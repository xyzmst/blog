<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷石的博客</title>
  <icon>https://coldstone.fun/avatar.png</icon>
  <subtitle>孑然一身，傲立于世</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coldstone.fun/"/>
  <updated>2019-10-26T07:19:44.997Z</updated>
  <id>https://coldstone.fun/</id>
  
  <author>
    <name>Cold Stone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker ARG vs ENV</title>
    <link href="https://coldstone.fun/post/2019/10/25/docker-arg-vs-env/"/>
    <id>https://coldstone.fun/post/2019/10/25/docker-arg-vs-env/</id>
    <published>2019-10-25T06:12:19.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>构建 Docker 镜像的的时候有两种环境变量 <code>ARG</code> 和 <code>ENV</code>, 一种是在运行 build 命令时通过 <code>--build-arg</code> 参数设置的 build-time variables 以及通过在 <code>dockerfile</code> 里面设置 <code>ENV</code> 指令配置的环境变量。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>构建 Docker 镜像的的时候有两种环境变量 <code>ARG</code> 和 <code>ENV</code>, 一种是在运行 build 命令时通过 <code>--build-arg</code> 参数设置的 build-time variables 以及通过在 <code>dockerfile</code> 里面设置 <code>ENV</code> 指令配置的环境变量，本文说明它们之间的区别。</p><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p>Dockerfile 里面的 ARG 指令定义了一个变量，在运行 <code>docker build</code> 命令时使用 <code>--build-arg &lt;varname&gt; = &lt;value&gt;</code> 参数将其传递给构建器。</p><pre><code class="dockerfile">ARG &lt;name&gt;[=&lt;default value&gt;]</code></pre><p>这种变量只存在于镜像构建的时候，一旦镜像构建完成就失效了，不要使用构建时变量来传递诸如 github 密钥，用户凭据等机密数据，构建时变量值可以使用 docker history 命令查看。</p><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>Dockerfile 里面的 ENV 指令将环境变量<key>设置为值<value>，这个变量将在构建阶段中所有后续指令的环境中使用。</value></key></p><pre><code class="dockerfile">ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ...</code></pre><p>使用 ENV 设置的环境变量将一直存在于构建镜像时以及镜像容器运行时，可以使用 docker inspect 查看设置打的变量。也可以使用 <code>docker run --env &lt;key&gt; = &lt;value&gt;</code> 来更改它们。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果只是需要构建镜像时的环境变量，使用 <code>ARG</code>，如果这个变量在容器运行时也有用到就需要用 <code>ENV</code>，注意使用 <code>ENV</code> 指令定义的环境变量会覆盖同名的 <code>ARG</code> 指令定义的变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;构建 Docker 镜像的的时候有两种环境变量 &lt;code&gt;ARG&lt;/code&gt; 和 &lt;code&gt;ENV&lt;/code&gt;, 一种是在运行 build 命令时通过 &lt;code&gt;--build-arg&lt;/code&gt; 参数设置的 build-time variables 以及通过在 &lt;code&gt;dockerfile&lt;/code&gt; 里面设置 &lt;code&gt;ENV&lt;/code&gt; 指令配置的环境变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://coldstone.fun/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>前端代码规范</title>
    <link href="https://coldstone.fun/post/2019/10/10/code-standard/"/>
    <id>https://coldstone.fun/post/2019/10/10/code-standard/</id>
    <published>2019-10-10T09:59:04.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>良好的代码规范有利于提高项目开发效率以及减少阅读代码的困难，本规范结合了(chaoxi)多个流行的代码规范以及前人的开发经验而成，参考规范进行开发提高代码质量</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>良好的代码规范有利于提高项目开发效率以及减少阅读代码的困难，本规范结合了(chaoxi)多个流行的代码规范以及前人的开发经验而成，参考规范进行开发提高代码质量</p><h2 id="HTML-规范"><a href="#HTML-规范" class="headerlink" title="HTML 规范"></a>HTML 规范</h2><p>设置标准模式的文档类型</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt; &lt;/head&gt;&lt;/html&gt;</code></pre><p>设置页面语言</p><pre><code class="html">&lt;html lang=&quot;zh-CN&quot;&gt;&lt;/html&gt;</code></pre><p>设置页面字符编码</p><pre><code class="html">&lt;meta charset=&quot;UTF-8&quot; /&gt;</code></pre><p>使用语义化的标签准确地描述网页的内容</p><pre><code class="html">&lt;main&gt;  &lt;article&gt;    &lt;header&gt;      &lt;h1&gt;title&lt;/h1&gt;      &lt;p&gt;published: &lt;time datetime=&quot;2015-02-21&quot;&gt;21st Feb, 2015&lt;/time&gt;&lt;/p&gt;    &lt;/header&gt;    &lt;p&gt;content&lt;/p&gt;  &lt;/article&gt;  &lt;aside&gt;...&lt;/aside&gt;  &lt;footer&gt;...&lt;/footer&gt;&lt;/main&gt;</code></pre><p>确保页面可访问性</p><ul><li>给 <code>img</code> 标签添加正确的 <code>alt</code> 属性</li><li>使用 <code>label</code> 标签对表单进行控制</li></ul><p>使用字符实体替代特殊字符</p><pre><code class="html">&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;copy;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;</code></pre><p>使用两个空格缩进</p><pre><code class="html">&lt;section&gt;  &lt;h1&gt;&lt;/h1&gt;&lt;/section&gt;</code></pre><p>按特定顺序书写标签属性</p><ol><li><code>class</code></li><li><code>id</code>, <code>name</code></li><li><code>data-*</code></li><li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code></li><li><code>title</code>, <code>alt</code></li><li><code>role</code>, <code>aria-*</code></li></ol><pre><code class="html">&lt;!-- 示例 --&gt;&lt;a class=&quot;link&quot; id=&quot;link&quot; data-toggle=&quot;modal&quot; href=&quot;#&quot;&gt;link&lt;/a&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot; /&gt;&lt;img src=&quot;example.jpg&quot; alt=&quot;dog&quot; /&gt;</code></pre><p>不对布尔属性赋值</p><pre><code class="html">&lt;!-- 示例 --&gt;&lt;input type=&quot;text&quot; disabled /&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked /&gt;&lt;select&gt;  &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="CSS-规范"><a href="#CSS-规范" class="headerlink" title="CSS 规范"></a>CSS 规范</h2><p>全局设置盒子模型</p><pre><code class="css">* {  box-sizing: border-box;}</code></pre><p>使用简洁的 class 命名</p><p>class 的命名应该尽量简洁、明确，以字母开头命名，且全部字母为小写，单词之间使用连字符 “-” 连接。<br>每个模块使用一个模块命名，子元素使用模块名 + 元素作用名名</p><pre><code class="html">&lt;!-- 示例 --&gt;&lt;header class=&quot;header&quot;&gt;  &lt;h1 class=&quot;header-title&quot;&gt;&lt;/h1&gt;&lt;/header&gt;</code></pre><p>使用常用的 class 命名</p><p><strong>包裹类：</strong> container, wrapper, outer, inner, box, header, footer, main, content, aside, page, section, block</p><p><strong>状态类：</strong> primary, secondary, success, danger, warning, info, error, link, light, dark, disabled, active, checked, loading</p><p><strong>尺寸类：</strong> large, middle, small, bigger, smaller</p><p><strong>组件类：</strong> card, list, picture, carousel, swiper, menu, navs, badge, hint, modal, dialog</p><p><strong>位置类：</strong> first, last, current, prev, next, forward, back</p><p><strong>文本类：</strong> title, desc, content, date, author, category，label，tag</p><p><strong>人物类：</strong> avatar, name, age, post, intro</p><table><thead><tr><th align="left">Class Name</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">about</td><td align="left">关于</td></tr><tr><td align="left">account</td><td align="left">账户</td></tr><tr><td align="left">arrow</td><td align="left">箭头图标</td></tr><tr><td align="left">article</td><td align="left">文章</td></tr><tr><td align="left">aside</td><td align="left">边栏</td></tr><tr><td align="left">audio</td><td align="left">音频</td></tr><tr><td align="left">avatar</td><td align="left">头像</td></tr><tr><td align="left">bg,background</td><td align="left">背景</td></tr><tr><td align="left">bar</td><td align="left">栏（工具类）</td></tr><tr><td align="left">branding</td><td align="left">品牌化</td></tr><tr><td align="left">crumb,breadcrumbs</td><td align="left">面包屑</td></tr><tr><td align="left">btn,button</td><td align="left">按钮</td></tr><tr><td align="left">caption</td><td align="left">标题，说明</td></tr><tr><td align="left">category</td><td align="left">分类</td></tr><tr><td align="left">chart</td><td align="left">图表</td></tr><tr><td align="left">clearfix</td><td align="left">清除浮动</td></tr><tr><td align="left">close</td><td align="left">关闭</td></tr><tr><td align="left">col,column</td><td align="left">列</td></tr><tr><td align="left">comment</td><td align="left">评论</td></tr><tr><td align="left">community</td><td align="left">社区</td></tr><tr><td align="left">container</td><td align="left">容器</td></tr><tr><td align="left">content</td><td align="left">内容</td></tr><tr><td align="left">copyright</td><td align="left">版权</td></tr><tr><td align="left">current</td><td align="left">当前态，选中态</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">description</td><td align="left">描述</td></tr><tr><td align="left">details</td><td align="left">细节</td></tr><tr><td align="left">disabled</td><td align="left">不可用</td></tr><tr><td align="left">entry</td><td align="left">文章，博文</td></tr><tr><td align="left">error</td><td align="left">错误</td></tr><tr><td align="left">even</td><td align="left">偶数，常用于多行列表或表格中</td></tr><tr><td align="left">fail</td><td align="left">失败（提示）</td></tr><tr><td align="left">feature</td><td align="left">专题</td></tr><tr><td align="left">fewer</td><td align="left">收起</td></tr><tr><td align="left">field</td><td align="left">用于表单的输入区域</td></tr><tr><td align="left">figure</td><td align="left">图</td></tr><tr><td align="left">filter</td><td align="left">筛选</td></tr><tr><td align="left">first</td><td align="left">第一个，常用于列表中</td></tr><tr><td align="left">footer</td><td align="left">页脚</td></tr><tr><td align="left">forum</td><td align="left">论坛</td></tr><tr><td align="left">gallery</td><td align="left">画廊</td></tr><tr><td align="left">group</td><td align="left">模块，清除浮动</td></tr><tr><td align="left">header</td><td align="left">页头</td></tr><tr><td align="left">help</td><td align="left">帮助</td></tr><tr><td align="left">hide</td><td align="left">隐藏</td></tr><tr><td align="left">hightlight</td><td align="left">高亮</td></tr><tr><td align="left">home</td><td align="left">主页</td></tr><tr><td align="left">icon</td><td align="left">图标</td></tr><tr><td align="left">info,information</td><td align="left">信息</td></tr><tr><td align="left">last</td><td align="left">最后一个，常用于列表中</td></tr><tr><td align="left">links</td><td align="left">链接</td></tr><tr><td align="left">login</td><td align="left">登录</td></tr><tr><td align="left">logout</td><td align="left">退出</td></tr><tr><td align="left">logo</td><td align="left">标志</td></tr><tr><td align="left">main</td><td align="left">主体</td></tr><tr><td align="left">menu</td><td align="left">菜单</td></tr><tr><td align="left">meta</td><td align="left">作者、更新时间等信息栏，一般位于标题之下</td></tr><tr><td align="left">module</td><td align="left">模块</td></tr><tr><td align="left">more</td><td align="left">更多（展开）</td></tr><tr><td align="left">msg,message</td><td align="left">消息</td></tr><tr><td align="left">nav,navigation</td><td align="left">导航</td></tr><tr><td align="left">next</td><td align="left">下一页</td></tr><tr><td align="left">nub</td><td align="left">小块</td></tr><tr><td align="left">odd</td><td align="left">奇数，常用于多行列表或表格中</td></tr><tr><td align="left">off</td><td align="left">鼠标离开</td></tr><tr><td align="left">on</td><td align="left">鼠标移过</td></tr><tr><td align="left">output</td><td align="left">输出</td></tr><tr><td align="left">pagination</td><td align="left">分页</td></tr><tr><td align="left">pop,popup</td><td align="left">弹窗</td></tr><tr><td align="left">preview</td><td align="left">预览</td></tr><tr><td align="left">previous</td><td align="left">上一页</td></tr><tr><td align="left">primary</td><td align="left">主要</td></tr><tr><td align="left">progress</td><td align="left">进度条</td></tr><tr><td align="left">promotion</td><td align="left">促销</td></tr><tr><td align="left">rcommd,recommendations</td><td align="left">推荐</td></tr><tr><td align="left">reg,register</td><td align="left">注册</td></tr><tr><td align="left">save</td><td align="left">保存</td></tr><tr><td align="left">search</td><td align="left">搜索</td></tr><tr><td align="left">secondary</td><td align="left">次要</td></tr><tr><td align="left">section</td><td align="left">区块</td></tr><tr><td align="left">selected</td><td align="left">已选</td></tr><tr><td align="left">share</td><td align="left">分享</td></tr><tr><td align="left">show</td><td align="left">显示</td></tr><tr><td align="left">sidebar</td><td align="left">边栏，侧栏</td></tr><tr><td align="left">slide</td><td align="left">幻灯片，图片切换</td></tr><tr><td align="left">sort</td><td align="left">排序</td></tr><tr><td align="left">sub</td><td align="left">次级的，子级的</td></tr><tr><td align="left">submit</td><td align="left">提交</td></tr><tr><td align="left">subscribe</td><td align="left">订阅</td></tr><tr><td align="left">subtitle</td><td align="left">副标题</td></tr><tr><td align="left">success</td><td align="left">成功（提示）</td></tr><tr><td align="left">summary</td><td align="left">摘要</td></tr><tr><td align="left">tab</td><td align="left">标签页</td></tr><tr><td align="left">table</td><td align="left">表格</td></tr><tr><td align="left">txt,text</td><td align="left">文本</td></tr><tr><td align="left">thumbnail</td><td align="left">缩略图</td></tr><tr><td align="left">time</td><td align="left">时间</td></tr><tr><td align="left">tips</td><td align="left">提示</td></tr><tr><td align="left">title</td><td align="left">标题</td></tr><tr><td align="left">video</td><td align="left">视频</td></tr><tr><td align="left">wrap</td><td align="left">容器，包，一般用于最外层</td></tr><tr><td align="left">wrapper</td><td align="left">容器，包，一般用于最外层</td></tr></tbody></table><p>不使用 ID 选择器</p><pre><code class="css">// bad#title {  color: blue;}// good.title {  color: blue;}</code></pre><p>不要为 <code>0</code> 值设置单位</p><pre><code class="css">// bad.content {  margin-top: 0px;}// good.content {  margin-top: 0;}</code></pre><p>遵循以下的样式书写顺序</p><ol><li>布局定位属性：position / display / float / clear / visibility / overflow</li><li>盒属性：width / height / margin / padding / border / background</li><li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li><li>视觉属性：background-color / border / border-radius / box-shadow</li><li>其他属性：content / cursor / text-shadow / background:linear-gradient</li></ol><pre><code class="css">.box {  /* Positioning */  position: absolute;  top: 0;  right: 0;  bottom: 0;  left: 0;  z-index: 100;  /* Box-model */  display: block;  float: right;  width: 100px;  height: 100px;  /* Typography */  font: normal 13px &#39;Helvetica Neue&#39;, sans-serif;  line-height: 1.5;  color: #333;  text-align: center;  /* Visual */  background-color: #f5f5f5;  border: 1px solid #e5e5e5;  border-radius: 3px;  /* Misc */  opacity: 1;}</code></pre><p>嵌套选择器的深度不要超过 3 层</p><pre><code class="css">.container {  .content {    .profile {      /* STOP! */    }  }}</code></pre><p>不要使用 <code>@import</code></p><pre><code class="html">/* bad */ @import url(&quot;other.css&quot;); /* good */&lt;link rel=&quot;stylesheet&quot; href=&quot;other.css&quot; /&gt;</code></pre><p>将媒体查询语句放在靠近相关规则最近的位置</p><pre><code class="css">.element {  /* ... */}.element-avatar {  /* ... */}.element-selected {  /* ... */}@media (min-width: 480px) {  .element {    /* ... */  }  .element-avatar {    /* ... */  }  .element-selected {    /* ... */  }}</code></pre><p>使用简短的申明语句</p><pre><code class="css">// bad.content {  padding-top: 10px;  padding-bottom: 10px;  padding-left: 20px;  padding-right: 20px;}// good.content {  padding: 10px 20px;}</code></pre><p>使用 stylelint 检查样式代码</p><p><a href="https://github.com/shinnn/vscode-stylelint" target="_blank" rel="noopener">https://github.com/shinnn/vscode-stylelint</a></p><h2 id="JS-规范"><a href="#JS-规范" class="headerlink" title="JS 规范"></a>JS 规范</h2><p>使用 const 优于 let，弃用 var</p><pre><code class="javascript">// badvar name = &#39;jack&#39;let myVariable = &#39;myVariable&#39;// goodconst FIRST_US_PRESIDENT = &#39;George Washington&#39;</code></pre><p>使用字面量创建对象</p><pre><code class="javascript">// badconst a = new Object{}// goodconst obj = {}</code></pre><p>函数名或方法名使用动宾短语</p><pre><code class="javascript">// badfunction userInfo() {    ...}// goodfunction getUserInfo() {    ...}</code></pre><p>命名所有的方法包含闭包和回调, 避免匿名方法</p><p>命名方法和函数可以让你在代码运行出错时更快的找到错误</p><p>布尔值变量使用 is 开头的词组</p><pre><code class="javascript">// badconst finished = false// goodconst isFinished = false</code></pre><p>避免重复的描述对象</p><pre><code class="javascript">// badconst car = {  carMake: &#39;Honda&#39;,  carModel: &#39;Accord&#39;,  carColor: &#39;Blue&#39;}// goodconst Car = {  make: &#39;Honda&#39;,  model: &#39;Accord&#39;,  color: &#39;Blue&#39;}</code></pre><p>使用有意义可读性好的变量名</p><pre><code class="javascript">// badconst yyyymmdstr = moment().format(&#39;YYYY/MM/DD&#39;)for (var i = 0; i &lt; 525600; i++) {  runCronJob()}// goodconst yearMonthDay = moment().format(&#39;YYYY/MM/DD&#39;)const MINUTES_IN_A_YEAR = 525600for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) {  runCronJob()}</code></pre><p>将函数参数限制 2 个以内</p><pre><code class="javascript">// badfunction createMenu(title, body, buttonText, cancellable) {  ...}// goodconst menuConfig = {  title: &#39;Foo&#39;,  body: &#39;Bar&#39;,  buttonText: &#39;Baz&#39;,  cancellable: true}function createMenu(menuConfig) {  ...}</code></pre><p>封装判断条件</p><p>将多个条件的判断结果赋值给一个变量或使用一个函数返回</p><pre><code class="javascript">// badif (fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode)) {  /// ...}// goodfunction shouldShowSpinner(fsm, listNode) {  return fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode)}if (shouldShowSpinner(fsmInstance, listNodeInstance)) {  // ...}</code></pre><p>避免否定情况的判断</p><p>尽可能只使用正向的判断</p><pre><code class="javascript">// badif(!isLoading) {  ...}// goodif(isLoading) {  ...}</code></pre><p>删除无效的代码</p><p>及时删除不再被调用的代码，避免给阅读代码带来困扰</p><p>使用 <code>try/catch</code> 语句捕获可能出现的错误</p><pre><code class="js">try {  functionThatMightThrow()} catch (error) {  // 不单单只是使用 console  console.error(error)  // 更多的错误处理  notifyUserOfError(error)  // 报告错误  reportErrorToService(error)}</code></pre><p>只注释业务逻辑复杂性的代码</p><pre><code class="js">function hashIt(data) {  var hash = 0  var length = data.length  for (var i = 0; i &lt; length; i++) {    var char = data.charCodeAt(i)    hash = (hash &lt;&lt; 5) - hash + char    // Convert to 32-bit integer    hash = hash &amp; hash  }}</code></pre><h2 id="Vue-规范"><a href="#Vue-规范" class="headerlink" title="Vue 规范"></a>Vue 规范</h2><p>将组件名命名为多个单词</p><pre><code class="json">// badtodo.vue// goodtodo-item.vue</code></pre><p>使用 PascalCase 或者 kebab-case 命名组件</p><pre><code class="html">&lt;!-- bad  --&gt;components/ |- mycomponent.vue components/ |- myComponent.vue&lt;!-- good --&gt;components/ |- MyComponent.vue components/ |- my-component.vue</code></pre><p>详细定义组件的 Prop</p><pre><code class="javascript">// badprops: [&#39;status&#39;]// goodprops: {   status: {    type: String,    required: true  }}</code></pre><p>在 v-for 循环上加 key</p><pre><code class="html">&lt;!-- bad --&gt;&lt;li v-for=&quot;todo in todos&quot;&gt;  {{ todo.text }}&lt;/li&gt;&lt;!-- good --&gt;&lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;  {{ todo.text }}&lt;/li&gt;</code></pre><p>不要把 v-if 和 v-for 同时用在同一个元素上</p><pre><code class="html">&lt;!-- bad --&gt;&lt;ul&gt;  &lt;li v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; :key=&quot;user.id&quot;&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;&lt;!-- good --&gt;&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;  &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot;&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;</code></pre><p>为组件样式设置作用域</p><pre><code class="html">&lt;!-- bad --&gt;&lt;template&gt;  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style&gt;  .btn-close {    background-color: red;  }&lt;/style&gt;&lt;!--  good --&gt;&lt;template&gt;  &lt;button class=&quot;c-button c-button--close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 BEM 约定 --&gt;&lt;style&gt;  .c-button {    border: none;    border-radius: 2px;  }  .c-button--close {    background-color: red;  }&lt;/style&gt;</code></pre><p><strong>组件和实例的选项使用统一的顺序</strong></p><ol><li><strong>副作用</strong>(触发组件外的影响)</li></ol><ul><li><code>el</code></li></ul><ol start="2"><li><strong>全局感知</strong>(要求组件以外的知识)</li></ol><ul><li><code>name</code></li><li><code>parent</code></li></ul><ol start="3"><li><strong>组件类型</strong>(更改组件的类型)</li></ol><ul><li><code>functional</code></li></ul><ol start="4"><li><strong>模板修改器</strong>(改变模板的编译方式)</li></ol><ul><li><code>delimiters</code></li><li><code>comments</code></li></ul><ol start="5"><li><strong>模板依赖</strong>(模板内使用的资源)</li></ol><ul><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li></ul><ol start="6"><li><strong>组合</strong>(向选项里合并属性)</li></ol><ul><li><code>extends</code></li><li><code>mixins</code></li></ul><ol start="7"><li><strong>接口</strong>(组件的接口)</li></ol><ul><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props</code>/<code>propsData</code></li></ul><ol start="8"><li><strong>本地状态</strong>(本地的响应式属性)</li></ol><ul><li><code>data</code></li><li><code>computed</code></li></ul><ol start="9"><li><strong>事件</strong>(通过响应式事件触发的回调)</li></ol><ul><li><code>watch</code></li><li>生命周期钩子 (按照它们被调用的顺序)<ul><li><code>beforeCreate</code></li><li><code>created</code></li><li><code>beforeMount</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestroy</code></li><li><code>destroyed</code></li></ul></li></ul><ol start="10"><li><strong>非响应式的属性</strong>(不依赖响应系统的实例属性)</li></ol><ul><li><code>methods</code></li></ul><ol start="11"><li><strong>渲染</strong>(组件输出的声明式描述)</li></ol><ul><li><code>template</code>/<code>render</code></li><li><code>renderError</code></li></ul><p><strong>元素和组件的特性使用统一的顺序</strong></p><ol><li><strong>定义</strong>(提供组件的选项)</li></ol><ul><li><code>is</code></li></ul><ol start="2"><li><strong>列表渲染</strong>(创建多个变化的相同元素)</li></ol><ul><li><code>v-for</code></li></ul><ol start="3"><li><strong>条件渲染</strong>(元素是否渲染/显示)</li></ol><ul><li><code>v-if</code></li><li><code>v-else-if</code></li><li><code>v-else</code></li><li><code>v-show</code></li><li><code>v-cloak</code></li></ul><ol start="4"><li><strong>渲染方式</strong>(改变元素的渲染方式)</li></ol><ul><li><code>v-pre</code></li><li><code>v-once</code></li></ul><ol start="5"><li><strong>全局感知</strong>(需要超越组件的知识)</li></ol><ul><li><code>id</code></li></ul><ol start="6"><li><strong>唯一的特性</strong>(需要唯一值的特性)</li></ol><ul><li><code>ref</code></li><li><code>key</code></li><li><code>slot</code></li></ul><ol start="7"><li><strong>双向绑定</strong>(把绑定和事件结合起来)</li></ol><ul><li><code>v-model</code></li></ul><ol start="8"><li><strong>其它特性</strong> (所有普通的绑定或未绑定的特性)<br></li><li><strong>事件</strong>(组件事件监听器)</li></ol><ul><li><code>v-on</code></li></ul><ol start="10"><li><strong>内容</strong>(覆写元素的内容)</li></ol><ul><li><code>v-html</code></li><li><code>v-text</code></li></ul><p>保证一个组件专注于解决一个问题</p><p>确保一个组件是独立的、可复用的、微小的和可测试的</p><p>将行内表达式转为 computed</p><pre><code class="html">// bad&lt;template&gt;  &lt;h1&gt;    {{ (new Date()).getUTCFullYear() }}  &lt;/h1&gt;&lt;/template&gt;// good&lt;template&gt;  &lt;h1&gt;    {{ year }}  &lt;/h1&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;  export default {    computed: {      year() {        return new Date().getUTCFullYear()      }    }  }&lt;/script&gt;</code></pre><p>尽可能使用 mixins</p><p>Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin</p><pre><code class="javascript">const HelloMixin = {    methods: {      hello() {        console.log(&#39;hello&#39;)    }  }}// CompA&lt;script&gt;  import HelloMixin from &#39;./HelloMixin&#39;  export default {    name: &#39;CompA&#39;,    mixins: [HelloMixin]  }&lt;/script&gt;// CompB&lt;script&gt;  import HelloMixin from &#39;./HelloMixin&#39;  export default {    name: &#39;CompB&#39;,    mixins: [HelloMixin]  }&lt;/script&gt;</code></pre><h2 id="Node-规范"><a href="#Node-规范" class="headerlink" title="Node 规范"></a>Node 规范</h2><p>require 文件夹，而不是文件</p><p>在一个文件夹中开发库/模块，放置一个文件 index.js 暴露模块的内部</p><p>使用 .npmrc 锁住依赖版本</p><p>代码必须在所有的环境中是相同的，但是 Npm 默认情况下会拿包的最新版本，配置 .npmrc 锁定依赖版本</p><pre><code class="basic">save-exact=true</code></pre><p>在 Node 外管理前端资源</p><p>使用专门的中间件（nginx，S3，CDN）服务前端内容，这是因为在处理大量静态文件的时候，由于 node 的单线程模型，它的性能很受影响</p><p>使用中间件限制并发请求</p><p>DOS 攻击非常流行而且相对容易处理。使用外部服务，比如 cloud 负载均衡, cloud 防火墙, nginx, 或者（对于小的，不是那么重要的 app）一个速率限制中间件(比如<a href="https://www.npmjs.com/package/express-rate-limit" target="_blank" rel="noopener">express-rate-limit</a>)，来实现速率限制。否则应用程序可能受到攻击, 导致拒绝服务, 在这种情况下, 真实用户会遭受服务降级或不可用。</p><p>验证传入的 JSON schemas</p><p>验证传入请求的 body payload，并确保其符合预期要求, 如果没有, 则快速报错。为了避免每个路由中繁琐的验证编码, 您可以使用基于 JSON 的轻量级验证架构，比如 <a href="https://www.npmjs.com/package/jsonschema" target="_blank" rel="noopener">jsonschema</a> or <a href="https://www.npmjs.com/package/joi" target="_blank" rel="noopener">joi</a>，否则您疏忽和宽松的方法大大增加了攻击面, 并鼓励攻击者尝试许多输入, 直到他们找到一些组合, 使应用程序崩溃。</p><p>使用非 root 用户运行 Node.js</p><p>Node.js 作为一个具有无限权限的 root 用户运行，这是一种普遍的情景。例如，在 Docker 容器中，这是默认行为。建议创建一个非 root 用户，并保存到 Docker 镜像中（下面给出了示例），或者通过调用带有”-u username” 的容器来代表此用户运行该进程，否则在服务器上运行脚本的攻击者在本地计算机上获得无限制的权利 (例如，改变 iptable，引流到他的服务器上)</p><h2 id="其它规范"><a href="#其它规范" class="headerlink" title="其它规范"></a>其它规范</h2><p>使用 jest 进行单元测试</p><p>通常只要求对一些基础/底层的组件、函数进行测试, 视情况考虑是否要测试业务代码</p><p>使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fprettier.io">Prettier</a> 格式化代码</p><p><br>所有代码格式相关的工作都可以交给 Prettier 来做</p><p>合理的图片命名</p><p>图片业务 + 图片功能类别 + 图片模块名称 + 图片精度</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li><li><a href="https://guide.aotu.io/" target="_blank" rel="noopener">O2 前端规范文档</a></li><li><a href="https://github.com/alivebao/clean-code-js" target="_blank" rel="noopener">JavaScript 风格指南</a></li><li><a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">Vue 风格指南</a></li><li><a href="https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md" target="_blank" rel="noopener">Vue.js 组件编码规范</a></li><li><a href="https://github.com/goldbergyoni/nodebestpractices/blob/master/README.chinese.md" target="_blank" rel="noopener">Node.js 最佳实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;良好的代码规范有利于提高项目开发效率以及减少阅读代码的困难，本规范结合了(chaoxi)多个流行的代码规范以及前人的开发经验而成，参考规范进行开发提高代码质量&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Standard" scheme="https://coldstone.fun/tags/Standard/"/>
    
  </entry>
  
  <entry>
    <title>使用 Intl 对象进行日期时间格式化</title>
    <link href="https://coldstone.fun/post/2019/10/05/js-intl/"/>
    <id>https://coldstone.fun/post/2019/10/05/js-intl/</id>
    <published>2019-10-05T04:04:00.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>平时项目中要对日期时间格式化通常会使用如 <a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">dayjs</a>，<a href="https://github.com/date-fns/date-fns" target="_blank" rel="noopener">date-fns</a>，<a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment</a> 这些第三方库，但是我们可能只需要某几个方法，却安装了一整个库，大大增加了项目的体积，具体可以看这篇文章的数据 <a href="https://github.com/you-dont-need/You-Dont-Need-Momentjs" target="_blank" rel="noopener">You-Dont-Need-Momentjs</a>。本文主要说明如何使用浏览器自带的 Intl 对象进行日期时间的格式化</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时项目中要对日期时间格式化通常会使用如 <a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">dayjs</a>，<a href="https://github.com/date-fns/date-fns" target="_blank" rel="noopener">date-fns</a>，<a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment</a> 这些第三方库，但是我们可能只需要某几个方法，却安装了一整个库，大大增加了项目的体积，具体可以看这篇文章的数据 <a href="https://github.com/you-dont-need/You-Dont-Need-Momentjs" target="_blank" rel="noopener">You-Dont-Need-Momentjs</a>。本文主要说明如何使用浏览器自带的 Intl 对象进行日期时间的格式化</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl" target="_blank" rel="noopener">MDN</a></p><blockquote><p>Intl 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比、数字格式化，和日期时间格式化。Collator，NumberFormat 和 DateTimeFormat 对象的构造函数是 Intl 对象的属性。本页文档内容包括了这些属性，以及国际化使用的构造器和其他语言的方法等常见的功能。</p></blockquote><h2 id="日期时间格式化"><a href="#日期时间格式化" class="headerlink" title="日期时间格式化"></a>日期时间格式化</h2><p>要对日期时间格式化就要使用 <code>Intl.DateTimeFormat</code> 对象，它是根据语言来格式化日期和时间的构造函数。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>第一个参数是语言代码，第二个参数是构造函数的选项，都是可选的</p><pre><code class="js">new Intl.DateTimeFormat([locales[, options]])</code></pre><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><pre><code class="js">const date = new Date()console.log(new Intl.DateTimeFormat(&#39;en-US&#39;).format(date))// &quot;10/8/2019&quot;console.log(new Intl.DateTimeFormat(&#39;zh-CN&#39;).format(date))// &quot;2019/10/8&quot;console.log(  new Intl.DateTimeFormat(&#39;zh-CN&#39;, {    year: &#39;numeric&#39;,    month: &#39;numeric&#39;,    day: &#39;numeric&#39;,    weekday: &#39;long&#39;,    hour: &#39;numeric&#39;,    minute: &#39;numeric&#39;,    second: &#39;numeric&#39;,    hour12: false  }).format(date))// &quot;2019年10月8日星期二 15:07:04&quot;</code></pre><h3 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h3><p>参考文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat" target="_blank" rel="noopener">Intl.DateTimeFormat</a></p><h2 id="相对时间格式化"><a href="#相对时间格式化" class="headerlink" title="相对时间格式化"></a>相对时间格式化</h2><p>使用 Intl.RelativeTimeFormat 对相对时间进行格式化</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>同上，第一个参数是语言代码，第二个参数是构造函数的选项，都是可选的</p><pre><code class="js">new Intl.RelativeTimeFormat([locales[, options]])</code></pre><h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><pre><code class="js">const rtf = new Intl.RelativeTimeFormat(&#39;zh-CN&#39;)console.log(rtf.format(-3, &#39;day&#39;))// &quot;3天前&quot;console.log(rtf.format(3, &#39;day&#39;))// &quot;3天后&quot;console.log(rtf.format(3, &#39;minute&#39;))// &quot;3分钟后&quot;console.log(rtf.format(-3, &#39;second&#39;))// &quot;3秒钟前&quot;</code></pre><h3 id="详细使用-1"><a href="#详细使用-1" class="headerlink" title="详细使用"></a>详细使用</h3><p>参考文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RelativeTimeFormat#%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">Intl.RelativeTimeFormat</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhangxinxu.com/wordpress/2019/09/js-intl-zh/" target="_blank" rel="noopener">Intl</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl" target="_blank" rel="noopener">JS Intl 对象完整简介及在中文中的应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时项目中要对日期时间格式化通常会使用如 &lt;a href=&quot;https://github.com/iamkun/dayjs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dayjs&lt;/a&gt;，&lt;a href=&quot;https://github.com/date-fns/date-fns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;date-fns&lt;/a&gt;，&lt;a href=&quot;https://github.com/moment/moment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;moment&lt;/a&gt; 这些第三方库，但是我们可能只需要某几个方法，却安装了一整个库，大大增加了项目的体积，具体可以看这篇文章的数据 &lt;a href=&quot;https://github.com/you-dont-need/You-Dont-Need-Momentjs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;You-Dont-Need-Momentjs&lt;/a&gt;。本文主要说明如何使用浏览器自带的 Intl 对象进行日期时间的格式化&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="https://coldstone.fun/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之集合</title>
    <link href="https://coldstone.fun/post/2019/10/01/dsa-set/"/>
    <id>https://coldstone.fun/post/2019/10/01/dsa-set/</id>
    <published>2019-10-01T02:46:48.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>集合是一种包含不同元素的数据结构，集合中的元素称之为成员。集合有两个重要的特性，一是集合中的成员是无序的，其次集合中不存在相同的成员。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集合是一种包含不同元素的数据结构，集合中的元素称之为成员。集合有两个重要的特性，一是集合中的成员是无序的，其次集合中不存在相同的成员。</p><h2 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h2><p>不包含任何成员的集合称为空集，全集则是包含可能一切成员的集合。<br>如果两个集合的成员完全相等，则两个集合相等。<br>如果一个集合的所有成员都属于另一个集合，则认为这个集合是另一个集合的子集。<br>并集-将两个集合的成员合并的操作。<br>交集-将两个集合共有的成员组成一个新的集合。<br>补集-属于一个集合而不属于另一个集合的成员。</p><h2 id="实现集合"><a href="#实现集合" class="headerlink" title="实现集合"></a>实现集合</h2><pre><code class="ts">class MySet {  data = &lt;any&gt;[]  get size() {    return this.data.length  }  add(element: any) {    if (this.data.indexOf(element) &gt; -1) {      return false    }    this.data.push(element)  }  remove(element: any) {    const index = this.data.indexOf(element)    if (index &gt; -1) {      this.data.splice(index, 1)      return true    }    return false  }  contains(element: any) {    if (this.data.indexOf(element) &gt; -1) {      return true    }    return false  }  // 并集  uinon(set: MySet) {    const newSet = new MySet()    this.data.forEach((e: any) =&gt; newSet.add(e))    for (let index = 0; index &lt; set.data.length; index++) {      const ele = set.data[index]      if (!newSet.contains(ele)) {        newSet.add(ele)      }    }    return newSet  }  // 交集  intersect(set: MySet) {    const newSet = new MySet()    this.data.forEach((ele: any) =&gt; {      if (set.contains(ele)) {        newSet.add(ele)      }    })    return newSet  }  // 判断是否是补集  subset(set: MySet) {    if (this.size &gt; set.size) {      return false    } else {      for (let index = 0; index &lt; this.data.length; index++) {        const element = this.data[index]        if (!set.contains(element)) {          return false        }      }      return true    }  }  // 返回集合中不同的成员  difference(set: MySet) {    const newSet = new MySet()    for (let index = 0; index &lt; this.data.length; index++) {      const element = this.data[index]      if (!set.contains(element)) {        newSet.add(element)      }    }    return newSet  }  show() {    return this.data.forEach((e: any) =&gt; console.log(e))  }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="ts">const setOne = new MySet()setOne.add(&#39;a&#39;)setOne.add(&#39;b&#39;)setOne.add(&#39;c&#39;)const setTwo = new MySet()setTwo.add(&#39;c&#39;)setTwo.add(&#39;d&#39;)setTwo.add(&#39;e&#39;)setTwo.add(&#39;f&#39;)const setThree = setOne.uinon(setTwo)console.log(&#39;合集&#39;)setThree.show()// 合集// a b c d e fconst setFour = setOne.intersect(setTwo)console.log(&#39;交集&#39;)setFour.show()// 交集// cconst isSubset = setOne.subset(setTwo)console.log(&#39;是否是补集&#39;, isSubset)// 是否是补集 falseconst setSix = setOne.difference(setTwo)console.log(&#39;查看集合中不同的成员&#39;)setSix.show()// 查看集合中不同的成员// a b</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合是一种包含不同元素的数据结构，集合中的元素称之为成员。集合有两个重要的特性，一是集合中的成员是无序的，其次集合中不存在相同的成员。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>使用 Provider 管理 Flutter 应用状态 (下)</title>
    <link href="https://coldstone.fun/post/2019/09/23/flutter-provider-todos-02/"/>
    <id>https://coldstone.fun/post/2019/09/23/flutter-provider-todos-02/</id>
    <published>2019-09-23T08:17:17.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>紧接上篇，对于一个代办事项的新增，修改，删除功能都已经完成了，但是数据都是保存在内存中的，重新启动应用数据就重置了，为了存储数据可以将数据存到手机的存储里面或者存到远程服务器上，本文就实现如何使用 <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">dio</a> 将数据存到服务器</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>紧接上篇，对于一个代办事项的新增，修改，删除功能都已经完成了，但是数据都是保存在内存中的，重新启动应用数据就重置了，为了存储数据可以将数据存到手机的存储里面或者存到远程服务器上，本文就实现如何使用 <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">dio</a> 将数据存到服务器</p><p><a href="https://github.com/xrr2016/flutter_provider_todos/tree/http" target="_blank" rel="noopener">源码地址</a></p><h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>在 <code>pubspec.yaml</code> 添加 dio 依赖；一个存储数据的服务，我用的是 <a href="https://jsonbox.io/" target="_blank" rel="noopener">jsonbox</a></p><pre><code class="yml">dependencies:  dio: ^3.0.1</code></pre><h2 id="配置-dio"><a href="#配置-dio" class="headerlink" title="配置 dio"></a>配置 dio</h2><p>由于这个应用只有一个服务地址，所以创建一个 dio 的单例来进行请求就很好了，新建一个 request.dart 文件配置 dio，使用一个函数返回创建的 dio 实例</p><ul><li>设置基础的请求地址</li><li>设置请求超时时间</li><li>设置在调试控制台输出请求响应体方便查看请求</li></ul><p>基本设置下就可以用了，其它设置可以查看 dio 的<a href="https://pub.flutter-io.cn/packages/dio" target="_blank" rel="noopener">文档</a></p><pre><code class="dart">import &#39;package:dio/dio.dart&#39;;const DB_URL = &#39;https://jsonbox.io/box_7ea9df49e805cf99509b&#39;;Dio craeteDio() {  BaseOptions options = BaseOptions(    baseUrl: DB_URL,    connectTimeout: 5000,    receiveTimeout: 3000,  );  Dio dio = Dio(options);  dio.interceptors.add(LogInterceptor(    error: true,    request: false,    responseBody: true,    responseHeader: false,    requestHeader: false,  ));  return dio;}</code></pre><h2 id="修改-Todo-模型"><a href="#修改-Todo-模型" class="headerlink" title="修改 Todo 模型"></a>修改 Todo 模型</h2><p>由于需要从服务器上获取 todo 数据，服务返回的数据是 json 格式，所以需要在拿到数据的时候将单个 todo 的 json 数据转成 Todo 实例，新建一个 model/todo.dart 文件，比之前多的是两个方法而已，<code>fromJson</code> 这个工厂函数作用是使用 json 数据实例化一个 Todo，<code>toJson</code> 方法用来将一个 Todo 转成一个 Map 结构的数据</p><p>如果一个模型的字段较少可以手写，但是当字段较多比较复杂的时候就需要使用工具来帮助生成代码了，我使用的是 <a href="https://app.quicktype.io/" target="_blank" rel="noopener">quicktype</a> 这个工具</p><pre><code class="dart">class Todo {  String id;  bool finish;  String thing;  Todo({    this.id,    this.thing,    this.finish,  });  factory Todo.fromJson(Map&lt;String, dynamic&gt; json) =&gt; Todo(        id: json[&quot;_id&quot;].toString(),        thing: json[&quot;thing&quot;],        finish: json[&quot;finish&quot;],      );  Map&lt;String, dynamic&gt; toJson() =&gt; {        &quot;id&quot;: id,        &quot;thing&quot;: thing,        &quot;finish&quot;: finish,      };}</code></pre><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>配置好 dio 就可以在 todos.dart 向服务器发送请求了，修改 store/todos.dart，给 Todos 类添加了一个 _dio 属性用来发送请求，一个 getTodos 方法用来获取全部 todo 的列表数据，然后修改 addTodo，removeTodo，editTodo 方法使用 _dio 向服务器发送 post，delete，put 请求。</p><p>需要注意的一点是将 json 转换成实例的问题，很容易就会出现类似</p><pre><code class="dart">type &#39;List&lt;dynamic&gt;&#39; is not a subtype of type &#39;List&lt;Todo&gt;&#39;</code></pre><p>这种错误，这种都是类型转换的问题，我看了一篇文章后才算弄懂了一点 <a href="https://medium.com/flutter-community/parsing-complex-json-in-flutter-747c46655f51" target="_blank" rel="noopener">parsing-complex-json-in-flutter</a></p><pre><code class="dart">import &#39;package:dio/dio.dart&#39;;import &#39;package:flutter/foundation.dart&#39;;import &#39;../request.dart&#39;;import &#39;../model/todo.dart&#39;;class Todos extends ChangeNotifier {  List&lt;Todo&gt; _items = [];  Dio _dio = craeteDio();  get items {    return [..._items];  }  void refresh() {    notifyListeners();  }  Future&lt;List&gt; getTodos() async {    try {      Response response = await _dio.get(&#39;/todos&#39;);      final list = response.data as List;      _items = List&lt;Todo&gt;.from(list.map((i) =&gt; Todo.fromJson(i)).toList());      return items;    } on DioError catch (err) {      throw err;    }  }  Future addTodo(String thing) async {    try {      Response response = await _dio.post(&#39;/todos&#39;, data: {        &quot;thing&quot;: thing,        &quot;finish&quot;: false,      });      Todo todo = Todo(        thing: thing,        id: response.data[&quot;_id&quot;],        finish: response.data[&quot;finish&quot;],      );      _items.insert(0, todo);      refresh();    } on DioError catch (err) {      throw err;    }  }  Future removeTodo(int index) async {    try {      String todoId = _items[index].id;      await _dio.delete(&quot;/todos/$todoId&quot;);      _items.removeAt(index);      refresh();    } catch (err) {      throw err;    }  }  Future editTodo(int index, String thing, bool finish) async {    String todoId = _items[index].id;    try {      await _dio.put(&quot;/todos/$todoId&quot;, data: {        &quot;thing&quot;: thing,        &quot;finish&quot;: finish,      });      Todo todo = _items[index];      todo.thing = thing;      todo.finish = finish;      refresh();    } catch (e) {      throw e;    }  }  void toggleFinish(int index) {    final todo = _items[index];    todo.finish = !todo.finish;    refresh();  }  bool isTodoExist(String thing) {    bool isExist = false;    for (var i = 0; i &lt; _items.length; i++) {      final todo = _items[i];      if (todo.thing == thing) {        isExist = true;      }    }    return isExist;  }}</code></pre><h2 id="使用数据"><a href="#使用数据" class="headerlink" title="使用数据"></a>使用数据</h2><p>有了数据后就可以在列表页使用了，由于现在数据是从服务器返回的，会有请求耗时，所以需要使用 <code>FutureBuilder</code> 这个部件渲染列表，<code>FutureBuilder</code> 需要一个设置一个 future 来判断状态，这里自然是 Todos 类的 <code>getTodos</code> 方法返回的 Future 对象，然后 builder 就是一个函数，有两个参数，一个是 context 上下文对象，一个是 snapshot 对象，表示的是这个 future 的状态。</p><p>在 builder 方法里面用一个 switch 语句判断这个 future 的状态，根据状态返回需要渲染的部件，有以下几种状态 none（状态不存在），active（运行中），waiting（等待中），done（完成），如果都不匹配就，返回一个 null 值。</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;store/todos.dart&#39;;import &#39;widget/add_todo_button.dart&#39;;import &#39;widget/edit_todo_button.dart&#39;;import &#39;widget/remove_todo_button.dart&#39;;class TodosPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;Flutter Provider Todos&#39;)),      body: FutureBuilder(        future: Provider.of&lt;Todos&gt;(context).getTodos(),        builder: (context, snapshot) {          switch (snapshot.connectionState) {            case ConnectionState.none:              return Text(&#39;Press button to start.&#39;);            case ConnectionState.active:            case ConnectionState.waiting:              return Center(child: CircularProgressIndicator());            case ConnectionState.done:              if (snapshot.hasError) {                print(snapshot.error);                return Center(                  child: Text(                    &#39;出错了，请重试&#39;,                    style: TextStyle(fontSize: 18.0, color: Colors.red),                  ),                );              }              List items = snapshot.data;              if (items == null) {                return Center(                  child: Text(                    &#39;还没有代办事项，快去添加吧&#39;,                    style: TextStyle(fontSize: 18.0),                  ),                );              }              return ListView.builder(                  itemCount: items.length,                  itemBuilder: (_, index) {                    return Column(                      children: &lt;Widget&gt;[                        ListTile(                          title: Text(                            items[index].thing,                            style: TextStyle(                              color: items[index].finish                                  ? Colors.green                                  : Colors.grey,                            ),                          ),                          trailing: Container(                            width: 150,                            child: Row(                              mainAxisAlignment: MainAxisAlignment.end,                              children: &lt;Widget&gt;[                                EditTodoButton(todoIndex: index),                                RemoveTodoButton(todoIndex: index),                              ],                            ),                          ),                        ),                        Divider(),                      ],                    );                  });          }          return null;        },      ),      floatingActionButton: Consumer&lt;Todos&gt;(        builder: (_, todos, child) {          return AddTodoButton();        },      ),      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,    );  }}</code></pre><h2 id="修改按钮"><a href="#修改按钮" class="headerlink" title="修改按钮"></a>修改按钮</h2><p>接下来就是需要修改新增，编辑，删除代办的按钮了，同理由于现在需要跟服务端进行通信，所以需要根据请求状态来处理逻辑，主要的修改就是使用 <code>async/await</code> 语法等到一个请求完成后，根据返回值进行处理。</p><p>添加 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class AddTodoButton extends StatefulWidget {  @override  _AddTodoButtonState createState() =&gt; _AddTodoButtonState();}class _AddTodoButtonState extends State&lt;AddTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  final _controller = TextEditingController();  @override  void dispose() {    _formKey.currentState.dispose();    _controller.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (_, todos, child) {        _addTodo() async {          final isValid = _formKey.currentState.validate();          if (!isValid) {            return;          }          final thing = _controller.value.text;          try {            await todos.addTodo(thing);            Navigator.pop(context);            _controller.clear();          } catch (e) {            Scaffold.of(context).showSnackBar(              SnackBar(content: Text(&#39;新增代办失败了，请重试。&#39;)),            );          }        }        return FloatingActionButton(          child: Icon(Icons.add),          onPressed: () {            print(&#39;add todo&#39;);            return showDialog(              context: context,              builder: (BuildContext _) {                return SimpleDialog(                  title: Text(&#39;添加 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: true,                            autovalidate: false,                            controller: _controller,                            keyboardType: TextInputType.text,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              bool isExist = todos.isTodoExist(val);                              if (isExist) {                                return &#39;这件事情已经存在了&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () {                                  Navigator.pop(context);                                },                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: _addTodo,                              ),                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><p>编辑 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../model/todo.dart&#39;;import &#39;../store/todos.dart&#39;;class EditTodoButton extends StatefulWidget {  final todoIndex;  const EditTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  _EditTodoButtonState createState() =&gt; _EditTodoButtonState();}class _EditTodoButtonState extends State&lt;EditTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  @override  void dispose() {    _formKey?.currentState?.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (context, todos, child) {        final todoIndex = widget.todoIndex;        final Todo todo = todos.items[todoIndex];        return IconButton(          color: Colors.blue,          icon: Icon(Icons.edit),          onPressed: () {            return showDialog(              context: context,              builder: (_) {                return SimpleDialog(                  title: Text(&#39;编辑 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: false,                            autovalidate: false,                            initialValue: todo.thing,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            onChanged: (val) {                              todo.thing = val;                            },                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          SwitchListTile(                            title: const Text(&#39;是否完成&#39;),                            value: todo.finish,                            onChanged: (bool value) {                              todo.finish = value;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () =&gt; Navigator.pop(context),                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: () async {                                  final isValid =                                      _formKey.currentState.validate();                                  if (!isValid) {                                    return;                                  }                                  try {                                    await todos.editTodo(                                      todoIndex,                                      todo.thing,                                      todo.finish,                                    );                                    Navigator.pop(context);                                  } catch (e) {                                    Scaffold.of(context).showSnackBar(                                      SnackBar(content: Text(&#39;修改代办失败了，请重试。&#39;)),                                    );                                  }                                },                              )                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><p>删除 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../model/todo.dart&#39;;import &#39;../store/todos.dart&#39;;class RemoveTodoButton extends StatelessWidget {  final int todoIndex;  const RemoveTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(builder: (_, todos, child) {      final Todo todo = todos.items[todoIndex];      return IconButton(        color: Colors.red,        icon: Icon(Icons.delete),        onPressed: () {          print(&#39;delete todo&#39;);          showDialog(            context: context,            builder: (BuildContext context) {              return AlertDialog(                title: Text(&#39;确认删除 ${todo.thing}?&#39;),                actions: &lt;Widget&gt;[                  FlatButton(                    child: Text(                      &#39;取消&#39;,                      style: TextStyle(color: Colors.grey),                    ),                    onPressed: () =&gt; Navigator.pop(context),                  ),                  FlatButton(                    child: Text(&#39;确认&#39;),                    onPressed: () async {                      await todos.removeTodo(todoIndex);                      Navigator.pop(context);                    },                  ),                ],              );            },          );        },      );    });  }}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此所有的数据都存储在服务器上了，重启应用数据也会从服务器上获取了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;紧接上篇，对于一个代办事项的新增，修改，删除功能都已经完成了，但是数据都是保存在内存中的，重新启动应用数据就重置了，为了存储数据可以将数据存到手机的存储里面或者存到远程服务器上，本文就实现如何使用 &lt;a href=&quot;https://github.com/flutterchina/dio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dio&lt;/a&gt; 将数据存到服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>使用 Provider 管理 Flutter 应用状态 (上)</title>
    <link href="https://coldstone.fun/post/2019/09/11/flutter-provider-todos-01/"/>
    <id>https://coldstone.fun/post/2019/09/11/flutter-provider-todos-01/</id>
    <published>2019-09-11T13:48:56.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>一个应用内通常会有两种数据，部件内部的使用的临时性数据以及很多部件使用的全局性数据，部件内部使用的数据可以通过 StatefulWidget 来管理，但是全局性的数据如果通过从上到下传递的方式会使代码写的十分繁琐，这时就需要一个状态管理工具来进行管理了，本文说明如何使用 Provider 来管理这种应用的全局性的数据</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个应用内通常会有两种数据，部件内部的使用的临时性数据以及很多部件使用的全局性数据，部件内部使用的数据可以通过 StatefulWidget 来管理，但是全局性的数据如果通过从上到下传递的方式会使代码写的十分繁琐，这时就需要一个状态管理工具来进行管理了，本文说明如何使用 Provider 来管理这种应用的全局性的数据</p><h2 id="什么是-Provider"><a href="#什么是-Provider" class="headerlink" title="什么是 Provider"></a>什么是 Provider</h2><p>官方的定义是： A mixture between dependency injection (DI) and state management, built with widgets for widgets. 翻译过来大意是一种依赖注入和状态管理的混合方案，使用部件创建，作用于部件 😅</p><p><a href="https://pub.flutter-io.cn/documentation/provider/latest/" target="_blank" rel="noopener">官方文档</a></p><h2 id="为什么要使用-Provider"><a href="#为什么要使用-Provider" class="headerlink" title="为什么要使用 Provider"></a>为什么要使用 Provider</h2><p>应用中通常会有一些很多部件都需要的数据，如用户的登录信息，用户设置，地理位置等，如果只是使用 StatefullWeight 的话就需要将状态提升到一个父部件中然后向下进行传递，会很繁琐，使用 provider 的话可以将对一种状态数据的操作放到一个文件内，然后使用到这个数据的部件只需要使用就可以了，当数据有变化时，部件会自动的重新构建，使界面更新。</p><h2 id="一个例子-🌰"><a href="#一个例子-🌰" class="headerlink" title="一个例子 🌰"></a>一个例子 🌰</h2><p>使用一个 todo 应用来说明如何在 Flutter 应用中使用 Provider，最终的完成的应用是这样的，可以新增，编辑和删除 todo。</p><p><a href="https://github.com/xrr2016/flutter_provider_todos" target="_blank" rel="noopener">源码地址</a></p><img src="images/provider-todos.png" width="360" style="max-width:360px"><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>首先使用命令行创建一个项目</p><pre><code class="sh">flutter create flutter_provider_todos</code></pre><p>然后在项目的 pubspec.yml 添加 provider</p><pre><code class="yml">dependencies:  provider: ^3.1.0</code></pre><p>创建一个 store 文件夹以及 todos.dart 用来存放应用中需要用到的全局性数据，新建一个 widget 目录，用来存放应用中的部件以及一个显示 todo 的页面 todos_page.dart</p><img src="images/todos-folder.jpg" width="360" style="max-width:360px"><p>首先创建 todos 这个全局性的数据，修改 store/todos.dart，创建一个 Todo 类表示一个代办事项，然后实现 Todos 类， Todos 混合了 ChangeNotifier 类，为了使用 notifyListeners 方法来通知 UI 更新，因此需要导入 foundation.dart，Todos 类使用一个 _items 数组存放 Todo 数据，以及其它对 Todo 进行操作的方法。</p><pre><code class="dart">import &#39;package:flutter/foundation.dart&#39;;class Todo {  bool finish;  String thing;  Todo({    @required this.thing,    this.finish = false,  });}class Todos extends ChangeNotifier {  List&lt;Todo&gt; _items = [    Todo(thing: &#39;Play lol&#39;, finish: true),    Todo(thing: &#39;Learn flutter&#39;, finish: false),    Todo(thing: &#39;Read book&#39;, finish: false),    Todo(thing: &#39;Watch anime&#39;, finish: false),  ];  get items {    return [..._items];  }  get finishTodos {    return _items.where((todo) =&gt; todo.finish);  }  void refresh() {    notifyListeners();  }  void addTodo(Todo todo) {    _items.insert(0, todo);    refresh();  }  void removeTodo(int index) {    _items.removeAt(index);    refresh();  }  void editTodo(int index, String newThing, bool isFinish) {    Todo todo = _items[index];    todo.thing = newThing;    todo.finish = isFinish;    refresh();  }  void toggleFinish(int index) {    final todo = _items[index];    todo.finish = !todo.finish;    refresh();  }  bool isTodoExist(String thing) {    bool isExist = false;    for (var i = 0; i &lt; _items.length; i++) {      final todo = _items[i];      if (todo.thing == thing) {        isExist = true;      }    }    return isExist;  }}</code></pre><p>然后使用 provider 提供的 ChangeNotifierProvider 方法将数据注册到整个应用，如果有多个数据就需要使用 MultiProvider 方法</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;todos_page.dart&#39;;import &#39;store/todos.dart&#39;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Todos&#39;,      debugShowCheckedModeBanner: false,      theme: ThemeData(        primarySwatch: Colors.green,      ),      home: ChangeNotifierProvider(        builder: (context) =&gt; Todos(),        child: TodosPage(),      ),    );  }}</code></pre><h3 id="列表页面"><a href="#列表页面" class="headerlink" title="列表页面"></a>列表页面</h3><p>接着就是实现显示 todo 列表的页面，这个页面就是要用到 Todos 类里面的数据的部件，要使用 provider 的数据首先要导入 provider 以及对应的数据类 Todos，然后用 Consumer 加类型 Todos 来使用这个数据</p><pre><code class="dart">Consumer&lt;Todos&gt;(  builder: (ctx, todos, child) {    return YourWidget()  },)</code></pre><p>这个页面使用了一个 ListView.builder() 来渲染 Todos，然后每一项使用一个 ListTile 展示。新增，编辑和删除对应了 3 个不同的部件，分别是 AddTodoButton()，EditTodoButton()， RemoveTodoButton()</p><pre><code class="dart">// todos_page.dartimport &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;store/todos.dart&#39;;import &#39;widget/add_todo_button.dart&#39;;import &#39;widget/edit_todo_button.dart&#39;;import &#39;widget/remove_todo_button.dart&#39;;class TodosPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;Flutter Provider Todos&#39;)),      body: Consumer&lt;Todos&gt;(        builder: (ctx, todos, child) {          List&lt;Todo&gt; items = todos.items;          return ListView.builder(            itemCount: items.length,            itemBuilder: (_, index) =&gt; Column(              children: &lt;Widget&gt;[                ListTile(                  title: Text(                    items[index].thing,                    style: TextStyle(                      color: items[index].finish ? Colors.green : Colors.grey,                    ),                  ),                  trailing: Container(                    width: 150,                    child: Row(                      mainAxisAlignment: MainAxisAlignment.end,                      children: &lt;Widget&gt;[                        EditTodoButton(todoIndex: index),                        RemoveTodoButton(todoIndex: index),                      ],                    ),                  ),                ),                Divider(),              ],            ),          );        },      ),      floatingActionButton: AddTodoButton(),      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,    );  }}</code></pre><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>接下来就是要实现这 3 个按钮了，在 widget 目录创建对应的文件，每个按钮都会使用到 Todos 类里面定义的方法，所以都需要导入 provider 和 Todos 类，点击按钮会弹出一个对话框询问对应的操作，</p><img src="images/todos-widget.jpg" style="max-width:360px"><p>添加 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class AddTodoButton extends StatefulWidget {  @override  _AddTodoButtonState createState() =&gt; _AddTodoButtonState();}class _AddTodoButtonState extends State&lt;AddTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  final _controller = TextEditingController();  @override  void dispose() {    _formKey.currentState.dispose();    _controller.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (_, todos, child) {        return FloatingActionButton(          child: Icon(Icons.add),          onPressed: () {            print(&#39;add todo&#39;);            return showDialog(              context: context,              builder: (BuildContext _) {                return SimpleDialog(                  title: Text(&#39;添加 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: true,                            autovalidate: false,                            controller: _controller,                            keyboardType: TextInputType.text,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              bool isExist = todos.isTodoExist(val);                              if (isExist) {                                return &#39;这件事情已经存在了&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () {                                  Navigator.pop(context);                                },                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: () {                                  final isValid =                                      _formKey.currentState.validate();                                  if (!isValid) {                                    return;                                  }                                  final thing = _controller.value.text;                                  todos.addTodo(Todo(                                    thing: thing,                                    finish: false,                                  ));                                  _controller.clear();                                  Navigator.pop(context);                                },                              )                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><img src="https://github.com/xrr2016/flutter_provider_todos/raw/master/add-todo.png" width="360" style="max-width:360px"><p>编辑 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class EditTodoButton extends StatefulWidget {  final todoIndex;  const EditTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  _EditTodoButtonState createState() =&gt; _EditTodoButtonState();}class _EditTodoButtonState extends State&lt;EditTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  @override  void dispose() {    _formKey?.currentState?.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (context, todos, child) {        final todoIndex = widget.todoIndex;        final Todo todo = todos.items[todoIndex];        return IconButton(          color: Colors.blue,          icon: Icon(Icons.edit),          onPressed: () {            return showDialog(              context: context,              builder: (context) {                return SimpleDialog(                  title: Text(&#39;编辑 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: false,                            autovalidate: false,                            initialValue: todo.thing,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            onChanged: (val) {                              todo.thing = val;                            },                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          SwitchListTile(                            title: const Text(&#39;是否完成&#39;),                            value: todo.finish,                            onChanged: (bool value) {                              todo.finish = value;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () =&gt; Navigator.pop(context),                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: () {                                  final isValid =                                      _formKey.currentState.validate();                                  if (!isValid) {                                    return;                                  }                                  Navigator.pop(context);                                  todos.editTodo(                                    todoIndex,                                    todo.thing,                                    todo.finish,                                  );                                },                              )                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><img src="https://github.com/xrr2016/flutter_provider_todos/raw/master/edit-todo.png" width="360" style="max-width:360px"><p>删除 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class RemoveTodoButton extends StatelessWidget {  final int todoIndex;  const RemoveTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(builder: (_, todos, child) {      final Todo todo = todos.items[todoIndex];      return IconButton(        color: Colors.red,        icon: Icon(Icons.delete),        onPressed: () {          print(&#39;delete todo&#39;);          showDialog(            context: context,            builder: (BuildContext context) {              return AlertDialog(                title: Text(&#39;确认删除 ${todo.thing}?&#39;),                actions: &lt;Widget&gt;[                  FlatButton(                    child: Text(                      &#39;取消&#39;,                      style: TextStyle(color: Colors.grey),                    ),                    onPressed: () =&gt; Navigator.pop(context),                  ),                  FlatButton(                    child: Text(&#39;确认&#39;),                    onPressed: () {                      todos.removeTodo(todoIndex);                      Navigator.pop(context);                    },                  ),                ],              );            },          );        },      );    });  }}</code></pre><img src="https://github.com/xrr2016/flutter_provider_todos/raw/master/remove-todo.png" width="360" style="max-width:360px"><p>可以看到要使用对应的方法需要的只是向对应的部件注入这个数据，然后使用就可以了</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>使用了 provider 后，数据以及对一个 Todo 的操作都放在一个文件里面了，不用在多个层级间传递数据，并且在数据变化时自动更新了 UI，所以是十分有必要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个应用内通常会有两种数据，部件内部的使用的临时性数据以及很多部件使用的全局性数据，部件内部使用的数据可以通过 StatefulWidget 来管理，但是全局性的数据如果通过从上到下传递的方式会使代码写的十分繁琐，这时就需要一个状态管理工具来进行管理了，本文说明如何使用 Provider 来管理这种应用的全局性的数据&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之哈希表</title>
    <link href="https://coldstone.fun/post/2019/09/08/dsa-hash/"/>
    <id>https://coldstone.fun/post/2019/09/08/dsa-hash/</id>
    <published>2019-09-08T08:26:45.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表是一种常用的数据结构，可以快速的插入和取用，但是查询数据效率低下</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>哈希表是一种常用的数据结构，可以快速的插入和取用，但是查询数据效率低下。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于数组实现哈希表，数组的长度是预先设定的，有需要是增加。最常见的是将数组的长度设为一个质数</p><pre><code class="ts">class HashTable {  table = &lt;any&gt;[]  constructor() {    this.table = Array.from({      length: 137    })  }  // 将字符串的 ASCLL 码相加对数组长度求余  hash(data: string) {    let total = 0    for (let index = 0; index &lt; data.length; index++) {      total += data.charCodeAt(index)    }    return total % this.table.length  }  // 更优的 hash 方法  betterHash(data: string) {    const H = 37    let total = 0    for (let index = 0; index &lt; data.length; index++) {      total += H * total + data.charCodeAt(index)    }    total = total % this.table.length    if (total &lt; 0) {      total += this.table.length - 1    }    return parseInt(total.toString())  }  // 存储数据  put(key: string, data: any) {    const pos = this.betterHash(key)    this.table[pos] = data  }  // 获取数据  get(key: string) {    return this.table[this.betterHash(key)]  }  // 显示数据  show() {    for (let index = 0; index &lt; this.table.length; index++) {      const item = this.table[index]      if (item) {        console.log(`${index}: ${item}`)      }    }  }}</code></pre><p>测试下</p><pre><code class="ts">const hashTable = new HashTable()hashTable.put(&#39;David&#39;, &#39;David&#39;)hashTable.put(&#39;Jennifer&#39;, &#39;Jennifer&#39;)hashTable.put(&#39;Donnie&#39;, &#39;Donnie&#39;)hashTable.put(&#39;Raymond&#39;, &#39;Raymond&#39;)hashTable.put(&#39;Cynthia&#39;, &#39;Cynthia&#39;)hashTable.put(&#39;Mike&#39;, &#39;Mike&#39;)hashTable.put(&#39;Clayton&#39;, &#39;Clayton&#39;)hashTable.put(&#39;Danny&#39;, &#39;Danny&#39;)hashTable.put(&#39;Jonathan&#39;, &#39;Jonathan&#39;)hashTable.show()console.log(&#39;Jonathan: &#39;, hashTable.get(&#39;Jonathan&#39;))</code></pre><p>输出</p><pre><code class="ts">12: Jennifer22: Raymond55: Donnie58: Clayton80: Jonathan82: Mike103: Cynthia110: DannyJonathan:  Jonathan</code></pre><h2 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h2><p>当哈希方法对于多个输入产生了相同的输出是就会出现碰撞，两种可以解决键的碰撞问题开链法以及线性探测法</p><p>开链法</p><p>开链法指的是在实现 hash 表的底层数组中，每个数组又是一个新的数据结构，比如另一个数组，这样即使有两个键 hash 后的值相同，依然被保存在同样的位置，但是他们在第二个数组中的位置是不同的。</p><p>要实现开链法，在创建存储键值的数组时，通过一个函数创建一个新的数组，然后将该数组赋值给 hash 表里的每一个元素，创建一个二维数组。</p><p>线性探测法</p><p>线性探测法指的是当发生碰撞时检查 hash 表里的下一个位置是否为空，如果为空就将数据存入该位置，如果不为空，则继续查找下一个位置，直到找到空位子为止。通常来说如果数组的大小是待存储数据个数的 1.5 倍时，那么用开链法；如果数组的大小是待存储的数据两倍以上时，那么使用线性探测法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表是一种常用的数据结构，可以快速的插入和取用，但是查询数据效率低下&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>在 Egg.js 中使用 Redis 缓存提升性能</title>
    <link href="https://coldstone.fun/post/2019/08/31/egg-redis-cache/"/>
    <id>https://coldstone.fun/post/2019/08/31/egg-redis-cache/</id>
    <published>2019-08-31T05:20:56.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一款开源的，基于 BSD 许可的，高级键值缓存和存储系统。Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog。你可以在这些类型上面运行原子操作，例如，追加字符串，增加哈希中的值，加入一个元素到列表，计算集合的交集、并集和差集，或者是从有序集合中获取最高排名的元素。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 是一款开源的，基于 BSD 许可的，高级键值缓存和存储系统。Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog。你可以在这些类型上面运行原子操作，例如，追加字符串，增加哈希中的值，加入一个元素到列表，计算集合的交集、并集和差集，或者是从有序集合中获取最高排名的元素。</p><p>要在 Egg.js 中使用 redis，只需要执行 <code>npm i redis</code> 命令即可。</p><p>通过一个例子来验证一下，创建一个可以返回开源仓库在 Github 上的 star 数量的数据接口，来测试使用 Redis 后带来的提升，代码地址: <a href="https://github.com/xrr2016/egg-redis-test" target="_blank" rel="noopener">https://github.com/xrr2016/egg-redis-test</a></p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>首先使用 Egg.js 创建一个项目</p><pre><code class="bash">mkdir egg-redis-test &amp;&amp; cd egg-redis-testnpm init egg --type=simplenpm i</code></pre><p>安装 redis</p><pre><code class="sh">npm i redis</code></pre><p>启动项目</p><pre><code class="bash">npm run devopen http://localhost:7001</code></pre><p>先创建 controller 和 service 目录，用来放处理请求和返回数据的方法，完成后的项目目录为</p><p><img src="/images/egg-folder.jpg" alt="folder"></p><p>修改 router.js 文件，添加路由，然后在 controller/home.js 文件实现 stars 方法</p><pre><code class="js">&#39;use strict&#39;module.exports = app =&gt; {  const { router, controller } = app  router.get(&#39;/&#39;, controller.home.index)  router.get(&#39;/stars&#39;, controller.home.stars)}</code></pre><p>修改 controller/home.js 文件，接收请求传过来的 query 参数向下传给 stars service 返回结果</p><pre><code class="js">&#39;use strict&#39;const Controller = require(&#39;egg&#39;).Controllerclass HomeController extends Controller {  async stars() {    const { ctx, service } = this    const { owner, name } = ctx.query    ctx.body = await service.home.stars(owner, name)  }}module.exports = HomeController</code></pre><p>在 service/home.js 里实现 stars 方法，需要做的就是通过 controller 传过来的 owner, name 参数，请求 Github 的接口，返回数据。</p><p>需要注意的是，这里请求的是 Github 的 graphql 接口，所以首先需要在 Github 上新建一个 token，token 不能直接写在代码里面，需要将 token 放在环境变量里，否则代码提交到 Github 后会失效。</p><p><img src="/images/redis-token.jpg" alt="token"></p><p>创建 token 后使用 <a href="https://github.com/motdotla/dotenv#readme" target="_blank" rel="noopener">dotenv</a> 保存环境变量，先安装然后在项目目录创建一个 .env 文件</p><pre><code class="bash">npm i dotenv</code></pre><p><img src="/images/env.jpg" alt="token"></p><p>然后就可以使用 egg.js 自带的 crul 方法向 Github 接口发送 post 请求，代码如下</p><pre><code class="js">&#39;use strict&#39;require(&#39;dotenv&#39;).config()const Service = require(&#39;egg&#39;).Serviceclass HomeService extends Service {  async stars(owner, name) {    function setResponse(name, stars) {      return { msg: `${name} has ${stars} stars.` }    }    const query = `      query {        repository(owner: ${owner}, name: ${name}) {          stargazers {            totalCount          }        }      }    `    const result = await this.ctx.curl(&#39;https://api.github.com/graphql&#39;, {      method: &#39;POST&#39;,      dataType: &#39;json&#39;,      headers: {        Authorization: `token ${process.env.TOKEN}`      },      data: JSON.stringify({ query }),      timeout: 10000    })    const data = result.data.data    return setResponse(name, data.repository.stargazers.totalCount)  }}module.exports = HomeService</code></pre><p>使用 postman 测试一下接口</p><p><img src="/images/redis-before.jpg" alt="folder"></p><p>耗时平均 1 秒左右，接下来就是使用 Redis 添加缓存，首先需要在本地安装 Redis，参考 <a href="https://redis.io/download" target="_blank" rel="noopener">Redis download</a>，Mac 可以直接使用 homebrew 安装</p><p>安装</p><pre><code class="bash">brew install redis</code></pre><p>启动</p><pre><code class="bash">redis-server /usr/local/etc/redis.conf</code></pre><p>进入 redis 命令行</p><pre><code class="bash">redis-cli</code></pre><p>缓存的主要逻辑就是，第一次请求完得到 Github 的数据将数据放到缓存中，再次请求的时候直接使用缓存中的数据，也需要给缓存设置一个过期时间，<br>需要从环境变量中拿到 token，post 请求的数据要用 JSON.stringify 方法传给 Github 接口，否则出现解析错误，代码如下</p><pre><code class="js">&#39;use strict&#39;require(&#39;dotenv&#39;).config()const redis = require(&#39;redis&#39;)const { promisify } = require(&#39;util&#39;)const Service = require(&#39;egg&#39;).Serviceconst REDIS_PORT = process.env.PORT || 6379const client = redis.createClient(REDIS_PORT)const getAsync = promisify(client.get).bind(client)const setexAsync = promisify(client.setex).bind(client)class HomeService extends Service {  async stars(owner, name) {    const key = `${owner}/${name}`    const stars = await getAsync(key)    function setResponse(name, stars) {      return { msg: `${name} has ${stars} stars.` }    }    if (stars !== null) {      return setResponse(name, stars)    }    const query = `      query {        repository(owner: ${owner}, name: ${name}) {          stargazers {            totalCount          }        }      }    `    const result = await this.ctx.curl(&#39;https://api.github.com/graphql&#39;, {      method: &#39;POST&#39;,      dataType: &#39;json&#39;,      headers: {        Authorization: `token ${process.env.TOKEN}`      },      data: JSON.stringify({ query }),      timeout: 10000    })    const data = result.data.data    await setexAsync(key, 10, data.repository.stargazers.totalCount)    return setResponse(name, data.repository.stargazers.totalCount)  }}module.exports = HomeService</code></pre><p>再次测试，首先把 Redis 里面的缓存清空，使用 Redis 的命令行运行</p><pre><code class="bash">FLUSHALL</code></pre><p>发送请求，第一次的耗时还是一秒多，然后在失效时间内请求，可以看到使用缓存的数据后耗时大大减少了，性能提升效果显著，实际项目可以设置一个较长的缓存失效时间</p><p><img src="/images/redis-after.jpg" alt="folder"></p><p>当然缓存过期后又要重新向 Github 发送请求了，因为 Redis 已经把数据删除了</p><p><img src="/images/redis-vue.jpg" alt="folder"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redis.io/documentation" target="_blank" rel="noopener">Redis documentation</a></p><p><a href="https://github.com/noderedis/node_redis" target="_blank" rel="noopener">Node Redis</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是一款开源的，基于 BSD 许可的，高级键值缓存和存储系统。Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog。你可以在这些类型上面运行原子操作，例如，追加字符串，增加哈希中的值，加入一个元素到列表，计算集合的交集、并集和差集，或者是从有序集合中获取最高排名的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Node" scheme="https://coldstone.fun/tags/Node/"/>
    
      <category term="Redis" scheme="https://coldstone.fun/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之字典</title>
    <link href="https://coldstone.fun/post/2019/08/28/dsa-dictionary/"/>
    <id>https://coldstone.fun/post/2019/08/28/dsa-dictionary/</id>
    <published>2019-08-28T13:09:13.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>字典是一种以键值对形式存储数据的数据结构，键用来查找，值用来保存数据</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字典是一种以键值对形式存储数据的数据结构，键用来查找，值用来保存数据</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="ts">class Dictionary {  data: any[] = []  // 添加元素  add(key: any, value: any) {    this.data[key] = value  }  // 查找元素  find(key: any) {    return this.data[key]  }  // 删除元素  remove(key: any) {    delete this.data[key]  }  // 显示元素  show() {    Object.entries(this.data).forEach(item =&gt; {      console.log(&#39;key:&#39;, item[0], &#39; value:&#39;, item[1])    })  }  // 元素个数  count() {    let n = 0    Object.keys(this.data).forEach(_ =&gt; {      n += 1    })    return n  }  // 清空元素  clear() {    Object.keys(this.data).forEach((key: any) =&gt; {      delete this.data[key]    })  }}</code></pre><p>测试</p><pre><code class="ts">const dictionary = new Dictionary()dictionary.add(&#39;a&#39;, &#39;a&#39;)dictionary.add(&#39;b&#39;, &#39;b&#39;)dictionary.add(&#39;c&#39;, &#39;c&#39;)dictionary.add(&#39;d&#39;, &#39;d&#39;)dictionary.add(&#39;e&#39;, &#39;e&#39;)dictionary.show()console.log(&#39;count: &#39;, dictionary.count())dictionary.clear()console.log(&#39;clear: &#39;, dictionary.count())</code></pre><p>输出</p><pre><code class="textmate">key: a  value: akey: b  value: bkey: c  value: ckey: d  value: dkey: e  value: ecount:  5clear:  0</code></pre><p>排序字典的输出，需要重新定义 show 方法</p><pre><code class="ts">// 显示元素show() {  Object.entries(this.data)    .sort()    .forEach(item =&gt; {      console.log(&#39;key:&#39;, item[0], &#39; value:&#39;, item[1])    })}</code></pre><p>测试一下</p><pre><code class="ts">const dictionary = new Dictionary()dictionary.add(&#39;c&#39;, &#39;c&#39;)dictionary.add(&#39;a&#39;, &#39;a&#39;)dictionary.add(&#39;d&#39;, &#39;d&#39;)dictionary.add(&#39;e&#39;, &#39;e&#39;)dictionary.add(&#39;b&#39;, &#39;b&#39;)dictionary.show()</code></pre><p>输出</p><pre><code class="textmate">key: a  value: akey: b  value: bkey: c  value: ckey: d  value: dkey: e  value: e</code></pre><p>使用 Object.keys 方法拿到字典的 keys 数组后，在用 sort 方法就可以显示有序的字典输出了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字典是一种以键值对形式存储数据的数据结构，键用来查找，值用来保存数据&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之链表</title>
    <link href="https://coldstone.fun/post/2019/08/25/dsa-linklist/"/>
    <id>https://coldstone.fun/post/2019/08/25/dsa-linklist/</id>
    <published>2019-08-25T04:49:36.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>链表是一组节点组成的集合，每个节点都使用一个对象的引用指向它的下一个节点，指向节点的引用叫做链</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>链表是一组节点组成的集合，每个节点都使用一个对象的引用指向它的下一个节点，指向节点的引用叫做链。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 LinkedListNode 类来表示节点，使用 LinkedList 来表示链表</p><pre><code class="ts">class LinkedListNode {  element: any  next: LinkedListNode  constructor(element: any) {    this.element = element    this.next = null  }}class LinkedList {  // 头节点  head: LinkedListNode  constructor() {    this.head = new LinkedListNode(&#39;head&#39;)  }  // 查找  find(element: any) {    let currentNode: LinkedListNode = this.head    while (currentNode.element !== element) {      currentNode = currentNode.next    }    return currentNode  }  // 插入  insert(element: any, item: any) {    let newNode = new LinkedListNode(element)    let currentNode = this.find(item)    newNode.next = currentNode.next    currentNode.next = newNode  }  // 移除  remove(element: any) {    let prevNode = this.findPrevNode(element)    if (!(prevNode.next === null)) {      prevNode.next = prevNode.next.next    }  }  //  findPrevNode(element: any) {    let currentNode = this.head    while (      !(currentNode.next === null) &amp;&amp;      currentNode.next.element !== element    ) {      currentNode = currentNode.next    }    return currentNode  }  // 显示  display() {    let currentNode = this.head    while (!(currentNode.next === null)) {      console.log(currentNode.next.element)      currentNode = currentNode.next    }  }}</code></pre><p>测试</p><pre><code class="ts">const foods = new LinkedList()foods.insert(&#39;eggs&#39;, &#39;head&#39;)foods.insert(&#39;apple&#39;, &#39;eggs&#39;)foods.insert(&#39;bread&#39;, &#39;apple&#39;)foods.insert(&#39;chese&#39;, &#39;bread&#39;)foods.insert(&#39;rice&#39;, &#39;chese&#39;)foods.display()console.log(&#39;------------&#39;)foods.remove(&#39;bread&#39;)foods.display()</code></pre><p>输出</p><pre><code class="json">eggsapplebreadcheserice------------eggsapplecheserice</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>要实现双向链表首先要为 LinkedListNode 类增加一个 prev 属性</p><pre><code class="ts">class LinkedListNode {  element: any  prev: LinkedListNode  next: LinkedListNode  constructor(element: any) {    this.element = element    this.prev = null    this.next = null  }}</code></pre><p>然后修改 LinkedList 类的 insert, remove 方法</p><pre><code class="ts">class LinkedList {  // 头节点  head: LinkedListNode = new LinkedListNode(&#39;head&#39;)  // 查找  find(element: any) {    let currentNode = this.head    while (currentNode.element !== element) {      currentNode = currentNode.next    }    return currentNode  }  // 找到最后的节点  findLast() {    let currentNode = this.head    while (currentNode.next !== null) {      currentNode = currentNode.next    }    return currentNode  }  // 插入  insert(element: any, item: any) {    let newNode = new LinkedListNode(element)    let currentNode = this.find(item)    newNode.prev = currentNode    newNode.next = currentNode.next    currentNode.next = newNode  }  // 移除  remove(element: any) {    let currentNode = this.find(element)    if (currentNode.next !== null) {      currentNode.prev.next = currentNode.next      currentNode.next.prev = currentNode.prev      currentNode.next = null      currentNode.prev = null    }  }  // 显示  display() {    let currentNode = this.head    while (!(currentNode.next === null)) {      console.log(currentNode.next.element)      currentNode = currentNode.next    }  }  // 倒叙显示  displayReverse() {    let currentNode = this.findLast()    while (currentNode.prev !== null) {      console.log(currentNode.element)      currentNode = currentNode.prev    }  }}</code></pre><p>测试一下</p><pre><code class="ts">foods.insert(&#39;eggs&#39;, &#39;head&#39;)foods.insert(&#39;apple&#39;, &#39;eggs&#39;)foods.insert(&#39;bread&#39;, &#39;apple&#39;)foods.insert(&#39;chese&#39;, &#39;bread&#39;)foods.insert(&#39;rice&#39;, &#39;chese&#39;)foods.display()console.log(&#39;------------&#39;)foods.remove(&#39;bread&#39;)foods.display()console.log(&#39;------------&#39;)foods.displayReverse()</code></pre><p>输出</p><pre><code class="json">eggsapplebreadcheserice------------eggsapplecheserice------------ricecheseappleeggs</code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>创建循环链表需要让它的头节点的 next 属性指向本身， 然后修改 display 方法</p><pre><code class="ts">this.head.next = this.head // 显示display() {  let currentNode = this.head  while (currentNode.next !== null &amp;&amp; currentNode.next.element !== &#39;head&#39;) {    console.log(currentNode.next.element)    currentNode = currentNode.next  }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表是一种高效的数据结构，如果发现数组在使用时很慢，就可以考虑用链表替代它，但是如果需要对数据随机访问，数组任然是更优的选择</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表是一组节点组成的集合，每个节点都使用一个对象的引用指向它的下一个节点，指向节点的引用叫做链&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Egg.js 中使用 Sequelize 的事务 Transaction</title>
    <link href="https://coldstone.fun/post/2019/08/22/egg-sequelize-transaction/"/>
    <id>https://coldstone.fun/post/2019/08/22/egg-sequelize-transaction/</id>
    <published>2019-08-22T06:07:14.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>在查了几遍 <a href="https://sequelize.org/" target="_blank" rel="noopener">Sequelize</a> 关于 <a href="https://sequelize.org/master/manual/transactions.html" target="_blank" rel="noopener">Transactions</a> 的文档，看了大佬同事的代码后，我终于弄懂怎么在 egg.js 框架里面使用事务了 😓</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在查了几遍 <a href="https://sequelize.org/" target="_blank" rel="noopener">Sequelize</a> 关于 <a href="https://sequelize.org/master/manual/transactions.html" target="_blank" rel="noopener">Transactions</a> 的文档，看了大佬同事的代码后，我终于弄懂怎么在 egg.js 框架里面使用事务了 😓</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>Sequelize 关于事务的示例代码是这样滴，首先通过 <code>sequelize.transaction</code> 方法创建了一个事务后，把这个事务传给需要进行操作的函数，如新增用户，给用户加属性等，但是看上去代码比较难懂</p><pre><code class="js">return sequelize.transaction().then(t =&gt; {  return User.create(    {      firstName: &#39;Bart&#39;,      lastName: &#39;Simpson&#39;    },    { transaction: t }  )    .then(user =&gt; {      return user.addSibling(        {          firstName: &#39;Lisa&#39;,          lastName: &#39;Simpson&#39;        },        { transaction: t }      )    })    .then(() =&gt; {      return t.commit()    })    .catch(err =&gt; {      return t.rollback()    })})</code></pre><p>实际使用的话需要用 <code>async/await</code> 语法让代码看起来更加清晰一点，在 egg.js 中使用的示例如下，首先需要用当前上下文中的 model 对象（就是对数据表的映射对象）创建一个事务，然后在 <code>try/catch</code> 中执行所要进行的操作，如果操作抛出了异常，那么就会回滚</p><pre><code class="js">const transaction = await this.ctx.model.transaction()try {  await this.ctx.model.create(this.ctx.request.body, { transaction })  await this.ctx.service.user.find(userId, { transaction });  await this.ctx.service.product.destory(productId, { transaction });  ...  await transaction.commit()} catch (err) {  await transaction.rollback()  throw err}</code></pre><p>用了 <code>async/await</code> 语法，代码确实清晰了很多</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在查了几遍 &lt;a href=&quot;https://sequelize.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sequelize&lt;/a&gt; 关于 &lt;a href=&quot;https://sequelize.org/master/manual/transactions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Transactions&lt;/a&gt; 的文档，看了大佬同事的代码后，我终于弄懂怎么在 egg.js 框架里面使用事务了 😓&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Egg" scheme="https://coldstone.fun/tags/Egg/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之队列</title>
    <link href="https://coldstone.fun/post/2019/08/18/das-queue/"/>
    <id>https://coldstone.fun/post/2019/08/18/das-queue/</id>
    <published>2019-08-18T14:18:36.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>队列是一种列表，只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的的数据，先进先出，可以将队列想象成在饭店排队取餐的人群，在队伍前面的先取餐，后来的人后取餐</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种列表，只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的的数据，先进先出，可以将队列想象成在饭店排队取餐的人群，在队伍前面的先取餐，后来的人后取餐。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用 TypeScript 实现队列</p><pre><code class="ts">class Queue {  data: Array&lt;any&gt; = []  // 入队  enqueue(element: any) {    this.data.push(element)  }  // 出队  dequeue() {    return this.data.shift()  }  // 返回第一个元素  front() {    return this.data[0]  }  // 返回最后一个元素  back() {    return this.data[this.data.length - 1]  }  // 显示队列中所有元素  toString() {    return this.data.map(ele =&gt; `${ele}`).toString()  }  // 判断队列是否为空  empty() {    if (this.data.length) {      return false    }    return true  }}</code></pre><p>测试一下</p><pre><code class="ts">const queue = new Queue()queue.enqueue(&#39;a&#39;)queue.enqueue(&#39;b&#39;)queue.enqueue(&#39;c&#39;)queue.enqueue(&#39;d&#39;)queue.enqueue(&#39;e&#39;)console.log(&#39;queue: &#39;, queue)console.log(&#39;front: &#39;, queue.front())console.log(&#39;back: &#39;, queue.back())queue.dequeue()queue.dequeue()queue.dequeue()queue.dequeue()console.log(&#39;queue: &#39;, queue)console.log(&#39;queue: &#39;, queue.empty())</code></pre><p>输出</p><pre><code class="json">queue:  Queue { data: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ] }front: aback:  equeue:  Queue { data: [ &#39;e&#39; ] }queue:  false</code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列指的是在删除队列中元素的时候需要考虑元素的优先级，优先级高的元素先出队，优先级低的后出队，同等优先级的元素按原本的顺序出队。</p><p>首先需要一个具有优先级的元素</p><pre><code class="ts">interface Element {  data: any  code: number // code 表示优先级，数值越小优先级越高，0 为最高}</code></pre><p>然后需要修改下队列的出队方法，找到队列中优先级最高的元素，然后将其移除队列</p><pre><code class="ts">dequeue() {  const codes = this.data.map(ele =&gt; ele.code)  const minCode = Math.min.apply(null, codes)  const index = this.data.findIndex(ele =&gt; ele.code === minCode)  return this.data.splice(index, 1)}</code></pre><p>测试一下</p><pre><code class="ts">const queue = new Queue()queue.enqueue({ data: &#39;a&#39;, code: 5 })queue.enqueue({ data: &#39;b&#39;, code: 4 })queue.enqueue({ data: &#39;c&#39;, code: 3 })queue.enqueue({ data: &#39;d&#39;, code: 2 })queue.enqueue({ data: &#39;e&#39;, code: 1 })console.log(&#39;queue: &#39;, queue)queue.dequeue()queue.dequeue()queue.dequeue()queue.dequeue()console.log(&#39;queue: &#39;, queue)</code></pre><p>输出</p><pre><code class="json">queue:  Queue {  data:   [     { data: &#39;a&#39;, code: 5 },     { data: &#39;b&#39;, code: 4 },     { data: &#39;c&#39;, code: 3 },     { data: &#39;d&#39;, code: 2 },     { data: &#39;e&#39;, code: 1 }  ]}queue:  Queue {  data:    [      { data: &#39;a&#39;, code: 5 },      { data: &#39;b&#39;, code: 4 }    ]}</code></pre><p>可以看到队列中剩下了优先级较低的元素</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;队列是一种列表，只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的的数据，先进先出，可以将队列想象成在饭店排队取餐的人群，在队伍前面的先取餐，后来的人后取餐&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>关于 Flutter 的安卓打包</title>
    <link href="https://coldstone.fun/post/2019/08/14/flutter-android-build/"/>
    <id>https://coldstone.fun/post/2019/08/14/flutter-android-build/</id>
    <published>2019-08-14T01:56:55.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 在打包安卓应用时有两种方式 <code>flutter build apk</code> 和 <code>flutter build appbundle</code>，本文说下这两种方式有什么区别</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 在打包安卓应用时有两种方式 <code>flutter build apk</code> 和 <code>flutter build appbundle</code>，本文说下这两种方式有什么区别。</p><h2 id="Appbundle"><a href="#Appbundle" class="headerlink" title="Appbundle"></a>Appbundle</h2><p>Android App Bundle 是上传到 Google Play 用以支持 Dynamic Delivery 的文件，扩展名为 .aab，一个 bundle 包含所有应用的已编译代码和资源，但是还没有生成 apk 和 Google Play 的签名。</p><p>Google Play 的新应用服务模式称为 Dynamic Delivery（动态传送），使用你的应用包为每个用户的设备配置生成并提供优化的 APK，因此用户只下载运行应用所需的代码和资源。开发者不再需要构建，签名和管理多个 APK 来支持不同的设备，用户可以获得更小，更优化的下载。</p><p><a href="https://developer.android.com/guide/app-bundle" target="_blank" rel="noopener">官方文档</a></p><h2 id="Apk"><a href="#Apk" class="headerlink" title="Apk"></a>Apk</h2><p>如果应用不发布到 Google Play，则需要发布多个 apk，但必须自己构建，签名和管理每个 apk。</p><p>通常构建一个 apk 用以支持所有目标设备，但由于需要支持多个屏幕密度或应用程序二进制接口（ABI）的文件，这可能会导致非常大的 apk，减少 apk 大小的一种方法是创建多个 apk，在执行 <code>flutter build apk</code> 的时候可以添加构建参数 <code>--target-platform android-arm,android-arm64 --split-per-abi</code>， 这样构建出来的 apk 包含特定屏幕密度或 ABI 的文件。</p><p><a href="https://developer.android.com/studio/build/configure-apk-splits" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 在打包安卓应用时有两种方式 &lt;code&gt;flutter build apk&lt;/code&gt; 和 &lt;code&gt;flutter build appbundle&lt;/code&gt;，本文说下这两种方式有什么区别&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之栈</title>
    <link href="https://coldstone.fun/post/2019/08/10/dsa-stack/"/>
    <id>https://coldstone.fun/post/2019/08/10/dsa-stack/</id>
    <published>2019-08-10T15:12:09.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>栈是一种高效的数据结构，因为它只能在栈顶添加或删除，这样的操作很快，它是被称之为后入先出（LIFO，last in first out）的数据结构。可以将栈想象成一叠装菜的盘子，用的时候先拿最上面的，洗好的盘子又会放到最上面</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种高效的数据结构，因为它只能在栈顶添加或删除，这样的操作很快，它是被称之为后入先出（LIFO，last in first out）的数据结构。可以将栈想象成一叠装菜的盘子，用的时候先拿最上面的，洗好的盘子又会放到最上面。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用 TypeScript 实现栈</p><pre><code class="ts">class Stack {  top: number = 0  data: Array&lt;any&gt; = []  get length() {    return this.top  }  // 向栈中压入一个新元素  push(element: any) {    this.data.push(element)    this.top += 1  }  // 返回栈顶元素, 同时将 top 值减 1  pop() {    this.top -= 1    return this.data.pop()  }  // 返回栈顶元素  peek() {    if (!this.data.length) {      return false    }    return this.data[this.top - 1]  }  // 清空栈  clear() {    this.top = 0  }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="ts">const stack = new Stack()stack.push(&#39;aaa&#39;)stack.push(&#39;bbb&#39;)stack.push(&#39;ccc&#39;)stack.push(&#39;ddd&#39;)console.log(&#39;执行 push 方法后\n&#39;, stack)stack.pop()console.log(&#39;执行 pop 方法后\n&#39;, stack)console.log(&#39;执行 peek 方法后返回：&#39;, stack.peek())stack.clear()console.log(&#39;执行 clear 方法后\n&#39;, stack)执行 push 方法后 Stack { data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39; ], top: 4 }执行 pop 方法后 Stack { data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39; ], top: 3 }执行 peek 方法后返回： ccc执行 clear 方法后 Stack { data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39; ], top: 0 }</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="将-10-进制的数转化为另一种进制"><a href="#将-10-进制的数转化为另一种进制" class="headerlink" title="将 10 进制的数转化为另一种进制"></a>将 10 进制的数转化为另一种进制</h3><p>此算法只针对基数为 2 ～ 9 的情况</p><pre><code class="ts">function mulBase(num: number, base: number) {  const stack = new Stack()  while (num &gt; 0) {    stack.push(num % base)    num = Math.floor((num /= base))  }  let converted = &#39;&#39;  while (stack.length &gt; 0) {    converted += stack.pop()  }  return converted}console.log(&#39;num = 2 base = 2：&#39;, mulBase(2, 2)) // 10console.log(&#39;num = 32 base = 2：&#39;, mulBase(32, 2)) // 100000console.log(&#39;num = 125 base = 8：&#39;, mulBase(125, 8)) // 175</code></pre><h3 id="判断回文"><a href="#判断回文" class="headerlink" title="判断回文"></a>判断回文</h3><pre><code class="ts">function isPalindrome(word: string) {  let rword = &#39;&#39;  const stack = new Stack()  word.split(&#39;&#39;).forEach(w =&gt; stack.push(w))  while (stack.length &gt; 0) {     rword += stack.pop()  }  if(word === rword) {    return true  }  return false}console.log(&#39;hello&#39;, isPalindrome(&#39;hello&#39;));console.log(&#39;bob&#39;, isPalindrome(&#39;bob&#39;));console.log(&#39;racecar&#39;, isPalindrome(&#39;racecar&#39;));hello falsebob trueracecar true</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈是一种高效的数据结构，因为它只能在栈顶添加或删除，这样的操作很快，它是被称之为后入先出（LIFO，last in first out）的数据结构。可以将栈想象成一叠装菜的盘子，用的时候先拿最上面的，洗好的盘子又会放到最上面&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之列表</title>
    <link href="https://coldstone.fun/post/2019/08/08/datastructure-list/"/>
    <id>https://coldstone.fun/post/2019/08/08/datastructure-list/</id>
    <published>2019-08-08T14:14:05.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>列表是一种常用的数据结构，如代办事项，十佳榜单等。当不需要在一个很长的序列中查找元素，或者对其排序时，列表显得尤其有用</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>列表是一种常用的数据结构，如代办事项，十佳榜单等。当不需要在一个很长的序列中查找元素，或者对其排序时，列表显得尤其有用</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 TypeScript 实现列表类，要实现的的列表类是</p><pre><code class="ts">class List {  pos: number // 列表当前位置  listSize: number // 列表的元素个数  data: [] // 列表的数据存储位置  constructor() {    this.pos = 0    this.listSize = 0    this.data = []  }  get length() {    return this.listSize  }  // 清空列表中的所有元素  clear() {}  // 返回列表的字符串形式  toString() {}  // 返回当前位置的元素  getElement() {}  // 在现有元素后插入新元素  insert() {}  // 在列表的末尾添加新元素  append() {}  // 从列表中删除元素  remove() {}  // 将列表的当前位置移动到第一个元素  front() {}  // 将列表的当前位置移动到最后一个元素  end() {}  // 将当前位置向前移一位  prev() {}  // 将当前位置向后移一位  next() {}  // 判断是否有后一个元素  hasNext() {}  // 判断是否有前一个元素  hasPrev() {}  // 返回列表的当前位置  currentPos() {}  // 将列表的当前位置移动到指定位置  moveTo() {}}</code></pre><p>将列表类实现后</p><pre><code class="ts">class List {  pos: number // 列表当前位置  data: Array&lt;any&gt; // 列表的数据存储  listSize: number // 列表的元素个数  constructor() {    this.pos = 0    this.listSize = 0    this.data = []  }  // 返回列表的长度  get length() {    return this.listSize  }  // 返回列表的当前位置  get currentPos() {    return this.pos  }  // 清空列表中的所有元素  clear() {    delete this.data    this.data.length = this.listSize = this.pos = 0  }  // 返回列表的字符串形式  toString() {    return this.data.toString()  }  // 返回当前位置的元素  getElement() {    return this.data[this.pos]  }  // 在现有元素后插入新元素  insert(element: any, after: any) {    const index = this.findIndex(after)    if (index &gt; -1) {      this.data.splice(index + 1, 0, element)      this.listSize += 1      return true    }    return false  }  // 在列表的末尾添加新元素  append(element: any) {    this.data.push(element)    this.listSize += 1  }  // 从列表中删除元素  remove(element: any) {    const index = this.findIndex(element)    if (index &gt; -1) {      this.data.splice(index, 1)      this.listSize -= 1      return true    }    return false  }  // 判断元素是否在列表中  contains(element: any) {    return this.data.includes(element)  }  // 将列表的当前位置移动到第一个元素  front() {    this.pos = 0  }  // 将列表的当前位置移动到最后一个元素  end() {    this.pos = this.listSize - 1  }  // 将当前位置向前移一位  prev() {    if (this.pos &gt; 0) {      this.pos -= 1    }  }  // 将当前位置向后移一位  next() {    if (this.pos &lt; this.listSize) {      this.pos += 1    }  }  // 判断是否有后一个元素  hasNext() {    return this.pos &lt; this.listSize  }  // 判断是否有前一个元素  hasPrev() {    return this.pos &gt; 0  }  // 将列表的当前位置移动到指定位置  moveTo(position: number) {    if (position &gt; 0 &amp;&amp; position &lt; this.listSize) {      this.pos = position    }  }  // 查找元素位置  private findIndex(element: any) {    return this.data.findIndex(ele =&gt; element === ele)  }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="ts">const list = new List()list.append(&#39;aaa&#39;)list.append(&#39;bbb&#39;)list.append(&#39;ccc&#39;)list.append(&#39;ddd&#39;)list.append(&#39;eee&#39;)console.log(&#39;list :&#39;, list)</code></pre><p>输出</p><pre><code class="ts">list : List {  pos: 0,  listSize: 5,  data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39;, &#39;eee&#39; ] }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表是一种常用的数据结构，如代办事项，十佳榜单等。当不需要在一个很长的序列中查找元素，或者对其排序时，列表显得尤其有用&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="https://coldstone.fun/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>在服务器上搭建 Npm 私服</title>
    <link href="https://coldstone.fun/post/2019/08/08/create-privite-npm-server/"/>
    <id>https://coldstone.fun/post/2019/08/08/create-privite-npm-server/</id>
    <published>2019-08-08T07:33:00.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>部门需要建一个 npm 私服，我查了一下发现有一个很好用的开源工具 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a>，有 3 中方式可以在自己的服务器上搭建，以 Centos 为例</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>部门需要建一个 npm 私服，我查了一下发现有一个很好用的开源工具 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a>，有 3 中方式可以在自己的服务器上搭建，以 Centos 为例</p><h2 id="使用-Node-js-环境"><a href="#使用-Node-js-环境" class="headerlink" title="使用 Node.js 环境"></a>使用 Node.js 环境</h2><p>首先需要在服务器上安装 node 环境</p><pre><code class="bash">curl -sL https://rpm.nodesource.com/setup_10.x | sudo bash -</code></pre><pre><code class="bash">sudo yum install nodejs</code></pre><p>安装后检查 node 是否正确安装</p><pre><code class="bash">node -v</code></pre><p>然后安装 Verdaccio</p><pre><code class="bash">npm install -g verdaccio</code></pre><p>安装完成就可以使用了， 如果使用的是 root 用户会提示你不要使用 root 账户</p><pre><code class="bash">verdaccio</code></pre><p>但是这样退出后服务就停止了，所以需要 pm2 进行启动</p><p>全局安装 pm2</p><pre><code class="bash">npm install -g pm2</code></pre><p>使用 pm2 启动 Verdaccio</p><pre><code class="bash">pm2 start verdaccio</code></pre><h2 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h2><p>首先需要在服务器上安装 Docker，有了 Docker 之后就很简单了</p><p>拉取镜像</p><pre><code class="bash">docker pull verdaccio/verdaccio</code></pre><p>运行容器</p><pre><code class="bash">docker run -d --rm --name verdaccio -p 4873:4873 verdaccio/verdaccio</code></pre><h2 id="使用-Cloudron"><a href="#使用-Cloudron" class="headerlink" title="使用 Cloudron"></a>使用 Cloudron</h2><p>这种方式没试过，因为上面两种已经很方便了</p><p>链接 <a href="https://cloudron.io/button/org.eggertsson.verdaccio.html" target="_blank" rel="noopener">https://cloudron.io/button/org.eggertsson.verdaccio.html</a></p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>私服安装完成后可以通过 ip 地址+端口号的形式访问了 xxx.xxx.xxx.xxx:4873</p><p>要用域名访问的话就需要将自己的域名解析到服务器上去</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://verdaccio.org/docs/en/installation" target="_blank" rel="noopener">https://verdaccio.org/docs/en/installation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;部门需要建一个 npm 私服，我查了一下发现有一个很好用的开源工具 &lt;a href=&quot;https://github.com/verdaccio/verdaccio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Verdaccio&lt;/a&gt;，有 3 中方式可以在自己的服务器上搭建，以 Centos 为例&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Node" scheme="https://coldstone.fun/tags/Node/"/>
    
      <category term="Docker" scheme="https://coldstone.fun/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Flutter World 上线啦</title>
    <link href="https://coldstone.fun/post/2019/08/03/flutter-world-release/"/>
    <id>https://coldstone.fun/post/2019/08/03/flutter-world-release/</id>
    <published>2019-08-03T15:21:48.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>一大波关于 Flutter 的学习资源集合</p><a id="more"></a><h2 id="Flutter-World-上线啦！"><a href="#Flutter-World-上线啦！" class="headerlink" title="Flutter World 上线啦！"></a>Flutter World 上线啦！</h2><p>一大波关于 Flutter 的学习资源集合，想要入坑的同学快去查看吧 👌</p><p><a href="https://flutterworld.site" target="_blank" rel="noopener">https://flutterworld.site</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一大波关于 Flutter 的学习资源集合&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>在 Centos 中安装 Java8</title>
    <link href="https://coldstone.fun/post/2019/08/01/centos-install-java8/"/>
    <id>https://coldstone.fun/post/2019/08/01/centos-install-java8/</id>
    <published>2019-08-01T10:56:29.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>由于要在服务器上安装 <a href="https://jenkins.io/zh/" target="_blank" rel="noopener">Jenkins</a> 所以首先要安装 java</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于要在服务器上安装 <a href="https://jenkins.io/zh/" target="_blank" rel="noopener">Jenkins</a> 所以首先要安装 java。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>安装之前最好更新下</p><pre><code class="bash">yum -y update</code></pre><h2 id="安装-Java8"><a href="#安装-Java8" class="headerlink" title="安装 Java8"></a>安装 Java8</h2><pre><code class="bash">yum install java-1.8.0-openjdk</code></pre><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><pre><code class="bash">java -version</code></pre><h2 id="设置环境变量-JAVA-HOME"><a href="#设置环境变量-JAVA-HOME" class="headerlink" title="设置环境变量 JAVA_HOME"></a>设置环境变量 JAVA_HOME</h2><p>首先找到安装 java 的位置</p><pre><code class="bash">update-alternatives --config java</code></pre><p>编辑 .bash_profile 文件</p><pre><code class="bash">vim .bash_profile</code></pre><p>添加这一行</p><pre><code class="bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/jre/bin/java</code></pre><p>重新执行刚修改的 .bash_profile</p><pre><code class="bash">source .bash_profile</code></pre><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><pre><code class="bash">echo $JAVA_HOME</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于要在服务器上安装 &lt;a href=&quot;https://jenkins.io/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jenkins&lt;/a&gt; 所以首先要安装 java&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Centos" scheme="https://coldstone.fun/tags/Centos/"/>
    
      <category term="Java" scheme="https://coldstone.fun/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>理解 Flutter 应用和部件的生命周期</title>
    <link href="https://coldstone.fun/post/2019/07/28/understand-flutter-lifecycle/"/>
    <id>https://coldstone.fun/post/2019/07/28/understand-flutter-lifecycle/</id>
    <published>2019-07-28T05:21:03.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>在 Flutter 里面部件以及应用本身都有自己的生命周期，本文分别说明它们的生命周期</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Flutter 里面部件以及应用本身都有自己的生命周期，本文分别说明它们的生命周期</p><h2 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h2><p>在 Flutter 里面有两种部件 StatefulWidget 和 StatelessWidget，它们的生命周期分别是</p><h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p>无状态部件的生命周期很简单，首先执行构造函数然后就执行 build 方法了</p><pre><code>Constructor Functionbuild()</code></pre><h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3><p>有状态部件的生命周期会复杂一些，因为是多了状态变化。首先是构造函数，然后会初始化 State 在执行 build 方法，如果执行了 setState 方法，就要检查部件是否更新，在执行 build，最后部件销毁的时候执行 dispose 方法</p><pre><code>Constructor FunctioninitState()build()setState()didUpdateWidget()build()dispose()</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Flutter 应用本身也有自己的生命周期，要观察到这些状态的变化需要让一个有状态部件混入 <code>WidgetsBindingObserver</code>，然后在 <code>initState</code> 方法中创建一个观察者，当然部件销毁的时候需要把创建的观察者实现清除</p><ul><li><p>inactive 应用处于非活动状态，并且未接收用户输入</p></li><li><p>paused 应用当前对用户不可见，不响应用户输入，并在后台运行</p></li><li><p>resumed 应用可见并响应用户输入</p></li><li><p>suspending 应用退出了</p></li></ul><p>代码</p><pre><code>class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Flutter Lifecycle&#39;,      home: MyHomePage(),    );  }}class MyHomePage extends StatefulWidget {  @override  _MyHomePageState createState() =&gt; _MyHomePageState();}class _MyHomePageState extends State&lt;MyHomePage&gt; with WidgetsBindingObserver {  @override  void initState() {    WidgetsBinding.instance.addObserver(this);    super.initState();  }  @override  void didChangeAppLifecycleState(AppLifecycleState state) {    print(state);  }  @override  void dispose() {    WidgetsBinding.instance.removeObserver(this);    super.dispose();  }  @override  Widget build(BuildContext context) {    return Scaffold();  }}</code></pre><p>可以看到在 Flutter 应用里面这些生命周期还是挺简单易懂的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Flutter 里面部件以及应用本身都有自己的生命周期，本文分别说明它们的生命周期&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="https://coldstone.fun/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>对于 Workbox Strategies几种策略的解释</title>
    <link href="https://coldstone.fun/post/2019/07/26/about-workbox-strategies/"/>
    <id>https://coldstone.fun/post/2019/07/26/about-workbox-strategies/</id>
    <published>2019-07-26T20:36:13.000Z</published>
    <updated>2019-10-26T07:19:44.997Z</updated>
    
    <content type="html"><![CDATA[<p>要将自己的网站支持 PWA，需要注册一个 serviceWorker 到浏览器中，通常使用 Google 的 <a href="https://developers.google.com/web/tools/workbox/" target="_blank" rel="noopener">Workbox</a> 工具，Workbox 可以在浏览器请求资源的时候提供了几种不同的策略对请求响应，本文对几种策略进行说明</p><a id="more"></a><p>要将自己的网站支持 PWA，需要注册一个 serviceWorker 到浏览器中，通常使用 Google 的 <a href="https://developers.google.com/web/tools/workbox/" target="_blank" rel="noopener">Workbox</a> 工具，Workbox 可以在浏览器请求资源的时候提供了几种不同的策略对请求响应，本文对几种策略进行说明。</p><h2 id="StaleWhileRevalidate"><a href="#StaleWhileRevalidate" class="headerlink" title="StaleWhileRevalidate"></a>StaleWhileRevalidate</h2><p>StaleWhileRevalidate 模式允许您使用缓存的响应尽快响应请求，如果未缓存，则返回到网络请求，然后，用网络请求更新缓存。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/stale-while-revalidate.png" alt="StaleWhileRevalidate"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.StaleWhileRevalidate({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="CacheFirst"><a href="#CacheFirst" class="headerlink" title="CacheFirst"></a>CacheFirst</h2><p>如果缓存中存在响应，则将使用缓存的响应来完成请求，并且根本不会使用网络。 如果没有缓存的响应，则将通过网络请求来满足请求，并且将缓存响应，以便直接从缓存提供下一个请求。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/cache-first.png" alt="CacheFirst"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.CacheFirst({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="NetworkFirst"><a href="#NetworkFirst" class="headerlink" title="NetworkFirst"></a>NetworkFirst</h2><p>对于频繁更新的请求，网络优先策略是理想的解决方案。 默认情况下，它将尝试从网络获取最新响应，如果请求成功，它会将响应放入缓存中。 如果网络无法返回响应，则将使用缓存的响应。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/network-first.png" alt="NetworkFirst"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.NetworkFirst({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="NetworkOnly"><a href="#NetworkOnly" class="headerlink" title="NetworkOnly"></a>NetworkOnly</h2><p>仅使用网络响应请求。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/network-only.png" alt="NetworkOnly"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.NetworkOnly({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="CacheOnly"><a href="#CacheOnly" class="headerlink" title="CacheOnly"></a>CacheOnly</h2><p>仅使用缓存响应请求。不常见，但如果您有自己的预先缓存步骤，则可能很有用。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/cache-only.png" alt="CacheOnly"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.CacheOnly({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要将自己的网站支持 PWA，需要注册一个 serviceWorker 到浏览器中，通常使用 Google 的 &lt;a href=&quot;https://developers.google.com/web/tools/workbox/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Workbox&lt;/a&gt; 工具，Workbox 可以在浏览器请求资源的时候提供了几种不同的策略对请求响应，本文对几种策略进行说明&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://coldstone.fun/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Workbox" scheme="https://coldstone.fun/tags/Workbox/"/>
    
  </entry>
  
</feed>
