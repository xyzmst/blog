<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 Codemagic 持续部署 Flutter 应用 (上)</title>
      <link href="/post/2020/02/03/flutter-cicd/"/>
      <url>/post/2020/02/03/flutter-cicd/</url>
      
        <content type="html"><![CDATA[<img src="https://blog.codemagic.io/uploads/2019/01/FB-build-test-publish-100.fdfb1baaca70728207ad87f5a7e36350d8c8e0693eff9616cc6758134c5542e0.jpg" alt="Codemagic" width="672"><a id="more"></a><h2 id="什么是-Codemagic"><a href="#什么是-Codemagic" class="headerlink" title="什么是 Codemagic"></a>什么是 <code>Codemagic</code></h2><p><a href="https://codemagic.io" target="_blank" rel="noopener">Codemagic</a> 是一个为 <code>Flutter</code> 项目以及其它移动端项目提供 CI/CD 服务的平台。</p><p>可以使用 Github 账号注册登录，登录后它会要求获得你仓库的读/写权限，然后在 <a href="https://codemagic.io/apps" target="_blank" rel="noopener">apps</a> 页面显示你需要进行构建的项目。</p><p><img src="./images/code-apps.jpg" alt="code-apps"></p><h2 id="为什么使用-Codemagic"><a href="#为什么使用-Codemagic" class="headerlink" title="为什么使用 Codemagic"></a>为什么使用 <code>Codemagic</code></h2><p>好的 <code>CI/CD</code> 有助于更快地构建，测试以及部署发布应用。在 <code>Flutter</code> 的官方文档 <a href="https://flutter.cn/docs/deployment/cd" target="_blank" rel="noopener">Flutter 里的持续部署</a> 里介绍了使用 <code>fastlane</code> 工具进行本地部署以及如何将 <code>fastlane</code> 整合到 <code>Travis</code>，<code>Cirrus</code>，<code>Bitrise</code> 等持续交付的服务中，但是对于 <code>Flutter</code> 项目来说最方便的 <code>CI/CD</code> 服务应该还是 <code>Codemagic</code>，它可以直接在网页上就配置出完整的应用交付流程。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>选择需要构建的 <code>Fluter</code> 项目，点击 <code>Start your first build</code> 按钮，创建一个工作流程 <code>Workflow</code>。<br>一个 <code>Workflow</code> 指的是每次构建要做的任务，如执行构建，测试以及发布任务。</p><p>对于 <code>Flutter</code> 项目可以在网页上配置或使用 <code>codemagic.yaml</code> 配置文件，其它项目只能使用 <code>codemagic.yaml</code> 配置。</p><p><img src="./images/workflow.jpg" alt="workflow"></p><p>一个 <code>Workflow</code> 由以下几个部分组成</p><ol><li><code>Build triggers</code> –&gt; 指定的构建分支和触发构建的时机</li></ol><p><img src="./images/build-triggers.jpg" alt="build-triggers"></p><ol start="2"><li><code>Environment variables</code> –&gt; 设置构建时的环境变量</li></ol><p><img src="https://docs.codemagic.io/uploads/env_vars.PNG" alt="env_vars"></p><ol start="3"><li><code>Dependency caching</code> –&gt; 设置构建时的依赖缓存文件目录，加快构建速度</li></ol><p><img src="https://docs.codemagic.io/uploads/2019/04/caching_enabled.PNG" alt="caching"></p><ol start="4"><li><code>Test</code> –&gt; 执行应用的单元，集成和部件测试，以及静态代码分析</li></ol><p><img src="./images/code-test.jpg" alt="code-test"></p><ol start="5"><li><code>Build</code> –&gt; 配置应用构建时的 Flutter 版本，构建目标，构建参数</li></ol><p><img src="./images/code-build.jpg" alt="code-build"></p><ol start="6"><li><code>Publish</code> –&gt; 选择需要发布应用的目标，这里我选择了 <code>Google play</code></li></ol><p><img src="./images/code-publish.jpg" alt="code-publish"></p><h2 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h2><p>要将应用发布到 <code>Apple store</code> 或者 <code>Goople play</code> 上就必须对你的应用进行代码签名，代码签名目的是为了识别谁开发了该应用程序，并确保该应用程序的所有更新均来自这个人。</p><p>对于 Android 来说有两种签名：发布签名和上传签名。最终用户下载的 <code>.aab/.apk</code> 文件使用发布签名。上传签名提供给开发者上传到 <code>Google Play</code> 商店的认证。上传后，<code>Google Play</code> 会重新使用发布签名对 <code>.aab/.apk</code> 文件签名。</p><p>在配置 <code>Workflow</code> 时，我选择发布到 <code>Goople play</code> 所以需要对 Android 应用进行代码签名，有以下两种方式进行签名，选择其一即可。</p><ol><li>使用 <code>Android Studio</code> <a href="https://developer.android.google.cn/studio/publish/app-signing#sign-apk" target="_blank" rel="noopener">为您的应用签名</a></li><li>使用命令行工具进行签名 <a href="https://flutter.cn/docs/deployment/android#signing-the-app" target="_blank" rel="noopener">为 app 签名</a></li></ol><p>签名后需要做的是把签名信息存到工作流程 <code>Workflow</code> 内，<a href="https://docs.codemagic.io/code-signing/android-code-signing/" target="_blank" rel="noopener">Android code signing</a>。</p><h2 id="创建-Service-Account"><a href="#创建-Service-Account" class="headerlink" title="创建 Service Account"></a>创建 <code>Service Account</code></h2><p><code>Service Account</code> 是给 <code>CI/CD</code> 平台发布构建后应用用的，根据指引创建 <a href="https://docs.codemagic.io/publishing/publishing-to-google-play/#setting-up-a-service-account-in-google-play-console" target="_blank" rel="noopener">Setting up a service account in Google Play Console</a>，创建后需做的上传你的凭证 JSON 文件</p><p><img src="./images/code-google-play.jpg" alt="code-google-play"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>在使用 <code>CI/CD</code> 服务前首先要人工的上传应用到 <code>Google Play</code> 一次。</li><li>每次上传到 <code>Google Play</code> 的应用构建版本不能重复，否则会遇到这样一个问题</li></ol><pre><code class="sh">Google Play responded with: APK specifies a version code that has already been used.</code></pre><p>搜索一番后发现问题是应用构建的版本号重复，需要更新 <code>pubspec.yaml</code> 文件的 <code>version</code> 字段的值，详细说明可以查阅这篇文章 <a href="https://flutter.cn/docs/deployment/android#updating-the-apps-version-number" target="_blank" rel="noopener">更新应用版本号</a></p><ol start="3"><li>上传 <code>Google Play</code> 需要添加一个环境变量 <code>FCI_KEYSTORE_FILE</code>，这个变量需要用 base64 encode 一下，需要用到的命令是<pre><code class="sh">base64 input-file-path -o output.txt</code></pre></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 <code>Codemagic</code> 发布 Flutter 应用的流程大致如下</p><ol><li>选择构建项目</li><li>配置构建流程</li><li>进行代码签名</li><li>创建 Service Account</li><li>触发构建</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://flutter.cn/docs/deployment/cd" target="_blank" rel="noopener">Flutter 里的持续部署</a></p><p><a href="https://docs.codemagic.io/" target="_blank" rel="noopener">Codemagic Documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Codemagic </tag>
            
            <tag> Google Play </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为 Flutter 应用添加搜索功能</title>
      <link href="/post/2020/01/26/flutter-show-search/"/>
      <url>/post/2020/01/26/flutter-show-search/</url>
      
        <content type="html"><![CDATA[<img src="images/flutter_show_search.png" height="320" style="height:340px;object-fit:cover"><p>自定义 <code>SearchDelegate</code> 给 Flutter 应用添加搜索功能</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>SearchDelegate</code> 是 Flutter 框架提供的一个实现搜索功能的类，使用它可以快速实现搜索功能，本文说明如何使用它来实现搜索功能。</p><p>最终效果如下</p><div><video src="videos/show_search.mov" controls width="240" autoplay muted loop></div><p>创建新项目，初始化代码如下</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;void main() {  runApp(MyApp());}class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Search App&#39;,      home: HomePage(),    );  }}class HomePage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Search App&#39;),      ),    );  }}</code></pre><h2 id="显示搜索页面"><a href="#显示搜索页面" class="headerlink" title="显示搜索页面"></a>显示搜索页面</h2><p><code>showSearch</code> 方法是 Flutter 里用来显示一个搜索页面的方法，这个页面由一个带有搜索框的 <code>AppBar</code> 和显示搜索建议或搜索结果的 <code>body</code> 组成。它有两个必要参数 <code>context</code> 和 <code>delegate</code>，<code>context</code> 即为当前的应用上下文，<code>delegate</code> 是一个实现了 <code>SearchDelegate</code> 抽象类自定义的部件，这个自定义部件定义了如何显示搜索页面，关闭搜索页面时返回用户选择的搜索结果。</p><p>在 <code>AppBar</code> 的 <code>actions</code> 数组里面添加一个 <code>IconButton</code>，按下时调用 <code>showSearch</code> 方法，进入搜索页面。</p><pre><code class="dart">class HomePage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Search App&#39;),        actions: &lt;Widget&gt;[          IconButton(            icon: Icon(Icons.search),            onPressed: () {              showSearch(context: context, delegate: CustomSearchDelegate());            },          )        ],      ),    );  }}</code></pre><p>初始化一个继承了 <code>SearchDelegate</code> 的 <code>CustomSearchDelegate</code>，类的名字是自定义的。</p><pre><code class="dart">class CustomSearchDelegate extends SearchDelegate {  @override  List&lt;Widget&gt; buildActions(BuildContext context) {    // TODO: implement buildActions    throw UnimplementedError();  }  @override  Widget buildLeading(BuildContext context) {    // TODO: implement buildLeading    throw UnimplementedError();  }  @override  Widget buildResults(BuildContext context) {    // TODO: implement buildResults    throw UnimplementedError();  }  @override  Widget buildSuggestions(BuildContext context) {    // TODO: implement buildSuggestions    throw UnimplementedError();  }}</code></pre><h2 id="实现-CustomSearchDelegate"><a href="#实现-CustomSearchDelegate" class="headerlink" title="实现 CustomSearchDelegate"></a>实现 <code>CustomSearchDelegate</code></h2><p>自定义的 <code>CustomSearchDelegate</code> 需要实现四个方法</p><ul><li><code>buildLeading</code> 显示在输入框之前的部件，一般显示返回前一个页面箭头按钮</li><li><code>buildActions</code> 显示在输入框之后的部件</li><li><code>buildResults</code> 显示搜索结果</li><li><code>buildSuggestions</code> 显示搜索建议</li></ul><p>先实现 <code>buildActions</code> 和 <code>buildLeading</code>，<code>buildActions</code> 显示一个清除按钮，可以把当前的 <code>query</code> 查询参数清空，并显示搜索建议。<code>buildLeading</code> 显示一个箭头的按钮，使用 <code>close</code> 方法关闭搜索页面，<code>close</code> 方法第二个参数是选定的搜索结果，如果使用系统后退按钮关闭搜索页面，则返回 <code>null</code> 值。</p><pre><code class="dart">List&lt;Widget&gt; buildActions(BuildContext context) {  return [    IconButton(      tooltip: &#39;Clear&#39;,      icon: const Icon(Icons.clear),      onPressed: () {        query = &#39;&#39;;        showSuggestions(context);      },    )  ];}@overrideWidget buildLeading(BuildContext context) {  return IconButton(    tooltip: &#39;Back&#39;,    icon: AnimatedIcon(      icon: AnimatedIcons.menu_arrow,      progress: transitionAnimation,    ),    onPressed: () {      close(context, null);    },  );}@overrideWidget buildResults(BuildContext context) {  return ListView();}@overrideWidget buildSuggestions(BuildContext context) {  return ListView();}</code></pre><img src="images/search_01.png" width="240" style="width:240px"><p>然后实现 <code>buildResults</code> 和 <code>buildSuggestions</code>，这两个方法用来展示搜索页面内容，可以使用不同的部显示，这里使用 <code>ListView</code> 部件。</p><pre><code class="dart">@overrideWidget buildResults(BuildContext context) {  return ListView.builder(    itemCount: Random().nextInt(10),    itemBuilder: (context, index) {      return ListTile(        title: Text(&#39;result $index&#39;),      );    },  );}@overrideWidget buildSuggestions(BuildContext context) {  return ListView(    children: &lt;Widget&gt;[      ListTile(title: Text(&#39;Suggest 01&#39;)),      ListTile(title: Text(&#39;Suggest 02&#39;)),      ListTile(title: Text(&#39;Suggest 03&#39;)),      ListTile(title: Text(&#39;Suggest 04&#39;)),      ListTile(title: Text(&#39;Suggest 05&#39;)),    ],  );}</code></pre><p>搜索结果</p><img src="images/search_result.png" width="240" style="width:240px"><p>搜索建议</p><img src="images/search_suggestion.png" width="240" style="width:240px"><h2 id="获取远程数据"><a href="#获取远程数据" class="headerlink" title="获取远程数据"></a>获取远程数据</h2><p>搜索功能一般需要请求后端的搜索接口来获取数据，此时可以使用 <code>FutureBuilder</code> 部件来请求数据然后渲染结果。首先需要定义一个请求接口的方法，返回一个 <code>Future</code>，然后在 <code>buildResults</code> 方法中使用 <code>FutureBuilder</code> 来展示结果。</p><p>先添加 <code>http</code> 包，用来发送 http 请求，然后引入需要的依赖包</p><pre><code class="yml">dependencies:  http: &lt;latest_version&gt;</code></pre><pre><code class="dart">import &#39;dart:convert&#39;;import &#39;package:http/http.dart&#39; as http;</code></pre><p>将键盘输入类型设置为数字，定义一个 <code>_fetchPosts</code> 方法用来获取远端数据，在 <code>buildResults</code> 方法里使用 <code>FutureBuilder</code> 渲染搜索结果。</p><pre><code class="dart">@overrideTextInputType get keyboardType =&gt; TextInputType.number;Future _fetchPosts() async {  http.Response response =      await http.get(&#39;https://jsonplaceholder.typicode.com/posts/$query&#39;);  final data = await json.decode(response.body);  return data;}@overrideWidget buildResults(BuildContext context) {  if (int.tryParse(query) &gt;= 100) {    return Center(child: Text(&#39;请输入小于 100 的数字&#39;));  }  return FutureBuilder(    future: _fetchPosts(),    builder: (context, AsyncSnapshot snapshot) {      if (snapshot.hasData) {        final post = snapshot.data;        return ListTile(          title: Text(post[&#39;title&#39;], maxLines: 1),          subtitle: Text(post[&#39;body&#39;], maxLines: 3),        );      }      return Center(child: CircularProgressIndicator());    },  );}</code></pre><img src="images/search_server.png" width="240" style="width:240px"><p>使用 <code>FutureBuilder</code> 部件获取了远程的数据，但是遇到一个问题，搜索结果可能是分页显示的，一开始只获取了第一页的数据，想追加下一页数据时需要像 <code>stateFullWidget</code> 那样使用 <code>setState</code> 方法更新页面，但是在 <code>SearchDelegate</code> 里无法使用…暂时没想到解决方法。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="dart">import &#39;dart:convert&#39;;import &#39;package:flutter/material.dart&#39;;import &#39;package:http/http.dart&#39; as http;void main() {  runApp(MyApp());}class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Search App&#39;,      home: HomePage(),    );  }}class HomePage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Search App&#39;),        actions: &lt;Widget&gt;[          IconButton(            icon: Icon(Icons.search),            onPressed: () {              showSearch(context: context, delegate: CustomSearchDelegate());            },          )        ],      ),    );  }}class CustomSearchDelegate extends SearchDelegate {  @override  List&lt;Widget&gt; buildActions(BuildContext context) {    return [      IconButton(        tooltip: &#39;Clear&#39;,        icon: const Icon(Icons.clear),        onPressed: () {          query = &#39;&#39;;          showSuggestions(context);        },      )    ];  }  @override  Widget buildLeading(BuildContext context) {    return IconButton(      tooltip: &#39;Back&#39;,      icon: AnimatedIcon(        icon: AnimatedIcons.menu_arrow,        progress: transitionAnimation,      ),      onPressed: () {        this.close(context, null);      },    );  }  @override  TextInputType get keyboardType =&gt; TextInputType.number;  Future _fetchPosts() async {    http.Response response =        await http.get(&#39;https://jsonplaceholder.typicode.com/posts/$query&#39;);    final data = await json.decode(response.body);    return data;  }  @override  Widget buildResults(BuildContext context) {    if (int.parse(query) &gt;= 100) {      return Center(child: Text(&#39;请输入小于 100 的数字&#39;));    }    return FutureBuilder(      future: _fetchPosts(),      builder: (context, AsyncSnapshot snapshot) {        if (snapshot.hasData) {          final post = snapshot.data;          return ListTile(            title: Text(post[&#39;title&#39;], maxLines: 1),            subtitle: Text(post[&#39;body&#39;], maxLines: 3),          );        }        return Center(child: CircularProgressIndicator());      },    );  }  @override  Widget buildSuggestions(BuildContext context) {    return ListView(      children: &lt;Widget&gt;[        ListTile(title: Text(&#39;Suggest 01&#39;)),        ListTile(title: Text(&#39;Suggest 02&#39;)),        ListTile(title: Text(&#39;Suggest 03&#39;)),        ListTile(title: Text(&#39;Suggest 04&#39;)),        ListTile(title: Text(&#39;Suggest 05&#39;)),      ],    );  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 创建自定义路由过渡动画</title>
      <link href="/post/2019/12/10/flutter-route-transition/"/>
      <url>/post/2019/12/10/flutter-route-transition/</url>
      
        <content type="html"><![CDATA[<p><img src="./images/transition.jpg" alt="flutter-routes"></p><p>Flutter 应用进行路由跳转的时候有默认的过渡动画，但是自定义的跳转动画会让应用更具特色</p><a id="more"></a><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ol><li>使用 <code>PageRouteBuilder</code> 创建自定义路由</li><li>在 <code>transitionsBuilder</code> 方法里创建过渡动画</li><li>过渡动画示例</li><li>定义全局路由过渡动画</li><li>封装自定义路由</li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>Flutter</code> 中使用 <code>Navigator.of(context).push(Route route);</code> 方法进行路由跳转时就需要传一个 <code>Route</code> 对象，通常使用 <code>MaterialPageRoute(builder: () {});</code> 创建，使用时会在路由跳转过程中添加默认的过渡动画。当需要自定义路由过渡动画时，就要使用 <code>PageRouteBuilder</code>，它是 <code>Flutter</code> 提供的用来创建自定义的路由的一个类，实例化这个类会得到一个路由对象 <code>Route</code>，要做的就是创建一个自定义的 <code>Route</code>。</p><h2 id="PageRouteBuilder"><a href="#PageRouteBuilder" class="headerlink" title="PageRouteBuilder"></a>PageRouteBuilder</h2><p>使用 <code>PageRouteBuilder</code> 创建自定义路由过渡动画时需要传入两个回调函数作为参数，一个必要参数 <code>pageBuilder</code>，这个函数用来创建跳转的页面，另一个函数 <code>transitionsBuilder</code>，这个函数就是实现过渡动画的地方。</p><blockquote><p><code>transitionsBuilder</code> 的 <code>child</code> 参数是 <code>pageBuilder</code> 函数返回的一个 <code>transitionsBuilder widget</code> 部件， <code>pageBuilder</code> 方法仅会在第一次构建路由的时候被调用，<code>Flutter</code> 能够自动避免做额外的工作，整个过渡期间 <code>child</code> 保存了同一个实例。</p></blockquote><pre><code class="dart">PageRouteBuilder(  pageBuilder: (      BuildContext context,      Animation&lt;double&gt; animation,      Animation&lt;double&gt; secondaryAnimation,    ) {      return widget;    },    transitionsBuilder: (      BuildContext context,      Animation&lt;double&gt; animation,      Animation&lt;double&gt; secondaryAnimation,      Widget child,    ) {      return child;    },);</code></pre><p>创建自定义路由需要继承 <code>PageRouteBuilder</code>，然后实现自定义路由的构造函数。</p><pre><code class="dart">// 定义class YourRoute extends PageRouteBuilder {  final Widget page;  YourRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return child;          },        );}// 使用Navigator.of(context).push(YourRoute(NewPage()));</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用 <code>FirstPage</code> 和 <code>SecondPage</code> 两个页面展示效果</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      debugShowCheckedModeBanner: false,      home: FirstPage(),    );  }}class FirstPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;First Page&#39;),        elevation: 0.0,        backgroundColor: Colors.purple,      ),      body: Column(        mainAxisAlignment: MainAxisAlignment.center,        children: &lt;Widget&gt;[          Center(            child: RaisedButton(              onPressed: () {                Navigator.of(context).push(                  MaterialPageRoute(builder: (context) =&gt; SecondPage()),                );              },              child: Text(&#39;Next Page&#39;),            ),          )        ],      ),      backgroundColor: Colors.purple,    );  }}class SecondPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        title: Text(&#39;Second Page&#39;),        elevation: 0.0,        backgroundColor: Colors.deepPurpleAccent,      ),      body: Column(        mainAxisAlignment: MainAxisAlignment.center,        children: &lt;Widget&gt;[          Center(            child: RaisedButton(              onPressed: () {                Navigator.pop(context);              },              child: Text(&#39;Go Back&#39;),            ),          )        ],      ),      backgroundColor: Colors.deepPurpleAccent,    );  }}</code></pre><h3 id="FadeTransition"><a href="#FadeTransition" class="headerlink" title="FadeTransition"></a><code>FadeTransition</code></h3><pre><code class="dart">class FadeRoute extends PageRouteBuilder {  final Widget page;  FadeRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return FadeTransition(              opacity: animation,              child: child,            );          },        );}</code></pre><div><video src="videos/fade_transition.mov" controls width="320" autoplay muted loop></div><h3 id="ScaleTransition"><a href="#ScaleTransition" class="headerlink" title="ScaleTransition"></a><code>ScaleTransition</code></h3><pre><code class="dart">class ScaleRoute extends PageRouteBuilder {  final Widget page;  ScaleRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return ScaleTransition(              alignment: Alignment.bottomLeft,              scale: Tween(                begin: 0.0,                end: 1.0,              ).animate(                CurvedAnimation(                  parent: animation,                  curve: Curves.easeInOut,                ),              ),              child: child,            );          },          transitionDuration: Duration(seconds: 1),        );}Navigator.of(context).push(ScaleRoute(SecondPage()));</code></pre><div><video src="videos/scale_transition.mov" controls width="320" autoplay muted loop></div><h3 id="RotationTransition"><a href="#RotationTransition" class="headerlink" title="RotationTransition"></a><code>RotationTransition</code></h3><pre><code class="dart">class RotationRoute extends PageRouteBuilder {  final Widget page;  RotationRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            Animation myAnimation = CurvedAnimation(              parent: animation,              curve: Curves.easeInBack,            );            return RotationTransition(              turns: myAnimation,              child: child,            );          },          transitionDuration: Duration(seconds: 1),        );}Navigator.of(context).push(RotationRoute(SecondPage()));</code></pre><div><video src="videos/rotation_transition.mov" controls width="320" autoplay muted loop></div><h3 id="ScaleRotationRoute"><a href="#ScaleRotationRoute" class="headerlink" title="ScaleRotationRoute"></a><code>ScaleRotationRoute</code></h3><p>结合两个过渡动画</p><pre><code class="dart">class ScaleRotationRoute extends PageRouteBuilder {  final Widget page;  ScaleRotationRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return ScaleTransition(              scale: animation,              child: RotationTransition(                turns: Tween(                  begin: 0.0,                  end: 1.0,                ).animate(                  CurvedAnimation(parent: animation, curve: Curves.linear),                ),                child: child,              ),            );          },          transitionDuration: Duration(milliseconds: 800),        );}Navigator.of(context).push(ScaleRotationRoute(SecondPage()));</code></pre><div><video src="videos/scale_rotation_transition.mov" controls width="320" autoplay muted loop></div><h3 id="TransformRoute"><a href="#TransformRoute" class="headerlink" title="TransformRoute"></a><code>TransformRoute</code></h3><p>使用 <code>Transform</code> 部件创造 <code>3D</code> 效果</p><pre><code class="dart">import &#39;dart:math&#39; show pi;class TransformRoute extends PageRouteBuilder {  final Widget page;  TransformRoute(this.page)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            return Transform(              transform: Matrix4.identity()                // 类似于 CSS 里面 `perspective` 属性，确定 z=0 平面与用户之间的距离                ..setEntry(3, 2, 0.0001)                ..rotateX(animation.value * pi * 2)                ..rotateY(animation.value * pi * 2),              alignment: FractionalOffset.center,              child: child,            );          },          transitionDuration: Duration(seconds: 2),        );}Navigator.of(context).push(TransformRoute(SecondPage()));</code></pre><div><video src="videos/transform_transition.mov" controls width="320" autoplay muted loop></div><h3 id="EnterExitRoute"><a href="#EnterExitRoute" class="headerlink" title="EnterExitRoute"></a><code>EnterExitRoute</code></h3><p>同时为进入页面和退出页面添加动画</p><pre><code class="dart">class EnterExitRoute extends PageRouteBuilder {  final Widget enterPage;  final Widget exitPage;  EnterExitRoute(this.enterPage, this.exitPage)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return exitPage;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) =&gt;              Stack(            children: [              SlideTransition(                position: Tween&lt;Offset&gt;(                  begin: Offset(0.0, 0.0),                  end: Offset(-1.0, 0.0),                ).animate(                  CurvedAnimation(parent: animation, curve: Curves.easeIn),                ),                child: enterPage,              ),              SlideTransition(                position: Tween&lt;Offset&gt;(                  begin: Offset(1.0, 0.0),                  end: Offset.zero,                ).animate(                  CurvedAnimation(parent: animation, curve: Curves.easeInOut),                ),                child: exitPage,              )            ],          ),        );}Navigator.of(context).push(  EnterExitRoute(FirstPage(), SecondPage()),);</code></pre><div><video src="videos/enter_exist_transition.mov" controls width="320" autoplay muted loop></div><h2 id="使用-Navigator-pushNamed-方法跳转"><a href="#使用-Navigator-pushNamed-方法跳转" class="headerlink" title="使用 Navigator.pushNamed 方法跳转"></a>使用 <code>Navigator.pushNamed</code> 方法跳转</h2><p>在 <code>onGenerateRoute</code> 对跳转路由的 <code>name</code> 进行判断，对特定的路由添加过渡动画。</p><pre><code class="dart">class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      debugShowCheckedModeBanner: false,      home: FirstPage(),      onGenerateRoute: (settings) {        switch (settings.name) {          case &#39;/second&#39;:            return ScaleRoute(SecondPage());            break;          default:            return null;        }      },    );  }}Navigator.pushNamed(context, &#39;/second&#39;, arguments: {});</code></pre><h2 id="设置全局的路由过渡动画"><a href="#设置全局的路由过渡动画" class="headerlink" title="设置全局的路由过渡动画"></a>设置全局的路由过渡动画</h2><p><code>Flutter</code> 的默认路由过渡动画是由 <code>buildTransitions</code> 方法创建的，它使用的是 <code>Theme.of(context).pageTransitionsTheme</code>方法，因此可以定义全局的路由跳转过渡动画。</p><pre><code class="dart">@overrideWidget buildTransitions(context, animation, secondaryAnimation, child) {    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;    return theme.buildTransitions&lt;T&gt;(this, context, animation, secondaryAnimation, child);}</code></pre><p>首先自定义一个 <code>TransitionBuilder</code>， <code>buildTransitions</code> 方法返回跳转页面。然后配置 <code>theme</code> 的 <code>pageTransitionsTheme</code>，设置对应的平台，最后在使用 <code>MaterialPageRoute</code> 或者 <code>CupertinoPageRoute</code> 进行页面跳转时就会有自定义的过渡动画了。</p><pre><code class="dart">class ScaleTransitionBuilder extends PageTransitionsBuilder {  @override  Widget buildTransitions&lt;T&gt;(    route,    context,    animation,    secondaryAnimation,    child,  ) {    return ScaleTransition(      scale: CurvedAnimation(parent: animation, curve: Curves.easeIn),      child: child,    );  }}class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      debugShowCheckedModeBanner: false,      home: FirstPage(),      theme: ThemeData(        pageTransitionsTheme: PageTransitionsTheme(          builders: {            TargetPlatform.android: ScaleTransitionBuilder(),            TargetPlatform.iOS: ScaleTransitionBuilder(),          },        ),      ),    );  }}Navigator.push(context, MaterialPageRoute(builder: (ctx) =&gt; SecondPage()));</code></pre><h2 id="将动画封装成一个库"><a href="#将动画封装成一个库" class="headerlink" title="将动画封装成一个库"></a>将动画封装成一个库</h2><p>将自定义的路由过渡动画封装起来方便使用。</p><pre><code class="dart">enum TransitionType {  fade,  scale,  rotate,  transform,}class PageTransition extends PageRouteBuilder {  PageTransition(TransitionType type, Widget page, Duration time)      : super(          pageBuilder: (            context,            animation,            secondaryAnimation,          ) {            return page;          },          transitionsBuilder: (            context,            animation,            secondaryAnimation,            child,          ) {            switch (type) {              case TransitionType.fade:                return FadeTransition(opacity: animation, child: child);                break;              case TransitionType.scale:                return ScaleTransition(                  scale: Tween(begin: 0.0, end: 1.0).animate(                    CurvedAnimation(parent: animation, curve: Curves.easeInOut),                  ),                  child: child,                );                break;              case TransitionType.rotate:                return RotationTransition(                  turns: CurvedAnimation(                    parent: animation,                    curve: Curves.easeInBack,                  ),                  child: child,                );                break;              case TransitionType.transform:                return Transform(                  transform: Matrix4.identity()                    ..setEntry(3, 2, 0.0001)                    ..rotateX(animation.value * pi * 2)                    ..rotateY(animation.value * pi * 2),                  alignment: FractionalOffset.center,                  child: child,                );                break;              default:                return child;            };          },          transitionDuration: time,        );}// 使用Navigator.push(  context,  PageTransition(    TransitionType.rotate,    SecondPage(),    Duration(milliseconds: 800),  ),}</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://flutter.cn/docs/cookbook/animation/page-route-animation" target="_blank" rel="noopener">为页面切换加入动画效果</a></p><p><a href="https://medium.com/flutter-community/everything-you-need-to-know-about-flutter-page-route-transition-9ef5c1b32823" target="_blank" rel="noopener">Everything you need to know about Flutter page route transition</a></p><p><a href="https://medium.com/flutter/perspective-on-flutter-6f832f4d912e" target="_blank" rel="noopener">Perspective on Flutter</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Egg.js 上传接口开发总结</title>
      <link href="/post/2019/12/05/egg-api-dev/"/>
      <url>/post/2019/12/05/egg-api-dev/</url>
      
        <content type="html"><![CDATA[<p><img src="./images/egg.jpg" alt="egg"></p><p>总结一下之前用 Egg.js 开发的文件上传接口的任务</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>要在浏览器端将文件上传到阿里的 OSS 对象存储，需要用到阿里云提供的 <a href="https://github.com/ali-sdk/ali-oss" target="_blank" rel="noopener">SDK</a>，但是这样会在前端暴露 OSS 的 <code>accessKeyId</code> 和 <code>accessKeySecret</code>，这是不安全的。所以需要一个文件上传接口把前端传过来的文件上传到对象存储里面，最初只支持阿里云，之后可能会支持其它的云服务商比如七牛云。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>后端框架用的是 Egg.js，因为比较熟悉。然后这只是一个文件上传的服务，一个路由就行。</p><pre><code class="js">router.post(`/${app.name}/v1/upload`, controller.oss.upload)</code></pre><p>然后实现对应的 <code>OssController</code> 的 <code>upload</code> 方法，一般的实践是在 <code>Controller</code> 层进行参数校验，这里用内置的是 <code>egg-validate</code> 插件进行校验。假如有两个参数 <code>folder</code> 和 <code>bucket</code> 代表文件上传的目录和 <code>bucket</code>，那么验证代码如下</p><pre><code class="js">const body = ctx.request.bodyconst rules = {  folder: { type: &#39;string&#39;, required: false, default: &#39;/&#39;, trim: true },  bucket: { type: &#39;string&#39;, required: false, default:  &#39;you-bucket-name&#39; },}await ctx.validate(rules, body)</code></pre><p>接受前端的上传文件用的是 <a href="https://github.com/eggjs/egg-multipart" target="_blank" rel="noopener">egg-multipart</a> 插件，这个插件有两种模式 <code>file</code> 和 <code>stream</code>，<code>file</code> 模式适合简单的文件上传，这种模式会先将前端传来的图片存到服务器上，执行完操作后需要用 <code>ctx.cleanupRequestFiles()</code> 方法将文件删除。 <code>stream</code> 模式适合在对上传文件进一步处理的时候使用，如压缩，解压等，如果上传文件是图片那么可以将这个流传递给处理图片的库进行处理。</p><p>在 <code>config.default.js</code> 配置 <code>egg-multipart</code> 插件，在 <code>fileExtensions</code> 新增需要添加的文件类型扩展名，<code>cleanSchedule</code> 配置定时清除零时保存的文件。</p><pre><code class="ts">config.multipart = {  mode: &#39;file&#39;,  fileSize: &#39;50mb&#39;,  tmpdir: path.join(os.tmpdir(), &#39;egg-multipart-tmp&#39;, appInfo.name),  cleanSchedule: {    cron: &#39;0 30 4 * * *&#39;,  },  fileExtensions: [ &#39;.pdf&#39;, &#39;.doc&#39;, &#39;.docx&#39; ],}</code></pre><p>然后用 <code>ctx.request.files</code> 获取请求过来的文件，这里也需要进行验证请求是否有文件，校验好请求参数后就把请求参数传到 <code>Services</code> 层里</p><pre><code class="js">const files = ctx.request.filesconst body = ctx.request.body...ctx.body = await ctx.service.oss.upload(body, files)</code></pre><p>对应的 <code>OssService</code> 是负责主要的任务地方，新建 <code>OSS</code> 实例对象，上传文件，设置上传文件的请求头，返回上传结果。</p><pre><code class="ts">import * as fs from &#39;fs&#39;import * as OSS from &#39;ali-oss&#39;const ONE_YEAR = 3600 * 24 * 365/** * OssService */export default class OssService extends Service {  private client  private createClient(option) {      this.client = new OSS({})    }  }  private async uploadFile(dir, file) {    let result    const filename = file.filename.replace(/\.(\w+)$/, `-${Date.now()}.$1`)    try {      result = await this.client.put(`${dir}${filename}`, file.filepath, {        headers: { &#39;Cache-Control&#39;: `max-age=${ONE_YEAR}`, &#39;Content-Disposition&#39;: &#39;&#39; },      })    } catch (e) {      this.ctx.logger.error(new Error(e.message))      throw new Error(e.message)    } finally {      fs.unlink(file.filepath, () =&gt; true)    }    return result  }  public async upload(parmas, files) {    this.createClient(parmas)    let result    if (files.length &gt; 1) {      result = []      for (const file of files) {        const res = await this.uploadFile(parmas.dir, file)        result.push({ url: res.url })      }    } else {      const file = files[0]      const res = await this.uploadFile(parmas.dir, file)      result = { url: res.url }    }    return result  }}</code></pre><p>至此上传文件到 OSS 接口基本完成了</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Egg.js 集成了 <a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">SuperTest</a> 测试框架，所以写接口的单元测试很方便。这个接口主要是对 <code>Controller</code> 层请求参数进行测试。测试代码写在项目目录 <code>test/app/controller/oss.test.ts</code> 文件内。</p><pre><code class="ts">import { app, assert } from &#39;egg-mock/bootstrap&#39;describe(&#39;测试 oss controller&#39;, () =&gt; {  it(&#39;不再白名单的 bucket 名返回错误&#39;, async () =&gt; {    const result = await app.httpRequest()      .post(&#39;/upload-server/v1/upload&#39;)      .set(&#39;Content-type&#39;, &#39;multipart/form-data; boundary=--------------------------820317025826519383208825&#39;)      .field(&#39;bucket&#39;, &#39;wrong-bucket&#39;)      .expect(403)    assert(result.body)  })  it(&#39;上传文件成功&#39;, async () =&gt; {    const result = await app.httpRequest()      .post(&#39;/upload-server/v1/upload&#39;)      .set(&#39;Content-type&#39;, &#39;multipart/form-data; boundary=--------------------------820317025826519383208825&#39;)      .field(&#39;dir&#39;, &#39;images&#39;)      .attach(&#39;avatar&#39;, &#39;test/app/controller/avatar.png&#39;)      .expect(200)    assert(result.body)  })})</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>Egg.js 本身部署十分的方便，只需要在服务器上运行以下命令即可</p><pre><code class="bash">egg-scripts start --daemon --env=prod --title=upload-server</code></pre><p>但是将这个服务变成一个 <code>Docker</code> <code>iamge</code> 就更方便了</p><blockquote><p>注意:<br>要用 <code>Docker</code> 运行 Egg 服务需要将 <code>package.json</code> 中 <code>scripts</code> 的 <code>start</code> 命令去掉 <code>--daemon</code> 参数，变成<br><code>egg-scripts start --env=prod --title=upload-server</code><br>因为在 <code>Docker</code> 运行 Egg 应用需要是前台模式运行</p></blockquote><pre><code class="dockerfile">FROM node:lts-alpine# 设置时区RUN apk --update add tzdata \    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone \    &amp;&amp; apk del tzdataWORKDIR /upload-serverCOPY package*.json ./RUN npm install --registry=https://registry.npm.taobao.orgCOPY . /upload-serverRUN npm run tsc &amp;&amp; npm prune --productionEXPOSE 7001CMD npm start</code></pre><p>有了镜像后，写一个运行容器的脚本，添加可执行的权限，之后启动服务就可以只用运行这个脚本即可。</p><pre><code class="sh">#!/bin/bashset -eIMAGE_NAME=&quot;upload-server&quot;CONTAINER_NAME=&quot;upload-server&quot;echo &#39;拉取代码&#39;git pull origin masterecho &#39;运行容器&#39;docker rm -f ${CONTAINER_NAME} || truedocker build -t ${IMAGE_NAME} .docker run -d -p 7001:7001 --env-file .env --name=${CONTAINER_NAME} ${IMAGE_NAME}exitEOF</code></pre><pre><code class="bash">chmod +x ./deploy.sh</code></pre><p>运行脚本</p><pre><code class="bash">./deploy.sh</code></pre><h2 id="请求频率限制"><a href="#请求频率限制" class="headerlink" title="请求频率限制"></a>请求频率限制</h2><p>为了防止接口被滥用需要限制请求接口的频率，在 Github 找到一个 <a href="https://github.com/koajs/ratelimit" target="_blank" rel="noopener">koa-ratelimit</a> 的仓库，由于 Egg.js 支持 Koa 的插件，所以也适合。</p><p>参考这个仓库的文档，在项目 <code>middleware</code> 文件添加一个 <code>ratelimit.ts</code>，用这个中间件来控制，一开始使用的 <code>redis</code> 作为 <code>driver</code> 可是遇到一个 <code>docker-compose</code> 网络链接问题始终无法解决，遂放弃，改用内存模式。</p><pre><code class="ts">import * as Redis from &#39;ioredis&#39;import * as ratelimit from &#39;koa-ratelimit&#39;const db = new Map();export default () =&gt; {  return ratelimit({    db: db,    driver: &#39;memory&#39;,    duration: 60000,    errorMessage: &#39;请求次数超过限制&#39;,    id: ctx =&gt; ctx.ip,    headers: {      remaining: &#39;Upload-Limit-Remaining&#39;,      reset: &#39;Uplaod-Limit-Reset&#39;,      total: &#39;Upload-Limit-Total&#39;,    },    max: 300,    disableHeader: false,  })}</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><strong><em>上传到 OSS 的图片在浏览器无法预览变为下载</em></strong></p><p>首先阿里云规定</p><blockquote><p>对于图片文件（在未修改文件http头的情况下）：<br>若您的Bucket是2019年9月23日前创建的，使用OSS默认访问域名或自有域名生成的文件URL从浏览器访问时可以预览文件内容。<br>若您的Bucket是2019年9月23日后创建的，使用OSS默认域名生成的文件URL从浏览器访问时会以附件形式下载；使用自有域名生成的文件URL访问时，可以预览&gt; 文件内容。绑定自有域名步骤请参见绑定自定义域名。</p></blockquote><p>然后是上传的图片不能添加 <code>Content-Disposition</code> 返回头信息，给文件添加了这个 http 返回头，也会让图片变成下载。</p><hr><p><strong><em><code>egg-multipart</code> 插件使用 <code>stream</code> 模式无法获取请求体传过来的参数</em></strong></p><p>用 <code>file</code> 模式能够正确的拿到 <code>ctx.request.body</code> 里的请求参数，但是将使用 <code>stream</code> 模式就无法获取，搜索了一下后发现使用 <code>stream</code> 模式需要将上传文件放到表单的最后一项去，不然拿不到其它参数。</p><blockquote><p><a href="https://eggjs.org/zh-cn/basics/controller.html#%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">https://eggjs.org/zh-cn/basics/controller.html#%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6</a><br>只支持上传一个文件。<br>上传文件必须在所有其他的 fields 后面，否则在拿到文件流时可能还获取不到 fields。</p></blockquote><hr><p><strong><em>Redis 无法链接问题</em></strong></p><p>用以下的 <code>docker-compose.yml</code> 文件启动 Egg.js 应用和一个 <code>Redis</code> 服务，然后想在上传接口的请求频率限制的中间件中使用这个 <code>Redis</code> 服务，然后一直报链接失败…Google 之后试了几种方法依然没有成功 :sad:</p><pre><code class="yml">version: &quot;3&quot;services:  redis:    image: redis:alpine    container_name: redis    restart: always    hostname: redis    ports:      - &quot;6379:6379&quot;    networks:       - upload-server-network  upload_server:    build:      context: .      dockerfile: Dockerfile    container_name: upload_server    restart: always    environment:      - EGG_SERVER_ENV:prod    ports:      - 7001:7001    depends_on:      - redis    networks:      - upload-server-networknetworks:  upload-server-network:    driver: bridge</code></pre><hr><p><strong><em>Egg.js 全局错误处理返回格式问题</em></strong></p><p>Egg.js 本身有一个全局错误处理的插件 <a href="https://github.com/eggjs/egg-onerror" target="_blank" rel="noopener">egg-onerror</a>，但是用这个插件在处理上传文件的异常时，直接 <code>throw</code> 错误，返回给前端的数据格式是文本类型的，不是 json 格式，除非前端在发送请求的添加 <code>Accept: application/json</code> 请求头信息。<br>只能在 <code>config.default.js</code> 使用 <code>all</code> 进行捕获异常，然后用 <code>JSON.stringify</code> 方法在处理一遍，这样 <code>throw new Error(e.message)</code> 的时候返回给前端的才是 json。</p><pre><code class="js">config.onerror = {  all(err, ctx) {    ctx.status = err.status || 500    ctx.body = JSON.stringify({      code: ctx.status,      success: false,      message: err.message,    })  },}</code></pre><p>最终还是没有使用这个插件，自己添加了一个方法，进行异常捕获。</p><pre><code class="ts">private error(msg) {  const { ctx } = this  ctx.status = 400  ctx.body = {    code: ctx.status,    success: false,    message: msg,  }}...this.error(&#39;错误的 bucket&#39;)return</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Egg.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Flutter 实现一个走马灯布局</title>
      <link href="/post/2019/11/20/flutter-carousel/"/>
      <url>/post/2019/11/20/flutter-carousel/</url>
      
        <content type="html"><![CDATA[<img src="images/carousel.jpg" height="334"><p>走马灯是一种常见的效果，本文讲一下如何用 <code>PageView</code> 在 <code>Flutter</code> 里实现一个走马灯</p><a id="more"></a><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>实现的效果如下，当前页面的高度比其它页面高，切换页面的时候有一个高度变化的动画。实现这样的效果主要用到的是 <code>PageView.builder</code> 部件。</p><div><video src="videos/heroes.mp4" controls width="320" autoplay muted></div><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="创建首页"><a href="#创建首页" class="headerlink" title="创建首页"></a>创建首页</h3><p>首先创建一个 <code>IndexPage</code> 部件，这个部件用来放 <code>PageView</code>，因为需要使用 <code>setState</code> 方法更新 UI，所以它是 stateful 的。</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;class IndexPage extends StatefulWidget {  @override  _IndexPageState createState() =&gt; _IndexPageState();}class _IndexPageState extends State&lt;IndexPage&gt; {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        elevation: 0.0,        backgroundColor: Colors.white,      ),      body: Column(        children: &lt;Widget&gt;[],      ),    );  }}</code></pre><p>然后在部件内申明一个 <code>_pageIndex</code> 变量用来保存当前显示的页面的 index，在 <code>initState</code> 生命周期里面初始化一个 <code>PageController</code> 用来配置 <code>PageView</code> 部件。</p><p>在 <code>body</code> 的 <code>Column</code> 里面创建一个 <code>PageView.builder</code>，使用一个 <code>SizedBox</code> 部件指定 <code>PageView</code> 的高度，将 <code>controller</code> 设置为 <code>_pageController</code>，在 <code>onPageChanged</code> 事件里将当前显示页面的 <code>index</code> 值赋值给 <code>_pageIndex</code> 变量。</p><pre><code class="dart">int _pageIndex = 0;PageController _pageController;@overridevoid initState() {  super.initState();  _pageController = PageController(    initialPage: 0,    viewportFraction: 0.8,  );}body: Column(  children: &lt;Widget&gt;[    SizedBox(      height: 580.0,      child: PageView.builder(        itemCount: 3,        pageSnapping: true,        controller: _pageController,        onPageChanged: (int index) {          setState(() {            _pageIndex = index;          });        },        itemBuilder: (BuildContext ctx, int index) {          return _buildItem(_pageIndex, index);        },      ),    ),  ],),</code></pre><blockquote><p>关键点: 设置 <code>PageController</code> 的 <code>viewportFraction</code> 参数小于 1，这个值是用来设置每个页面在屏幕上显示的比例，小于 1 的话，就可以在当前页面同时显示其它页面的内容了。</p><pre><code class="dart">/// The fraction of the viewport that each page should occupy./// Defaults to 1.0, which means each page fills the viewport in the scrolling direction.final double viewportFraction;</code></pre></blockquote><h3 id="实现-buildItem"><a href="#实现-buildItem" class="headerlink" title="实现 _buildItem"></a>实现 <code>_buildItem</code></h3><p>接着实现 <code>_buildItem</code> 方法，这个方法就是返回 <code>PageView.builder</code> 里每一个页面渲染的内容，第一个参数 <code>activeIndex</code> 是当前显示在屏幕上页面的 <code>index</code>，第二个参数 <code>index</code> 是每一项自己的 <code>index</code>。</p><p>使用一个 <code>Center</code> 部件让内容居中显示，然后用一个 <code>AnimatedContainer</code> 添加页面切换时的高度变化的动画效果，切换页面的时候使用了<code>setState</code> 方法改变了 <code>_pageIndex</code>，<code>Flutter</code> 重新绘制每一项。关键点在于判断当前页面是否为正在显示的页面，是的话它的高度就是 500 不是的话就是 450。</p><pre><code class="dart">_buildItem(activeIndex, index) {  return Center(    child: AnimatedContainer(      curve: Curves.easeInOut,      duration: Duration(milliseconds: 300),      height: activeIndex == index ? 500.0 : 450.0,      margin: EdgeInsets.symmetric(vertical: 20.0, horizontal: 10.0),      decoration: BoxDecoration(        color: heroes[index].color,        borderRadius: BorderRadius.all(Radius.circular(12.0)),      ),      child: Stack(),    ),  );}</code></pre><img src="images/empty00.jpg" width="320" style="width:320px"><h3 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h3><p>然后给 <code>AnimatedContainer</code> 添加每一项的内容</p><pre><code class="dart">child: Stack(  fit: StackFit.expand,  children: &lt;Widget&gt;[    ClipRRect(      borderRadius: BorderRadius.all(        Radius.circular(12.0),      ),      child: Image.network(        heroes[index].image,        fit: BoxFit.cover,      ),    ),    Align(      alignment: Alignment.bottomCenter,      child: Row(        children: &lt;Widget&gt;[          Expanded(            child: Container(              padding: EdgeInsets.all(12.0),              decoration: BoxDecoration(                color: Colors.black26,                borderRadius: BorderRadius.only(                  bottomRight: Radius.circular(12.0),                  bottomLeft: Radius.circular(12.0),                ),              ),              child: Text(                heroes[index].title,                textAlign: TextAlign.center,                style: TextStyle(                  fontSize: 20.0,                  fontWeight: FontWeight.bold,                  color: Colors.white,                ),              ),            ),          )        ],      ),    ),  ],),</code></pre><h3 id="实现指示器"><a href="#实现指示器" class="headerlink" title="实现指示器"></a>实现指示器</h3><p>然后实现页面的指示器，创建一个 <code>PageIndicator</code> 部件，需要传入 <code>pageCount</code> 表示总页数，以及 <code>currentIndex</code> 表示当前显示的页数索引。把所有指示器放在一个 <code>Row</code> 部件里，判断当前指示器的 <code>index</code> 是否为正在显示页面的 <code>index</code>，是的话显示较深的颜色。</p><pre><code class="dart">class PageIndicator extends StatelessWidget {  final int pageCount;  final int currentIndex;  const PageIndicator(this.currentIndex, this.pageCount);  Widget _indicator(bool isActive) {    return Container(      width: 6.0,      height: 6.0,      margin: EdgeInsets.symmetric(horizontal: 3.0),      decoration: BoxDecoration(        color: isActive ? Color(0xff666a84) : Color(0xffb9bcca),        shape: BoxShape.circle,        boxShadow: [          BoxShadow(            color: Colors.black12,            offset: Offset(0.0, 3.0),            blurRadius: 3.0,          ),        ],      ),    );  }  List&lt;Widget&gt; _buildIndicators() {    List&lt;Widget&gt; indicators = [];    for (int i = 0; i &lt; pageCount; i++) {      indicators.add(i == currentIndex ? _indicator(true) : _indicator(false));    }    return indicators;  }  @override  Widget build(BuildContext context) {    return Row(      mainAxisAlignment: MainAxisAlignment.center,      children: _buildIndicators(),    );  }}</code></pre><p>添加 <code>PageIndicator</code> 到 <code>SizedBox</code> 下放</p><h3 id="封装-Carousel"><a href="#封装-Carousel" class="headerlink" title="封装 Carousel"></a>封装 <code>Carousel</code></h3><p>最后的最后优化一下代码，把部件封装一下，让它成为一个单独的部件，创建一个 <code>Carousel</code> 部件，对外暴露 <code>items</code> 和 <code>height</code> 两个属性，分别配置数据和高度。</p><pre><code class="dart">class Carousel extends StatefulWidget {  final List items;  final double height;  const Carousel({    @required this.items,    @required this.height,  });  @override  _CarouselState createState() =&gt; _CarouselState();}class _CarouselState extends State&lt;Carousel&gt; {  int _pageIndex = 0;  PageController _pageController;  Widget _buildItem(activeIndex, index) {    final items = widget.items;    return Center(      child: AnimatedContainer(        curve: Curves.easeInOut,        duration: Duration(milliseconds: 300),        height: activeIndex == index ? 500.0 : 450.0,        margin: EdgeInsets.symmetric(vertical: 20.0, horizontal: 10.0),        decoration: BoxDecoration(          color: items[index].color,          borderRadius: BorderRadius.all(Radius.circular(12.0)),        ),        child: Stack(          fit: StackFit.expand,          children: &lt;Widget&gt;[            ClipRRect(              borderRadius: BorderRadius.all(                Radius.circular(12.0),              ),              child: Image.network(                items[index].image,                fit: BoxFit.cover,              ),            ),            Align(              alignment: Alignment.bottomCenter,              child: Row(                children: &lt;Widget&gt;[                  Expanded(                    child: Container(                      padding: EdgeInsets.all(12.0),                      decoration: BoxDecoration(                        color: Colors.black26,                        borderRadius: BorderRadius.only(                          bottomRight: Radius.circular(12.0),                          bottomLeft: Radius.circular(12.0),                        ),                      ),                      child: Text(                        items[index].title,                        textAlign: TextAlign.center,                        style: TextStyle(                          fontSize: 20.0,                          fontWeight: FontWeight.bold,                          color: Colors.white,                        ),                      ),                    ),                  )                ],              ),            ),          ],        ),      ),    );  }  @override  void initState() {    super.initState();    _pageController = PageController(      initialPage: 0,      viewportFraction: 0.8,    );  }  @override  Widget build(BuildContext context) {    return Column(      children: &lt;Widget&gt;[        Container(          height: widget.height,          child: PageView.builder(            pageSnapping: true,            itemCount: heroes.length,            controller: _pageController,            onPageChanged: (int index) {              setState(() {                _pageIndex = index;              });            },            itemBuilder: (BuildContext ctx, int index) {              return _buildItem(_pageIndex, index);            },          ),        ),        PageIndicator(_pageIndex, widget.items.length),      ],    );  }}</code></pre><p>之后在 <code>IndexPage</code> 部件里就只用实例化一个 <code>Carousel</code> 了，同时由于 <code>IndexPage</code> 不用管理部件状态了，可以将它变成 <code>StatelessWidget</code>。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;class Hero {  final Color color;  final String image;  final String title;  Hero({    @required this.color,    @required this.image,    @required this.title,  });}List heroes = [  Hero(    color: Color(0xFF86F3FB),    image: &quot;https://game.gtimg.cn/images/lol/act/img/skin/big22009.jpg&quot;,    title: &#39;寒冰射手-艾希&#39;,  ),  Hero(    color: Color(0xFF7D6588),    image: &quot;https://game.gtimg.cn/images/lol/act/img/skin/big39006.jpg&quot;,    title: &#39;刀锋舞者-艾瑞莉娅&#39;,  ),  Hero(    color: Color(0xFF4C314D),    image: &quot;https://game.gtimg.cn/images/lol/act/img/skin/big103015.jpg&quot;,    title: &#39;九尾妖狐-阿狸&#39;,  ),];class Carousel extends StatefulWidget {  final List items;  final double height;  const Carousel({    @required this.items,    @required this.height,  });  @override  _CarouselState createState() =&gt; _CarouselState();}class _CarouselState extends State&lt;Carousel&gt; {  int _pageIndex = 0;  PageController _pageController;  Widget _buildItem(activeIndex, index) {    final items = widget.items;    return Center(      child: AnimatedContainer(        curve: Curves.easeInOut,        duration: Duration(milliseconds: 300),        height: activeIndex == index ? 500.0 : 450.0,        margin: EdgeInsets.symmetric(vertical: 20.0, horizontal: 10.0),        decoration: BoxDecoration(          color: items[index].color,          borderRadius: BorderRadius.all(Radius.circular(12.0)),        ),        child: Stack(          fit: StackFit.expand,          children: &lt;Widget&gt;[            ClipRRect(              borderRadius: BorderRadius.all(                Radius.circular(12.0),              ),              child: Image.network(                items[index].image,                fit: BoxFit.cover,              ),            ),            Align(              alignment: Alignment.bottomCenter,              child: Row(                children: &lt;Widget&gt;[                  Expanded(                    child: Container(                      padding: EdgeInsets.all(12.0),                      decoration: BoxDecoration(                        color: Colors.black26,                        borderRadius: BorderRadius.only(                          bottomRight: Radius.circular(12.0),                          bottomLeft: Radius.circular(12.0),                        ),                      ),                      child: Text(                        items[index].title,                        textAlign: TextAlign.center,                        style: TextStyle(                          fontSize: 20.0,                          fontWeight: FontWeight.bold,                          color: Colors.white,                        ),                      ),                    ),                  )                ],              ),            ),          ],        ),      ),    );  }  @override  void initState() {    super.initState();    _pageController = PageController(      initialPage: 0,      viewportFraction: 0.8,    );  }  @override  Widget build(BuildContext context) {    return Column(      children: &lt;Widget&gt;[        Container(          height: widget.height,          child: PageView.builder(            pageSnapping: true,            itemCount: heroes.length,            controller: _pageController,            onPageChanged: (int index) {              setState(() {                _pageIndex = index;              });            },            itemBuilder: (BuildContext ctx, int index) {              return _buildItem(_pageIndex, index);            },          ),        ),        PageIndicator(_pageIndex, widget.items.length),      ],    );  }}class PageIndicator extends StatelessWidget {  final int currentIndex;  final int pageCount;  const PageIndicator(this.currentIndex, this.pageCount);  Widget _indicator(bool isActive) {    return Container(      width: 6.0,      height: 6.0,      margin: EdgeInsets.symmetric(horizontal: 3.0),      decoration: BoxDecoration(        color: isActive ? Color(0xff666a84) : Color(0xffb9bcca),        shape: BoxShape.circle,        boxShadow: [          BoxShadow(            color: Colors.black12,            offset: Offset(0.0, 3.0),            blurRadius: 3.0,          ),        ],      ),    );  }  List&lt;Widget&gt; _buildIndicators() {    List&lt;Widget&gt; indicators = [];    for (int i = 0; i &lt; pageCount; i++) {      indicators.add(i == currentIndex ? _indicator(true) : _indicator(false));    }    return indicators;  }  @override  Widget build(BuildContext context) {    return Row(      mainAxisAlignment: MainAxisAlignment.center,      children: _buildIndicators(),    );  }}class IndexPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(        elevation: 0.0,        backgroundColor: Colors.white,      ),      body: Carousel(        height: 540,        items: heroes,      ),      backgroundColor: Colors.white,    );  }}</code></pre><p>至此，整个布局就完成了！ 😎</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享两道面试题</title>
      <link href="/post/2019/11/15/two-interview-question/"/>
      <url>/post/2019/11/15/two-interview-question/</url>
      
        <content type="html"><![CDATA[<p>前几天遇到两个前端面试题，要写代码的那种，然后我都没做对…记录一下</p><a id="more"></a><p>前几天遇到两个前端面试题，要写代码的那种，然后我都没做对…记录一下</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote><p>JavaScript 采用原型继承，即一个对象继承自另外一个对象，另外一个对象再继承自别的对象，依此往复。请写一个通用的 JavaScript 函数，来找出某个对象身上的某个属性继承自哪个对象。</p></blockquote><p>解答: 实际上是在考察如何判断一个对象上的属性是本身的还是通过继承来的，使用 <code>hasOwnProperty</code> 和 <code>getPrototypeOf</code> 方法即可</p><pre><code>function getPrototype(obj, key) {  if (obj.hasOwnProperty(key)) {    return obj  }  return getPrototype(Object.getPrototypeOf(obj), key)}const obj = { a: 'a' }const o1 = Object.create(obj)o1.b = 'b'console.log(o1.a) // aconsole.log(o1.b) // bconsole.log(o1.hasOwnProperty('a')) // falseconsole.log(o1.hasOwnProperty('b')) // trueconsole.log(getPrototype(o1, 'a')) // { a: 'a' }console.log(getPrototype(o1, 'b')) // { b: 'b' }</code></pre><p>相关文章</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承与原型链</a></p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><blockquote><p><code>URLSearchParams()</code> 可以解析和处理URL参数，目前兼容性一般，请实现 <code>class URLSearchParams</code> 的 polyfill。</p><pre><code class="js">searchParams = new URLSearchParams(&quot;foo=1&amp;bar=2&quot;)// 或者这样传入searchParams = new URLSearchParams({foo: &quot;1&quot;, bar: &quot;2&quot;})// 实例支持 get()、set()、has()、append() 四个方法// 支持以下方式searchParams.get(&quot;foo&quot;) // 1searchParams.set(&quot;foo&quot;, &quot;10&quot;)searchParams.has(&quot;bar&quot;)searchParams.append(&quot;foo&quot;, &quot;100&quot;)</code></pre></blockquote><p>解答：简单实现了下，看了 Github 上 <code>URLSearchParams</code> 的 polyfill 代码，发现这个还是有点复杂的</p><pre><code>class URLSearchParams {  constructor (query) {    this._query = {}    if (typeof query === 'string') {      if (query.startsWith('?', 0)) {        query = query.slice(1)      }      query.split('&').forEach(pair => {        const params = pair.split('=')        const key = params[0]        const val = params[1]        this._query[key] = val      })    } else {      for (let [key, value] of Object.entries(query)) {        this._query[key] = query[key]      }    }  }  get (key) {    return this.has(key) ? this._query[key] : null  }  set (key, val) {    this._query[key] = encodeURIComponent(val)    return true  }  has (key) {    return key in this._query  }  append (key, val) {    const value = Array.isArray(val) ? val.join(',') : val    if (key in this._query) {      this._query[key].push(value)    } else {      this._query[key] = value    }    return this._query[key]  }}const mysp1 = new URLSearchParams('a=aaa&b=bbb')const mysp2 = new URLSearchParams({ c: 'ccc', d: 'ddd' })console.log(mysp1) // URLSearchParams { _query: { a: 'aaa', b: 'bbb' } }console.log(mysp1.get('a')) // aaaconsole.log(mysp1.set('c', 'ccc')) // trueconsole.log(mysp1.has('d')) // falseconsole.log(mysp1.append('e', 'eee')) // eeeconsole.log(mysp1) // { _query: { a: 'aaa', b: 'bbb', c: 'ccc', e: 'eee' } }console.log(mysp2) // URLSearchParams { _query: { c: 'ccc', d: 'ddd' } }console.log(mysp2.get('c')) // cccconsole.log(mysp2.set('d', 'ddd2')) // trueconsole.log(mysp2.has('d')) // trueconsole.log(mysp2.append('f', 'fff')) // fffconsole.log(mysp2) // URLSearchParams { _query: { c: 'ccc', d: 'ddd2', f: 'fff' } }</code></pre><p>相关文章</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams" target="_blank" rel="noopener">URLSearchParams docs</a></p><p><a href="https://github.com/ungap/url-search-params" target="_blank" rel="noopener">URLSearchParams polyfill</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己太菜了，基础知识由于没有去回顾所以忘的很多，继续加油吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 FFmpeg 转换视频格式</title>
      <link href="/post/2019/11/11/simple-use-ffmpeg/"/>
      <url>/post/2019/11/11/simple-use-ffmpeg/</url>
      
        <content type="html"><![CDATA[<p>用 B 站下载助手 下载下来的视频格式是 <code>flv</code>，用 QuickTime 看不了也不能导入 iMovie 进行编辑，所以需要转换一下视频格式。在搜索了很多视频格式转换工具后，发现它们大多底层是用 <a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a> 这个开源工具进行转换的，所以为什么不直接用 <code>FFmpeg</code> 它本身呢</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用 B 站下载助手 下载下来的视频格式是 <code>flv</code>，用 QuickTime 看不了也不能导入 iMovie 进行编辑，所以需要转换一下视频格式。在搜索了很多视频格式转换工具后，发现它们大多底层是用 <a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a> 这个开源工具进行转换的，所以为什么不直接用 <code>FFmpeg</code> 它本身呢。</p><h2 id="关于-FFmpeg"><a href="#关于-FFmpeg" class="headerlink" title="关于 FFmpeg"></a>关于 FFmpeg</h2><p>官方描述：FFmpeg 是一种非常快速的视频和音频转换器，也可以从实时音频/视频源中获取。 它还可以在任意采样率之间转换，并使用高质量的多相滤波器即时调整视频大小。</p><p>转换流程</p><pre><code class="pre"> _______              ______________|       |            |              || input |  demuxer   | encoded data |   decoder| file  | ---------&gt; | packets      | -----+|_______|            |______________|      |                                           v                                       _________                                      |         |                                      | decoded |                                      | frames  |                                      |_________| ________             ______________       ||        |           |              |      || output | &lt;-------- | encoded data | &lt;----+| file   |   muxer   | packets      |   encoder|________|           |______________|</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先安装 <code>FFmpeg</code>，macOS 可以使用 <code>homebrew</code> 安装</p><pre><code class="sh">brew install ffmpeg</code></pre><p>Windows 到 <code>https://ffmpeg.zeranoe.com/builds</code> 这里下载 zip 包，然后将 <code>bin</code> 目录添加到环境变量 <code>PATH</code> 中，在命令行中运行 <code>ffmpeg</code> 命令，出现提示语即表示安装成功</p><p><img src="images/ffmpeg-hint.jpg" alt="hint"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>只需一条命令即可对视频进行格式转换，<code>-i</code> 参数表示需要转换的视频，值是视频路径，后面的是转换后的视频文件名。</p><pre><code class="sh">ffmpeg -i input.mp4 output.avi</code></pre><p>转换过程中会出现进度提示</p><p><img src="images/ffmpeg-running.jpg" alt="running"></p><ul><li><code>frame</code> 表示是转码所进行到的帧数。</li><li><code>fps</code> 表示中的 FPS 就是 Frame per Second ，是现在电脑每秒所处理的帧的数量，这个数字跟视频的帧率无关。</li><li><code>size</code> 表示已经转换出来的视频的体积。</li><li><code>time</code> 表示经转换出来的视频的时间。</li></ul><h2 id="转换参数"><a href="#转换参数" class="headerlink" title="转换参数"></a>转换参数</h2><p><code>-r</code></p><p>这个选项设置视频帧率, 单位是 Hz，也就是帧每秒 FPS，如 <code>-r 30</code> 即代表输出视频的帧率为每秒 30 帧，降低帧率可以减小视频的体积。</p><pre><code class="sh">ffmpeg -i input.mp4 -r 30 output.mp4</code></pre><p><code>-s</code></p><p>默认输出的视频尺寸与原视频相同，<code>-s 720x480</code> 选项可以指定输出视频的尺寸，以像素为单位。</p><pre><code class="sh">ffmpeg -i input.mp4 -s 720x480 output.mp4</code></pre><p><code>-t</code></p><p>用来指定输出文件的持续时间，以秒为单位，如截取 input.mp4 的前 30 秒并保存为 output.mp4。</p><pre><code class="sh">ffmpeg -i input.mp4 -t 30 output.mp4</code></pre><p><code>-c</code></p><p>用来指定输出文件的编码，设置 <code>-c copy</code> 让 <code>FFmpeg</code> 在转换音视频时不重新进行编码，减少转换耗时。</p><pre><code class="sh">ffmpeg -i input.mp4 -c copy -t 30 output.mp4</code></pre><p>执行 help 命令，可以看到更多关于视频转换的选项</p><pre><code class="sh">ffmpeg -help</code></pre><p><img src="images/ffmpeg-video-opt.jpg" alt="video-options"></p><ul><li><code>-vframes</code> 设置要输出的视频帧数</li><li><code>-r</code> 速率设置帧速率（Hz值，分数或缩写）</li><li><code>-s</code> size设置帧大小（WxH或缩写）</li><li><code>-aspect</code> 宽高比设置的宽高比（4：3、16：9或1.3333、1.7777）</li><li><code>-bits_per_raw_sample</code> 设置每个原始样本的位数</li><li><code>-vn</code> 禁用视频</li><li><code>-vcodec</code> 编解码器强制视频编解码器（“复制”以复制流）</li><li><code>-timecode</code> 单位 hh：mm：ss [：;。] ff设置初始 TimeCode 值。</li><li><code>-pass n</code> 选择通过次数（1到3）</li><li><code>-vf filter_graph</code> 设置视频过滤器</li><li><code>-ab</code> 比特率音频比特率（请使用-b：a）</li><li><code>-b</code> 比特率视频比特率（请使用-b：v）</li><li><code>-dn</code> 禁用数据</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ffmpeg.org/documentation.html" target="_blank" rel="noopener">FFmpeg Documentation</a></p><p><a href="https://wiki.fiveyellowmice.com/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8_FFmpeg_%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81:%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">如何使用_FFmpeg_进行视频转码</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对 Egg.js 进行单元测试</title>
      <link href="/post/2019/11/01/eggjs-test/"/>
      <url>/post/2019/11/01/eggjs-test/</url>
      
        <content type="html"><![CDATA[<p>优秀的代码需要有单元测试进行质量保证，每个测试用例都给应用的稳定性提供了一层保障，本文说一下如何对使用 egg.js 写的接口进行单元测试</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>优秀的代码需要有单元测试进行质量保证，每个测试用例都给应用的稳定性提供了一层保障。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>egg.js 工程的测试代码都是放在工程的 test 目录下，命名的方式为 <code>${filename}.test.js</code>，比如我想测试项目的 <code>user</code> <code>controller</code> 就在 <code>test</code> 目录下新建一个 <code>controller/user.test.js</code>，同理要测 <code>service</code> 就是创建一个 <code>service</code> 目录，然后就是写具体的测试代码了。</p><p>假设现在需要对一个 <code>UserService</code> 进行测试，首先在 <code>user.test.js</code> 中引入 <code>egg-mock</code> 模块用来创建一个 <code>app</code> 实例以及一个 <code>ctx</code> 对象，一般在请求接口的时候会在 <code>ctx</code> 对象上携带这次请求的参数和是用户信息，需要在创建 <code>ctx</code> 的时候添加所要的数据，最好的方式是 <code>before</code> 函数中，将这些数据附加到 <code>ctx</code> 上。</p><pre><code class="js">const { app, assert } = require(&#39;egg-mock/bootstrap&#39;)let ctxbefore(() =&gt; {  ctx = app.mockContext({    user: {      name: &#39;your-name&#39;    }  })})</code></pre><p>如果还需要添加请求头信息，比如用户的 <code>token</code> 可以这样添加</p><pre><code class="js">ctx.request.headers = {  authorization: yourToken}</code></pre><p>准备完毕，接下来编写具体的测试代码了，假如 <code>UserService</code> 有一个 <code>create</code> 方法，作用是创建一个新的 <code>user</code>，参数是请求体传过来的新建用户数据，那么可以这样写测试代码</p><pre><code class="js">it(&#39;create 方法返回新增用户成功信息&#39;, async () =&gt; {  const data = {    name: &#39;user name&#39; + Date.now(),    age: parseInt(Math.random() * 60),    gender: Math.random() &gt; 0.5 ? &#39;male&#39; : &#39;female&#39;  }  const response = await ctx.service.user.create(data)  assert(response.success === true)  assert(response.payload.length &gt; 0)})</code></pre><p>完整的代码</p><pre><code>'use strict';const { app, assert } = require('egg-mock/bootstrap');describe('用户服务测试', () => {  let ctx  before(() => {    ctx = app.mockContext({      user: {        name: 'your-name',      },    });    ctx.request.headers = {      authorization: yourToken    };  })  it('create 方法返回新增用户成功信息', async () => {    const data = {      name: 'user name' + Date.now(),      age: parseInt(Math.random() * 60),      gender: Math.random() > .5 ? 'male' : 'female'    };    const response = await ctx.service.user.create(data);    assert(response.success === true);    assert(response.payload.length > 0);  });})</code></pre><p>断言返回值的 <code>success</code> 为 <code>true</code>，<code>payload</code> 的 <code>length</code> 属性长度大于 0，当然这需要根据具体的业务来写，一个 <code>service</code> 可能会有很多的方法，需要尽可能多的对这些方法进行测试。</p><p>最后就是执行测试代码了</p><pre><code class="sh">npm run test</code></pre><p>通过命令 <code>npm run test</code> 执行 <code>egg-bin test</code>，或者在 <code>Idea</code> 添加一个测试的 <code>configuration</code> 点击执行即可，这样 <code>test</code> 目录下的所有测试都会运行。运行全部的测试耗时可能会很长或者有时只需要对一个测试文件进行测试，这时通过指定测试文件的路径即可</p><pre><code class="sh">npm run test &lt;TestFilePath&gt;</code></pre><p>运行测试的时候会加载 <code>config.unittest.js</code> 里面的配置，运行完毕，没有通过的测试会显示具体的错误信息，可以方便的定位错误，如果测试都通过了就会出现测试通过的以及耗时信息</p><p><img src="images/egg-test.jpg" alt="test"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://eggjs.org/zh-cn/core/unittest.html" target="_blank" rel="noopener">单元测试</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker ARG vs ENV</title>
      <link href="/post/2019/10/25/docker-arg-vs-env/"/>
      <url>/post/2019/10/25/docker-arg-vs-env/</url>
      
        <content type="html"><![CDATA[<p>构建 Docker 镜像的的时候有两种环境变量 <code>ARG</code> 和 <code>ENV</code>, 一种是在运行 build 命令时通过 <code>--build-arg</code> 参数设置的 build-time variables 以及通过在 <code>dockerfile</code> 里面设置 <code>ENV</code> 指令配置的环境变量。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>构建 Docker 镜像的的时候有两种环境变量 <code>ARG</code> 和 <code>ENV</code>, 一种是在运行 build 命令时通过 <code>--build-arg</code> 参数设置的 build-time variables 以及通过在 <code>dockerfile</code> 里面设置 <code>ENV</code> 指令配置的环境变量，本文说明它们之间的区别。</p><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p>Dockerfile 里面的 ARG 指令定义了一个变量，在运行 <code>docker build</code> 命令时使用 <code>--build-arg &lt;varname&gt; = &lt;value&gt;</code> 参数将其传递给构建器。</p><pre><code class="dockerfile">ARG &lt;name&gt;[=&lt;default value&gt;]</code></pre><p>这种变量只存在于镜像构建的时候，一旦镜像构建完成就失效了，不要使用构建时变量来传递诸如 github 密钥，用户凭据等机密数据，构建时变量值可以使用 docker history 命令查看。</p><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>Dockerfile 里面的 ENV 指令将环境变量<key>设置为值<value>，这个变量将在构建阶段中所有后续指令的环境中使用。</value></key></p><pre><code class="dockerfile">ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ...</code></pre><p>使用 ENV 设置的环境变量将一直存在于构建镜像时以及镜像容器运行时，可以使用 docker inspect 查看设置打的变量。也可以使用 <code>docker run --env &lt;key&gt; = &lt;value&gt;</code> 来更改它们。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果只是需要构建镜像时的环境变量，使用 <code>ARG</code>，如果这个变量在容器运行时也有用到就需要用 <code>ENV</code>，注意使用 <code>ENV</code> 指令定义的环境变量会覆盖同名的 <code>ARG</code> 指令定义的变量。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端代码规范</title>
      <link href="/post/2019/10/10/code-standard/"/>
      <url>/post/2019/10/10/code-standard/</url>
      
        <content type="html"><![CDATA[<p>良好的代码规范有利于提高项目开发效率以及减少阅读代码的困难，本规范结合了(chaoxi)多个流行的代码规范以及前人的开发经验而成，参考规范进行开发提高代码质量</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>良好的代码规范有利于提高项目开发效率以及减少阅读代码的困难，本规范结合了(chaoxi)多个流行的代码规范以及前人的开发经验而成，参考规范进行开发提高代码质量</p><h2 id="HTML-规范"><a href="#HTML-规范" class="headerlink" title="HTML 规范"></a>HTML 规范</h2><p>设置标准模式的文档类型</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt; &lt;/head&gt;&lt;/html&gt;</code></pre><p>设置页面语言</p><pre><code class="html">&lt;html lang=&quot;zh-CN&quot;&gt;&lt;/html&gt;</code></pre><p>设置页面字符编码</p><pre><code class="html">&lt;meta charset=&quot;UTF-8&quot; /&gt;</code></pre><p>使用语义化的标签准确地描述网页的内容</p><pre><code class="html">&lt;main&gt;  &lt;article&gt;    &lt;header&gt;      &lt;h1&gt;title&lt;/h1&gt;      &lt;p&gt;published: &lt;time datetime=&quot;2015-02-21&quot;&gt;21st Feb, 2015&lt;/time&gt;&lt;/p&gt;    &lt;/header&gt;    &lt;p&gt;content&lt;/p&gt;  &lt;/article&gt;  &lt;aside&gt;...&lt;/aside&gt;  &lt;footer&gt;...&lt;/footer&gt;&lt;/main&gt;</code></pre><p>确保页面可访问性</p><ul><li>给 <code>img</code> 标签添加正确的 <code>alt</code> 属性</li><li>使用 <code>label</code> 标签对表单进行控制</li></ul><p>使用字符实体替代特殊字符</p><pre><code class="html">&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;copy;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;</code></pre><p>使用两个空格缩进</p><pre><code class="html">&lt;section&gt;  &lt;h1&gt;&lt;/h1&gt;&lt;/section&gt;</code></pre><p>按特定顺序书写标签属性</p><ol><li><code>class</code></li><li><code>id</code>, <code>name</code></li><li><code>data-*</code></li><li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code></li><li><code>title</code>, <code>alt</code></li><li><code>role</code>, <code>aria-*</code></li></ol><pre><code class="html">&lt;!-- 示例 --&gt;&lt;a class=&quot;link&quot; id=&quot;link&quot; data-toggle=&quot;modal&quot; href=&quot;#&quot;&gt;link&lt;/a&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot; /&gt;&lt;img src=&quot;example.jpg&quot; alt=&quot;dog&quot; /&gt;</code></pre><p>不对布尔属性赋值</p><pre><code class="html">&lt;!-- 示例 --&gt;&lt;input type=&quot;text&quot; disabled /&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked /&gt;&lt;select&gt;  &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="CSS-规范"><a href="#CSS-规范" class="headerlink" title="CSS 规范"></a>CSS 规范</h2><p>全局设置盒子模型</p><pre><code class="css">* {  box-sizing: border-box;}</code></pre><p>使用简洁的 class 命名</p><p>class 的命名应该尽量简洁、明确，以字母开头命名，且全部字母为小写，单词之间使用连字符 “-” 连接。<br>每个模块使用一个模块命名，子元素使用模块名 + 元素作用名名</p><pre><code class="html">&lt;!-- 示例 --&gt;&lt;header class=&quot;header&quot;&gt;  &lt;h1 class=&quot;header-title&quot;&gt;&lt;/h1&gt;&lt;/header&gt;</code></pre><p>使用常用的 class 命名</p><p><strong>包裹类：</strong> container, wrapper, outer, inner, box, header, footer, main, content, aside, page, section, block</p><p><strong>状态类：</strong> primary, secondary, success, danger, warning, info, error, link, light, dark, disabled, active, checked, loading</p><p><strong>尺寸类：</strong> large, middle, small, bigger, smaller</p><p><strong>组件类：</strong> card, list, picture, carousel, swiper, menu, navs, badge, hint, modal, dialog</p><p><strong>位置类：</strong> first, last, current, prev, next, forward, back</p><p><strong>文本类：</strong> title, desc, content, date, author, category，label，tag</p><p><strong>人物类：</strong> avatar, name, age, post, intro</p><table><thead><tr><th align="left">Class Name</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">about</td><td align="left">关于</td></tr><tr><td align="left">account</td><td align="left">账户</td></tr><tr><td align="left">arrow</td><td align="left">箭头图标</td></tr><tr><td align="left">article</td><td align="left">文章</td></tr><tr><td align="left">aside</td><td align="left">边栏</td></tr><tr><td align="left">audio</td><td align="left">音频</td></tr><tr><td align="left">avatar</td><td align="left">头像</td></tr><tr><td align="left">bg,background</td><td align="left">背景</td></tr><tr><td align="left">bar</td><td align="left">栏（工具类）</td></tr><tr><td align="left">branding</td><td align="left">品牌化</td></tr><tr><td align="left">crumb,breadcrumbs</td><td align="left">面包屑</td></tr><tr><td align="left">btn,button</td><td align="left">按钮</td></tr><tr><td align="left">caption</td><td align="left">标题，说明</td></tr><tr><td align="left">category</td><td align="left">分类</td></tr><tr><td align="left">chart</td><td align="left">图表</td></tr><tr><td align="left">clearfix</td><td align="left">清除浮动</td></tr><tr><td align="left">close</td><td align="left">关闭</td></tr><tr><td align="left">col,column</td><td align="left">列</td></tr><tr><td align="left">comment</td><td align="left">评论</td></tr><tr><td align="left">community</td><td align="left">社区</td></tr><tr><td align="left">container</td><td align="left">容器</td></tr><tr><td align="left">content</td><td align="left">内容</td></tr><tr><td align="left">copyright</td><td align="left">版权</td></tr><tr><td align="left">current</td><td align="left">当前态，选中态</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">description</td><td align="left">描述</td></tr><tr><td align="left">details</td><td align="left">细节</td></tr><tr><td align="left">disabled</td><td align="left">不可用</td></tr><tr><td align="left">entry</td><td align="left">文章，博文</td></tr><tr><td align="left">error</td><td align="left">错误</td></tr><tr><td align="left">even</td><td align="left">偶数，常用于多行列表或表格中</td></tr><tr><td align="left">fail</td><td align="left">失败（提示）</td></tr><tr><td align="left">feature</td><td align="left">专题</td></tr><tr><td align="left">fewer</td><td align="left">收起</td></tr><tr><td align="left">field</td><td align="left">用于表单的输入区域</td></tr><tr><td align="left">figure</td><td align="left">图</td></tr><tr><td align="left">filter</td><td align="left">筛选</td></tr><tr><td align="left">first</td><td align="left">第一个，常用于列表中</td></tr><tr><td align="left">footer</td><td align="left">页脚</td></tr><tr><td align="left">forum</td><td align="left">论坛</td></tr><tr><td align="left">gallery</td><td align="left">画廊</td></tr><tr><td align="left">group</td><td align="left">模块，清除浮动</td></tr><tr><td align="left">header</td><td align="left">页头</td></tr><tr><td align="left">help</td><td align="left">帮助</td></tr><tr><td align="left">hide</td><td align="left">隐藏</td></tr><tr><td align="left">hightlight</td><td align="left">高亮</td></tr><tr><td align="left">home</td><td align="left">主页</td></tr><tr><td align="left">icon</td><td align="left">图标</td></tr><tr><td align="left">info,information</td><td align="left">信息</td></tr><tr><td align="left">last</td><td align="left">最后一个，常用于列表中</td></tr><tr><td align="left">links</td><td align="left">链接</td></tr><tr><td align="left">login</td><td align="left">登录</td></tr><tr><td align="left">logout</td><td align="left">退出</td></tr><tr><td align="left">logo</td><td align="left">标志</td></tr><tr><td align="left">main</td><td align="left">主体</td></tr><tr><td align="left">menu</td><td align="left">菜单</td></tr><tr><td align="left">meta</td><td align="left">作者、更新时间等信息栏，一般位于标题之下</td></tr><tr><td align="left">module</td><td align="left">模块</td></tr><tr><td align="left">more</td><td align="left">更多（展开）</td></tr><tr><td align="left">msg,message</td><td align="left">消息</td></tr><tr><td align="left">nav,navigation</td><td align="left">导航</td></tr><tr><td align="left">next</td><td align="left">下一页</td></tr><tr><td align="left">nub</td><td align="left">小块</td></tr><tr><td align="left">odd</td><td align="left">奇数，常用于多行列表或表格中</td></tr><tr><td align="left">off</td><td align="left">鼠标离开</td></tr><tr><td align="left">on</td><td align="left">鼠标移过</td></tr><tr><td align="left">output</td><td align="left">输出</td></tr><tr><td align="left">pagination</td><td align="left">分页</td></tr><tr><td align="left">pop,popup</td><td align="left">弹窗</td></tr><tr><td align="left">preview</td><td align="left">预览</td></tr><tr><td align="left">previous</td><td align="left">上一页</td></tr><tr><td align="left">primary</td><td align="left">主要</td></tr><tr><td align="left">progress</td><td align="left">进度条</td></tr><tr><td align="left">promotion</td><td align="left">促销</td></tr><tr><td align="left">rcommd,recommendations</td><td align="left">推荐</td></tr><tr><td align="left">reg,register</td><td align="left">注册</td></tr><tr><td align="left">save</td><td align="left">保存</td></tr><tr><td align="left">search</td><td align="left">搜索</td></tr><tr><td align="left">secondary</td><td align="left">次要</td></tr><tr><td align="left">section</td><td align="left">区块</td></tr><tr><td align="left">selected</td><td align="left">已选</td></tr><tr><td align="left">share</td><td align="left">分享</td></tr><tr><td align="left">show</td><td align="left">显示</td></tr><tr><td align="left">sidebar</td><td align="left">边栏，侧栏</td></tr><tr><td align="left">slide</td><td align="left">幻灯片，图片切换</td></tr><tr><td align="left">sort</td><td align="left">排序</td></tr><tr><td align="left">sub</td><td align="left">次级的，子级的</td></tr><tr><td align="left">submit</td><td align="left">提交</td></tr><tr><td align="left">subscribe</td><td align="left">订阅</td></tr><tr><td align="left">subtitle</td><td align="left">副标题</td></tr><tr><td align="left">success</td><td align="left">成功（提示）</td></tr><tr><td align="left">summary</td><td align="left">摘要</td></tr><tr><td align="left">tab</td><td align="left">标签页</td></tr><tr><td align="left">table</td><td align="left">表格</td></tr><tr><td align="left">txt,text</td><td align="left">文本</td></tr><tr><td align="left">thumbnail</td><td align="left">缩略图</td></tr><tr><td align="left">time</td><td align="left">时间</td></tr><tr><td align="left">tips</td><td align="left">提示</td></tr><tr><td align="left">title</td><td align="left">标题</td></tr><tr><td align="left">video</td><td align="left">视频</td></tr><tr><td align="left">wrap</td><td align="left">容器，包，一般用于最外层</td></tr><tr><td align="left">wrapper</td><td align="left">容器，包，一般用于最外层</td></tr></tbody></table><p>不使用 ID 选择器</p><pre><code class="css">// bad#title {  color: blue;}// good.title {  color: blue;}</code></pre><p>不要为 <code>0</code> 值设置单位</p><pre><code class="css">// bad.content {  margin-top: 0px;}// good.content {  margin-top: 0;}</code></pre><p>遵循以下的样式书写顺序</p><ol><li>布局定位属性：position / display / float / clear / visibility / overflow</li><li>盒属性：width / height / margin / padding / border / background</li><li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li><li>视觉属性：background-color / border / border-radius / box-shadow</li><li>其他属性：content / cursor / text-shadow / background:linear-gradient</li></ol><pre><code class="css">.box {  /* Positioning */  position: absolute;  top: 0;  right: 0;  bottom: 0;  left: 0;  z-index: 100;  /* Box-model */  display: block;  float: right;  width: 100px;  height: 100px;  /* Typography */  font: normal 13px &#39;Helvetica Neue&#39;, sans-serif;  line-height: 1.5;  color: #333;  text-align: center;  /* Visual */  background-color: #f5f5f5;  border: 1px solid #e5e5e5;  border-radius: 3px;  /* Misc */  opacity: 1;}</code></pre><p>嵌套选择器的深度不要超过 3 层</p><pre><code class="css">.container {  .content {    .profile {      /* STOP! */    }  }}</code></pre><p>不要使用 <code>@import</code></p><pre><code class="html">/* bad */ @import url(&quot;other.css&quot;); /* good */&lt;link rel=&quot;stylesheet&quot; href=&quot;other.css&quot; /&gt;</code></pre><p>将媒体查询语句放在靠近相关规则最近的位置</p><pre><code class="css">.element {  /* ... */}.element-avatar {  /* ... */}.element-selected {  /* ... */}@media (min-width: 480px) {  .element {    /* ... */  }  .element-avatar {    /* ... */  }  .element-selected {    /* ... */  }}</code></pre><p>使用简短的申明语句</p><pre><code class="css">// bad.content {  padding-top: 10px;  padding-bottom: 10px;  padding-left: 20px;  padding-right: 20px;}// good.content {  padding: 10px 20px;}</code></pre><p>使用 stylelint 检查样式代码</p><p><a href="https://github.com/shinnn/vscode-stylelint" target="_blank" rel="noopener">https://github.com/shinnn/vscode-stylelint</a></p><h2 id="JS-规范"><a href="#JS-规范" class="headerlink" title="JS 规范"></a>JS 规范</h2><p>使用 const 优于 let，弃用 var</p><pre><code class="javascript">// badvar name = &#39;jack&#39;let myVariable = &#39;myVariable&#39;// goodconst FIRST_US_PRESIDENT = &#39;George Washington&#39;</code></pre><p>使用字面量创建对象</p><pre><code class="javascript">// badconst a = new Object{}// goodconst obj = {}</code></pre><p>函数名或方法名使用动宾短语</p><pre><code class="javascript">// badfunction userInfo() {    ...}// goodfunction getUserInfo() {    ...}</code></pre><p>命名所有的方法包含闭包和回调, 避免匿名方法</p><p>命名方法和函数可以让你在代码运行出错时更快的找到错误</p><p>布尔值变量使用 is 开头的词组</p><pre><code class="javascript">// badconst finished = false// goodconst isFinished = false</code></pre><p>避免重复的描述对象</p><pre><code class="javascript">// badconst car = {  carMake: &#39;Honda&#39;,  carModel: &#39;Accord&#39;,  carColor: &#39;Blue&#39;}// goodconst Car = {  make: &#39;Honda&#39;,  model: &#39;Accord&#39;,  color: &#39;Blue&#39;}</code></pre><p>使用有意义可读性好的变量名</p><pre><code class="javascript">// badconst yyyymmdstr = moment().format(&#39;YYYY/MM/DD&#39;)for (var i = 0; i &lt; 525600; i++) {  runCronJob()}// goodconst yearMonthDay = moment().format(&#39;YYYY/MM/DD&#39;)const MINUTES_IN_A_YEAR = 525600for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) {  runCronJob()}</code></pre><p>将函数参数限制 2 个以内</p><pre><code class="javascript">// badfunction createMenu(title, body, buttonText, cancellable) {  ...}// goodconst menuConfig = {  title: &#39;Foo&#39;,  body: &#39;Bar&#39;,  buttonText: &#39;Baz&#39;,  cancellable: true}function createMenu(menuConfig) {  ...}</code></pre><p>封装判断条件</p><p>将多个条件的判断结果赋值给一个变量或使用一个函数返回</p><pre><code class="javascript">// badif (fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode)) {  /// ...}// goodfunction shouldShowSpinner(fsm, listNode) {  return fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode)}if (shouldShowSpinner(fsmInstance, listNodeInstance)) {  // ...}</code></pre><p>避免否定情况的判断</p><p>尽可能只使用正向的判断</p><pre><code class="javascript">// badif(!isLoading) {  ...}// goodif(isLoading) {  ...}</code></pre><p>删除无效的代码</p><p>及时删除不再被调用的代码，避免给阅读代码带来困扰</p><p>使用 <code>try/catch</code> 语句捕获可能出现的错误</p><pre><code class="js">try {  functionThatMightThrow()} catch (error) {  // 不单单只是使用 console  console.error(error)  // 更多的错误处理  notifyUserOfError(error)  // 报告错误  reportErrorToService(error)}</code></pre><p>只注释业务逻辑复杂性的代码</p><pre><code class="js">function hashIt(data) {  var hash = 0  var length = data.length  for (var i = 0; i &lt; length; i++) {    var char = data.charCodeAt(i)    hash = (hash &lt;&lt; 5) - hash + char    // Convert to 32-bit integer    hash = hash &amp; hash  }}</code></pre><h2 id="Vue-规范"><a href="#Vue-规范" class="headerlink" title="Vue 规范"></a>Vue 规范</h2><p>将组件名命名为多个单词</p><pre><code class="json">// badtodo.vue// goodtodo-item.vue</code></pre><p>使用 PascalCase 或者 kebab-case 命名组件</p><pre><code class="html">&lt;!-- bad  --&gt;components/ |- mycomponent.vue components/ |- myComponent.vue&lt;!-- good --&gt;components/ |- MyComponent.vue components/ |- my-component.vue</code></pre><p>详细定义组件的 Prop</p><pre><code class="javascript">// badprops: [&#39;status&#39;]// goodprops: {   status: {    type: String,    required: true  }}</code></pre><p>在 v-for 循环上加 key</p><pre><code class="html">&lt;!-- bad --&gt;&lt;li v-for=&quot;todo in todos&quot;&gt;  {{ todo.text }}&lt;/li&gt;&lt;!-- good --&gt;&lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;  {{ todo.text }}&lt;/li&gt;</code></pre><p>不要把 v-if 和 v-for 同时用在同一个元素上</p><pre><code class="html">&lt;!-- bad --&gt;&lt;ul&gt;  &lt;li v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; :key=&quot;user.id&quot;&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;&lt;!-- good --&gt;&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;  &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot;&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;</code></pre><p>为组件样式设置作用域</p><pre><code class="html">&lt;!-- bad --&gt;&lt;template&gt;  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style&gt;  .btn-close {    background-color: red;  }&lt;/style&gt;&lt;!--  good --&gt;&lt;template&gt;  &lt;button class=&quot;c-button c-button--close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 BEM 约定 --&gt;&lt;style&gt;  .c-button {    border: none;    border-radius: 2px;  }  .c-button--close {    background-color: red;  }&lt;/style&gt;</code></pre><p><strong>组件和实例的选项使用统一的顺序</strong></p><ol><li><strong>副作用</strong>(触发组件外的影响)</li></ol><ul><li><code>el</code></li></ul><ol start="2"><li><strong>全局感知</strong>(要求组件以外的知识)</li></ol><ul><li><code>name</code></li><li><code>parent</code></li></ul><ol start="3"><li><strong>组件类型</strong>(更改组件的类型)</li></ol><ul><li><code>functional</code></li></ul><ol start="4"><li><strong>模板修改器</strong>(改变模板的编译方式)</li></ol><ul><li><code>delimiters</code></li><li><code>comments</code></li></ul><ol start="5"><li><strong>模板依赖</strong>(模板内使用的资源)</li></ol><ul><li><code>components</code></li><li><code>directives</code></li><li><code>filters</code></li></ul><ol start="6"><li><strong>组合</strong>(向选项里合并属性)</li></ol><ul><li><code>extends</code></li><li><code>mixins</code></li></ul><ol start="7"><li><strong>接口</strong>(组件的接口)</li></ol><ul><li><code>inheritAttrs</code></li><li><code>model</code></li><li><code>props</code>/<code>propsData</code></li></ul><ol start="8"><li><strong>本地状态</strong>(本地的响应式属性)</li></ol><ul><li><code>data</code></li><li><code>computed</code></li></ul><ol start="9"><li><strong>事件</strong>(通过响应式事件触发的回调)</li></ol><ul><li><code>watch</code></li><li>生命周期钩子 (按照它们被调用的顺序)<ul><li><code>beforeCreate</code></li><li><code>created</code></li><li><code>beforeMount</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>updated</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeDestroy</code></li><li><code>destroyed</code></li></ul></li></ul><ol start="10"><li><strong>非响应式的属性</strong>(不依赖响应系统的实例属性)</li></ol><ul><li><code>methods</code></li></ul><ol start="11"><li><strong>渲染</strong>(组件输出的声明式描述)</li></ol><ul><li><code>template</code>/<code>render</code></li><li><code>renderError</code></li></ul><p><strong>元素和组件的特性使用统一的顺序</strong></p><ol><li><strong>定义</strong>(提供组件的选项)</li></ol><ul><li><code>is</code></li></ul><ol start="2"><li><strong>列表渲染</strong>(创建多个变化的相同元素)</li></ol><ul><li><code>v-for</code></li></ul><ol start="3"><li><strong>条件渲染</strong>(元素是否渲染/显示)</li></ol><ul><li><code>v-if</code></li><li><code>v-else-if</code></li><li><code>v-else</code></li><li><code>v-show</code></li><li><code>v-cloak</code></li></ul><ol start="4"><li><strong>渲染方式</strong>(改变元素的渲染方式)</li></ol><ul><li><code>v-pre</code></li><li><code>v-once</code></li></ul><ol start="5"><li><strong>全局感知</strong>(需要超越组件的知识)</li></ol><ul><li><code>id</code></li></ul><ol start="6"><li><strong>唯一的特性</strong>(需要唯一值的特性)</li></ol><ul><li><code>ref</code></li><li><code>key</code></li><li><code>slot</code></li></ul><ol start="7"><li><strong>双向绑定</strong>(把绑定和事件结合起来)</li></ol><ul><li><code>v-model</code></li></ul><ol start="8"><li><strong>其它特性</strong> (所有普通的绑定或未绑定的特性)<br></li><li><strong>事件</strong>(组件事件监听器)</li></ol><ul><li><code>v-on</code></li></ul><ol start="10"><li><strong>内容</strong>(覆写元素的内容)</li></ol><ul><li><code>v-html</code></li><li><code>v-text</code></li></ul><p>保证一个组件专注于解决一个问题</p><p>确保一个组件是独立的、可复用的、微小的和可测试的</p><p>将行内表达式转为 computed</p><pre><code class="html">// bad&lt;template&gt;  &lt;h1&gt;    {{ (new Date()).getUTCFullYear() }}  &lt;/h1&gt;&lt;/template&gt;// good&lt;template&gt;  &lt;h1&gt;    {{ year }}  &lt;/h1&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;  export default {    computed: {      year() {        return new Date().getUTCFullYear()      }    }  }&lt;/script&gt;</code></pre><p>尽可能使用 mixins</p><p>Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin</p><pre><code class="javascript">const HelloMixin = {    methods: {      hello() {        console.log(&#39;hello&#39;)    }  }}// CompA&lt;script&gt;  import HelloMixin from &#39;./HelloMixin&#39;  export default {    name: &#39;CompA&#39;,    mixins: [HelloMixin]  }&lt;/script&gt;// CompB&lt;script&gt;  import HelloMixin from &#39;./HelloMixin&#39;  export default {    name: &#39;CompB&#39;,    mixins: [HelloMixin]  }&lt;/script&gt;</code></pre><h2 id="Node-规范"><a href="#Node-规范" class="headerlink" title="Node 规范"></a>Node 规范</h2><p>require 文件夹，而不是文件</p><p>在一个文件夹中开发库/模块，放置一个文件 index.js 暴露模块的内部</p><p>使用 .npmrc 锁住依赖版本</p><p>代码必须在所有的环境中是相同的，但是 Npm 默认情况下会拿包的最新版本，配置 .npmrc 锁定依赖版本</p><pre><code class="basic">save-exact=true</code></pre><p>在 Node 外管理前端资源</p><p>使用专门的中间件（nginx，S3，CDN）服务前端内容，这是因为在处理大量静态文件的时候，由于 node 的单线程模型，它的性能很受影响</p><p>使用中间件限制并发请求</p><p>DOS 攻击非常流行而且相对容易处理。使用外部服务，比如 cloud 负载均衡, cloud 防火墙, nginx, 或者（对于小的，不是那么重要的 app）一个速率限制中间件(比如<a href="https://www.npmjs.com/package/express-rate-limit" target="_blank" rel="noopener">express-rate-limit</a>)，来实现速率限制。否则应用程序可能受到攻击, 导致拒绝服务, 在这种情况下, 真实用户会遭受服务降级或不可用。</p><p>验证传入的 JSON schemas</p><p>验证传入请求的 body payload，并确保其符合预期要求, 如果没有, 则快速报错。为了避免每个路由中繁琐的验证编码, 您可以使用基于 JSON 的轻量级验证架构，比如 <a href="https://www.npmjs.com/package/jsonschema" target="_blank" rel="noopener">jsonschema</a> or <a href="https://www.npmjs.com/package/joi" target="_blank" rel="noopener">joi</a>，否则您疏忽和宽松的方法大大增加了攻击面, 并鼓励攻击者尝试许多输入, 直到他们找到一些组合, 使应用程序崩溃。</p><p>使用非 root 用户运行 Node.js</p><p>Node.js 作为一个具有无限权限的 root 用户运行，这是一种普遍的情景。例如，在 Docker 容器中，这是默认行为。建议创建一个非 root 用户，并保存到 Docker 镜像中（下面给出了示例），或者通过调用带有”-u username” 的容器来代表此用户运行该进程，否则在服务器上运行脚本的攻击者在本地计算机上获得无限制的权利 (例如，改变 iptable，引流到他的服务器上)</p><h2 id="其它规范"><a href="#其它规范" class="headerlink" title="其它规范"></a>其它规范</h2><p>使用 jest 进行单元测试</p><p>通常只要求对一些基础/底层的组件、函数进行测试, 视情况考虑是否要测试业务代码</p><p>使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fprettier.io">Prettier</a> 格式化代码</p><p><br>所有代码格式相关的工作都可以交给 Prettier 来做</p><p>合理的图片命名</p><p>图片业务 + 图片功能类别 + 图片模块名称 + 图片精度</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://codeguide.co" target="_blank" rel="noopener">Code Guide</a></li><li><a href="https://guide.aotu.io/" target="_blank" rel="noopener">O2 前端规范文档</a></li><li><a href="https://github.com/alivebao/clean-code-js" target="_blank" rel="noopener">JavaScript 风格指南</a></li><li><a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">Vue 风格指南</a></li><li><a href="https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md" target="_blank" rel="noopener">Vue.js 组件编码规范</a></li><li><a href="https://github.com/goldbergyoni/nodebestpractices/blob/master/README.chinese.md" target="_blank" rel="noopener">Node.js 最佳实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Standard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Intl 对象进行日期时间格式化</title>
      <link href="/post/2019/10/05/js-intl/"/>
      <url>/post/2019/10/05/js-intl/</url>
      
        <content type="html"><![CDATA[<p>平时项目中要对日期时间格式化通常会使用如 <a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">dayjs</a>，<a href="https://github.com/date-fns/date-fns" target="_blank" rel="noopener">date-fns</a>，<a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment</a> 这些第三方库，但是我们可能只需要某几个方法，却安装了一整个库，大大增加了项目的体积，具体可以看这篇文章的数据 <a href="https://github.com/you-dont-need/You-Dont-Need-Momentjs" target="_blank" rel="noopener">You-Dont-Need-Momentjs</a>。本文主要说明如何使用浏览器自带的 Intl 对象进行日期时间的格式化</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时项目中要对日期时间格式化通常会使用如 <a href="https://github.com/iamkun/dayjs" target="_blank" rel="noopener">dayjs</a>，<a href="https://github.com/date-fns/date-fns" target="_blank" rel="noopener">date-fns</a>，<a href="https://github.com/moment/moment" target="_blank" rel="noopener">moment</a> 这些第三方库，但是我们可能只需要某几个方法，却安装了一整个库，大大增加了项目的体积，具体可以看这篇文章的数据 <a href="https://github.com/you-dont-need/You-Dont-Need-Momentjs" target="_blank" rel="noopener">You-Dont-Need-Momentjs</a>。本文主要说明如何使用浏览器自带的 Intl 对象进行日期时间的格式化</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl" target="_blank" rel="noopener">MDN</a></p><blockquote><p>Intl 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比、数字格式化，和日期时间格式化。Collator，NumberFormat 和 DateTimeFormat 对象的构造函数是 Intl 对象的属性。本页文档内容包括了这些属性，以及国际化使用的构造器和其他语言的方法等常见的功能。</p></blockquote><h2 id="日期时间格式化"><a href="#日期时间格式化" class="headerlink" title="日期时间格式化"></a>日期时间格式化</h2><p>要对日期时间格式化就要使用 <code>Intl.DateTimeFormat</code> 对象，它是根据语言来格式化日期和时间的构造函数。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>第一个参数是语言代码，第二个参数是构造函数的选项，都是可选的</p><pre><code class="js">new Intl.DateTimeFormat([locales[, options]])</code></pre><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><pre><code class="js">const date = new Date()console.log(new Intl.DateTimeFormat(&#39;en-US&#39;).format(date))// &quot;10/8/2019&quot;console.log(new Intl.DateTimeFormat(&#39;zh-CN&#39;).format(date))// &quot;2019/10/8&quot;console.log(  new Intl.DateTimeFormat(&#39;zh-CN&#39;, {    year: &#39;numeric&#39;,    month: &#39;numeric&#39;,    day: &#39;numeric&#39;,    weekday: &#39;long&#39;,    hour: &#39;numeric&#39;,    minute: &#39;numeric&#39;,    second: &#39;numeric&#39;,    hour12: false  }).format(date))// &quot;2019年10月8日星期二 15:07:04&quot;</code></pre><h3 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h3><p>参考文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat" target="_blank" rel="noopener">Intl.DateTimeFormat</a></p><h2 id="相对时间格式化"><a href="#相对时间格式化" class="headerlink" title="相对时间格式化"></a>相对时间格式化</h2><p>使用 Intl.RelativeTimeFormat 对相对时间进行格式化</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>同上，第一个参数是语言代码，第二个参数是构造函数的选项，都是可选的</p><pre><code class="js">new Intl.RelativeTimeFormat([locales[, options]])</code></pre><h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><pre><code class="js">const rtf = new Intl.RelativeTimeFormat(&#39;zh-CN&#39;)console.log(rtf.format(-3, &#39;day&#39;))// &quot;3天前&quot;console.log(rtf.format(3, &#39;day&#39;))// &quot;3天后&quot;console.log(rtf.format(3, &#39;minute&#39;))// &quot;3分钟后&quot;console.log(rtf.format(-3, &#39;second&#39;))// &quot;3秒钟前&quot;</code></pre><h3 id="详细使用-1"><a href="#详细使用-1" class="headerlink" title="详细使用"></a>详细使用</h3><p>参考文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RelativeTimeFormat#%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">Intl.RelativeTimeFormat</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhangxinxu.com/wordpress/2019/09/js-intl-zh/" target="_blank" rel="noopener">Intl</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl" target="_blank" rel="noopener">JS Intl 对象完整简介及在中文中的应用</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之集合</title>
      <link href="/post/2019/10/01/dsa-set/"/>
      <url>/post/2019/10/01/dsa-set/</url>
      
        <content type="html"><![CDATA[<p>集合是一种包含不同元素的数据结构，集合中的元素称之为成员。集合有两个重要的特性，一是集合中的成员是无序的，其次集合中不存在相同的成员。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集合是一种包含不同元素的数据结构，集合中的元素称之为成员。集合有两个重要的特性，一是集合中的成员是无序的，其次集合中不存在相同的成员。</p><h2 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h2><p>不包含任何成员的集合称为空集，全集则是包含可能一切成员的集合。<br>如果两个集合的成员完全相等，则两个集合相等。<br>如果一个集合的所有成员都属于另一个集合，则认为这个集合是另一个集合的子集。<br>并集-将两个集合的成员合并的操作。<br>交集-将两个集合共有的成员组成一个新的集合。<br>补集-属于一个集合而不属于另一个集合的成员。</p><h2 id="实现集合"><a href="#实现集合" class="headerlink" title="实现集合"></a>实现集合</h2><pre><code class="ts">class MySet {  data = &lt;any&gt;[]  get size() {    return this.data.length  }  add(element: any) {    if (this.data.indexOf(element) &gt; -1) {      return false    }    this.data.push(element)  }  remove(element: any) {    const index = this.data.indexOf(element)    if (index &gt; -1) {      this.data.splice(index, 1)      return true    }    return false  }  contains(element: any) {    if (this.data.indexOf(element) &gt; -1) {      return true    }    return false  }  // 并集  uinon(set: MySet) {    const newSet = new MySet()    this.data.forEach((e: any) =&gt; newSet.add(e))    for (let index = 0; index &lt; set.data.length; index++) {      const ele = set.data[index]      if (!newSet.contains(ele)) {        newSet.add(ele)      }    }    return newSet  }  // 交集  intersect(set: MySet) {    const newSet = new MySet()    this.data.forEach((ele: any) =&gt; {      if (set.contains(ele)) {        newSet.add(ele)      }    })    return newSet  }  // 判断是否是补集  subset(set: MySet) {    if (this.size &gt; set.size) {      return false    } else {      for (let index = 0; index &lt; this.data.length; index++) {        const element = this.data[index]        if (!set.contains(element)) {          return false        }      }      return true    }  }  // 返回集合中不同的成员  difference(set: MySet) {    const newSet = new MySet()    for (let index = 0; index &lt; this.data.length; index++) {      const element = this.data[index]      if (!set.contains(element)) {        newSet.add(element)      }    }    return newSet  }  show() {    return this.data.forEach((e: any) =&gt; console.log(e))  }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="ts">const setOne = new MySet()setOne.add(&#39;a&#39;)setOne.add(&#39;b&#39;)setOne.add(&#39;c&#39;)const setTwo = new MySet()setTwo.add(&#39;c&#39;)setTwo.add(&#39;d&#39;)setTwo.add(&#39;e&#39;)setTwo.add(&#39;f&#39;)const setThree = setOne.uinon(setTwo)console.log(&#39;合集&#39;)setThree.show()// 合集// a b c d e fconst setFour = setOne.intersect(setTwo)console.log(&#39;交集&#39;)setFour.show()// 交集// cconst isSubset = setOne.subset(setTwo)console.log(&#39;是否是补集&#39;, isSubset)// 是否是补集 falseconst setSix = setOne.difference(setTwo)console.log(&#39;查看集合中不同的成员&#39;)setSix.show()// 查看集合中不同的成员// a b</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Provider 管理 Flutter 应用状态 (下)</title>
      <link href="/post/2019/09/23/flutter-provider-todos-02/"/>
      <url>/post/2019/09/23/flutter-provider-todos-02/</url>
      
        <content type="html"><![CDATA[<p>紧接上篇，对于一个代办事项的新增，修改，删除功能都已经完成了，但是数据都是保存在内存中的，重新启动应用数据就重置了，为了存储数据可以将数据存到手机的存储里面或者存到远程服务器上，本文就实现如何使用 <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">dio</a> 将数据存到服务器</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>紧接上篇，对于一个代办事项的新增，修改，删除功能都已经完成了，但是数据都是保存在内存中的，重新启动应用数据就重置了，为了存储数据可以将数据存到手机的存储里面或者存到远程服务器上，本文就实现如何使用 <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">dio</a> 将数据存到服务器</p><p><a href="https://github.com/xrr2016/flutter_provider_todos/tree/http" target="_blank" rel="noopener">源码地址</a></p><h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>在 <code>pubspec.yaml</code> 添加 dio 依赖；一个存储数据的服务，我用的是 <a href="https://jsonbox.io/" target="_blank" rel="noopener">jsonbox</a></p><pre><code class="yml">dependencies:  dio: ^3.0.1</code></pre><h2 id="配置-dio"><a href="#配置-dio" class="headerlink" title="配置 dio"></a>配置 dio</h2><p>由于这个应用只有一个服务地址，所以创建一个 dio 的单例来进行请求就很好了，新建一个 request.dart 文件配置 dio，使用一个函数返回创建的 dio 实例</p><ul><li>设置基础的请求地址</li><li>设置请求超时时间</li><li>设置在调试控制台输出请求响应体方便查看请求</li></ul><p>基本设置下就可以用了，其它设置可以查看 dio 的<a href="https://pub.flutter-io.cn/packages/dio" target="_blank" rel="noopener">文档</a></p><pre><code class="dart">import &#39;package:dio/dio.dart&#39;;const DB_URL = &#39;https://jsonbox.io/box_7ea9df49e805cf99509b&#39;;Dio craeteDio() {  BaseOptions options = BaseOptions(    baseUrl: DB_URL,    connectTimeout: 5000,    receiveTimeout: 3000,  );  Dio dio = Dio(options);  dio.interceptors.add(LogInterceptor(    error: true,    request: false,    responseBody: true,    responseHeader: false,    requestHeader: false,  ));  return dio;}</code></pre><h2 id="修改-Todo-模型"><a href="#修改-Todo-模型" class="headerlink" title="修改 Todo 模型"></a>修改 Todo 模型</h2><p>由于需要从服务器上获取 todo 数据，服务返回的数据是 json 格式，所以需要在拿到数据的时候将单个 todo 的 json 数据转成 Todo 实例，新建一个 model/todo.dart 文件，比之前多的是两个方法而已，<code>fromJson</code> 这个工厂函数作用是使用 json 数据实例化一个 Todo，<code>toJson</code> 方法用来将一个 Todo 转成一个 Map 结构的数据</p><p>如果一个模型的字段较少可以手写，但是当字段较多比较复杂的时候就需要使用工具来帮助生成代码了，我使用的是 <a href="https://app.quicktype.io/" target="_blank" rel="noopener">quicktype</a> 这个工具</p><pre><code class="dart">class Todo {  String id;  bool finish;  String thing;  Todo({    this.id,    this.thing,    this.finish,  });  factory Todo.fromJson(Map&lt;String, dynamic&gt; json) =&gt; Todo(        id: json[&quot;_id&quot;].toString(),        thing: json[&quot;thing&quot;],        finish: json[&quot;finish&quot;],      );  Map&lt;String, dynamic&gt; toJson() =&gt; {        &quot;id&quot;: id,        &quot;thing&quot;: thing,        &quot;finish&quot;: finish,      };}</code></pre><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>配置好 dio 就可以在 todos.dart 向服务器发送请求了，修改 store/todos.dart，给 Todos 类添加了一个 _dio 属性用来发送请求，一个 getTodos 方法用来获取全部 todo 的列表数据，然后修改 addTodo，removeTodo，editTodo 方法使用 _dio 向服务器发送 post，delete，put 请求。</p><p>需要注意的一点是将 json 转换成实例的问题，很容易就会出现类似</p><pre><code class="dart">type &#39;List&lt;dynamic&gt;&#39; is not a subtype of type &#39;List&lt;Todo&gt;&#39;</code></pre><p>这种错误，这种都是类型转换的问题，我看了一篇文章后才算弄懂了一点 <a href="https://medium.com/flutter-community/parsing-complex-json-in-flutter-747c46655f51" target="_blank" rel="noopener">parsing-complex-json-in-flutter</a></p><pre><code class="dart">import &#39;package:dio/dio.dart&#39;;import &#39;package:flutter/foundation.dart&#39;;import &#39;../request.dart&#39;;import &#39;../model/todo.dart&#39;;class Todos extends ChangeNotifier {  List&lt;Todo&gt; _items = [];  Dio _dio = craeteDio();  get items {    return [..._items];  }  void refresh() {    notifyListeners();  }  Future&lt;List&gt; getTodos() async {    try {      Response response = await _dio.get(&#39;/todos&#39;);      final list = response.data as List;      _items = List&lt;Todo&gt;.from(list.map((i) =&gt; Todo.fromJson(i)).toList());      return items;    } on DioError catch (err) {      throw err;    }  }  Future addTodo(String thing) async {    try {      Response response = await _dio.post(&#39;/todos&#39;, data: {        &quot;thing&quot;: thing,        &quot;finish&quot;: false,      });      Todo todo = Todo(        thing: thing,        id: response.data[&quot;_id&quot;],        finish: response.data[&quot;finish&quot;],      );      _items.insert(0, todo);      refresh();    } on DioError catch (err) {      throw err;    }  }  Future removeTodo(int index) async {    try {      String todoId = _items[index].id;      await _dio.delete(&quot;/todos/$todoId&quot;);      _items.removeAt(index);      refresh();    } catch (err) {      throw err;    }  }  Future editTodo(int index, String thing, bool finish) async {    String todoId = _items[index].id;    try {      await _dio.put(&quot;/todos/$todoId&quot;, data: {        &quot;thing&quot;: thing,        &quot;finish&quot;: finish,      });      Todo todo = _items[index];      todo.thing = thing;      todo.finish = finish;      refresh();    } catch (e) {      throw e;    }  }  void toggleFinish(int index) {    final todo = _items[index];    todo.finish = !todo.finish;    refresh();  }  bool isTodoExist(String thing) {    bool isExist = false;    for (var i = 0; i &lt; _items.length; i++) {      final todo = _items[i];      if (todo.thing == thing) {        isExist = true;      }    }    return isExist;  }}</code></pre><h2 id="使用数据"><a href="#使用数据" class="headerlink" title="使用数据"></a>使用数据</h2><p>有了数据后就可以在列表页使用了，由于现在数据是从服务器返回的，会有请求耗时，所以需要使用 <code>FutureBuilder</code> 这个部件渲染列表，<code>FutureBuilder</code> 需要一个设置一个 future 来判断状态，这里自然是 Todos 类的 <code>getTodos</code> 方法返回的 Future 对象，然后 builder 就是一个函数，有两个参数，一个是 context 上下文对象，一个是 snapshot 对象，表示的是这个 future 的状态。</p><p>在 builder 方法里面用一个 switch 语句判断这个 future 的状态，根据状态返回需要渲染的部件，有以下几种状态 none（状态不存在），active（运行中），waiting（等待中），done（完成），如果都不匹配就，返回一个 null 值。</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;store/todos.dart&#39;;import &#39;widget/add_todo_button.dart&#39;;import &#39;widget/edit_todo_button.dart&#39;;import &#39;widget/remove_todo_button.dart&#39;;class TodosPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;Flutter Provider Todos&#39;)),      body: FutureBuilder(        future: Provider.of&lt;Todos&gt;(context).getTodos(),        builder: (context, snapshot) {          switch (snapshot.connectionState) {            case ConnectionState.none:              return Text(&#39;Press button to start.&#39;);            case ConnectionState.active:            case ConnectionState.waiting:              return Center(child: CircularProgressIndicator());            case ConnectionState.done:              if (snapshot.hasError) {                print(snapshot.error);                return Center(                  child: Text(                    &#39;出错了，请重试&#39;,                    style: TextStyle(fontSize: 18.0, color: Colors.red),                  ),                );              }              List items = snapshot.data;              if (items == null) {                return Center(                  child: Text(                    &#39;还没有代办事项，快去添加吧&#39;,                    style: TextStyle(fontSize: 18.0),                  ),                );              }              return ListView.builder(                  itemCount: items.length,                  itemBuilder: (_, index) {                    return Column(                      children: &lt;Widget&gt;[                        ListTile(                          title: Text(                            items[index].thing,                            style: TextStyle(                              color: items[index].finish                                  ? Colors.green                                  : Colors.grey,                            ),                          ),                          trailing: Container(                            width: 150,                            child: Row(                              mainAxisAlignment: MainAxisAlignment.end,                              children: &lt;Widget&gt;[                                EditTodoButton(todoIndex: index),                                RemoveTodoButton(todoIndex: index),                              ],                            ),                          ),                        ),                        Divider(),                      ],                    );                  });          }          return null;        },      ),      floatingActionButton: Consumer&lt;Todos&gt;(        builder: (_, todos, child) {          return AddTodoButton();        },      ),      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,    );  }}</code></pre><h2 id="修改按钮"><a href="#修改按钮" class="headerlink" title="修改按钮"></a>修改按钮</h2><p>接下来就是需要修改新增，编辑，删除代办的按钮了，同理由于现在需要跟服务端进行通信，所以需要根据请求状态来处理逻辑，主要的修改就是使用 <code>async/await</code> 语法等到一个请求完成后，根据返回值进行处理。</p><p>添加 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class AddTodoButton extends StatefulWidget {  @override  _AddTodoButtonState createState() =&gt; _AddTodoButtonState();}class _AddTodoButtonState extends State&lt;AddTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  final _controller = TextEditingController();  @override  void dispose() {    _formKey.currentState.dispose();    _controller.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (_, todos, child) {        _addTodo() async {          final isValid = _formKey.currentState.validate();          if (!isValid) {            return;          }          final thing = _controller.value.text;          try {            await todos.addTodo(thing);            Navigator.pop(context);            _controller.clear();          } catch (e) {            Scaffold.of(context).showSnackBar(              SnackBar(content: Text(&#39;新增代办失败了，请重试。&#39;)),            );          }        }        return FloatingActionButton(          child: Icon(Icons.add),          onPressed: () {            print(&#39;add todo&#39;);            return showDialog(              context: context,              builder: (BuildContext _) {                return SimpleDialog(                  title: Text(&#39;添加 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: true,                            autovalidate: false,                            controller: _controller,                            keyboardType: TextInputType.text,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              bool isExist = todos.isTodoExist(val);                              if (isExist) {                                return &#39;这件事情已经存在了&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () {                                  Navigator.pop(context);                                },                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: _addTodo,                              ),                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><p>编辑 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../model/todo.dart&#39;;import &#39;../store/todos.dart&#39;;class EditTodoButton extends StatefulWidget {  final todoIndex;  const EditTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  _EditTodoButtonState createState() =&gt; _EditTodoButtonState();}class _EditTodoButtonState extends State&lt;EditTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  @override  void dispose() {    _formKey?.currentState?.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (context, todos, child) {        final todoIndex = widget.todoIndex;        final Todo todo = todos.items[todoIndex];        return IconButton(          color: Colors.blue,          icon: Icon(Icons.edit),          onPressed: () {            return showDialog(              context: context,              builder: (_) {                return SimpleDialog(                  title: Text(&#39;编辑 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: false,                            autovalidate: false,                            initialValue: todo.thing,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            onChanged: (val) {                              todo.thing = val;                            },                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          SwitchListTile(                            title: const Text(&#39;是否完成&#39;),                            value: todo.finish,                            onChanged: (bool value) {                              todo.finish = value;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () =&gt; Navigator.pop(context),                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: () async {                                  final isValid =                                      _formKey.currentState.validate();                                  if (!isValid) {                                    return;                                  }                                  try {                                    await todos.editTodo(                                      todoIndex,                                      todo.thing,                                      todo.finish,                                    );                                    Navigator.pop(context);                                  } catch (e) {                                    Scaffold.of(context).showSnackBar(                                      SnackBar(content: Text(&#39;修改代办失败了，请重试。&#39;)),                                    );                                  }                                },                              )                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><p>删除 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../model/todo.dart&#39;;import &#39;../store/todos.dart&#39;;class RemoveTodoButton extends StatelessWidget {  final int todoIndex;  const RemoveTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(builder: (_, todos, child) {      final Todo todo = todos.items[todoIndex];      return IconButton(        color: Colors.red,        icon: Icon(Icons.delete),        onPressed: () {          print(&#39;delete todo&#39;);          showDialog(            context: context,            builder: (BuildContext context) {              return AlertDialog(                title: Text(&#39;确认删除 ${todo.thing}?&#39;),                actions: &lt;Widget&gt;[                  FlatButton(                    child: Text(                      &#39;取消&#39;,                      style: TextStyle(color: Colors.grey),                    ),                    onPressed: () =&gt; Navigator.pop(context),                  ),                  FlatButton(                    child: Text(&#39;确认&#39;),                    onPressed: () async {                      await todos.removeTodo(todoIndex);                      Navigator.pop(context);                    },                  ),                ],              );            },          );        },      );    });  }}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此所有的数据都存储在服务器上了，重启应用数据也会从服务器上获取了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Provider 管理 Flutter 应用状态 (上)</title>
      <link href="/post/2019/09/11/flutter-provider-todos-01/"/>
      <url>/post/2019/09/11/flutter-provider-todos-01/</url>
      
        <content type="html"><![CDATA[<p>一个应用内通常会有两种数据，部件内部的使用的临时性数据以及很多部件使用的全局性数据，部件内部使用的数据可以通过 StatefulWidget 来管理，但是全局性的数据如果通过从上到下传递的方式会使代码写的十分繁琐，这时就需要一个状态管理工具来进行管理了，本文说明如何使用 Provider 来管理这种应用的全局性的数据</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个应用内通常会有两种数据，部件内部的使用的临时性数据以及很多部件使用的全局性数据，部件内部使用的数据可以通过 StatefulWidget 来管理，但是全局性的数据如果通过从上到下传递的方式会使代码写的十分繁琐，这时就需要一个状态管理工具来进行管理了，本文说明如何使用 Provider 来管理这种应用的全局性的数据</p><h2 id="什么是-Provider"><a href="#什么是-Provider" class="headerlink" title="什么是 Provider"></a>什么是 Provider</h2><p>官方的定义是： A mixture between dependency injection (DI) and state management, built with widgets for widgets. 翻译过来大意是一种依赖注入和状态管理的混合方案，使用部件创建，作用于部件 😅</p><p><a href="https://pub.flutter-io.cn/documentation/provider/latest/" target="_blank" rel="noopener">官方文档</a></p><h2 id="为什么要使用-Provider"><a href="#为什么要使用-Provider" class="headerlink" title="为什么要使用 Provider"></a>为什么要使用 Provider</h2><p>应用中通常会有一些很多部件都需要的数据，如用户的登录信息，用户设置，地理位置等，如果只是使用 StatefullWeight 的话就需要将状态提升到一个父部件中然后向下进行传递，会很繁琐，使用 provider 的话可以将对一种状态数据的操作放到一个文件内，然后使用到这个数据的部件只需要使用就可以了，当数据有变化时，部件会自动的重新构建，使界面更新。</p><h2 id="一个例子-🌰"><a href="#一个例子-🌰" class="headerlink" title="一个例子 🌰"></a>一个例子 🌰</h2><p>使用一个 todo 应用来说明如何在 Flutter 应用中使用 Provider，最终的完成的应用是这样的，可以新增，编辑和删除 todo。</p><p><a href="https://github.com/xrr2016/flutter_provider_todos" target="_blank" rel="noopener">源码地址</a></p><img src="images/provider-todos.png" width="360" style="max-width:360px"><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>首先使用命令行创建一个项目</p><pre><code class="sh">flutter create flutter_provider_todos</code></pre><p>然后在项目的 pubspec.yml 添加 provider</p><pre><code class="yml">dependencies:  provider: ^3.1.0</code></pre><p>创建一个 store 文件夹以及 todos.dart 用来存放应用中需要用到的全局性数据，新建一个 widget 目录，用来存放应用中的部件以及一个显示 todo 的页面 todos_page.dart</p><img src="images/todos-folder.jpg" width="360" style="max-width:360px"><p>首先创建 todos 这个全局性的数据，修改 store/todos.dart，创建一个 Todo 类表示一个代办事项，然后实现 Todos 类， Todos 混合了 ChangeNotifier 类，为了使用 notifyListeners 方法来通知 UI 更新，因此需要导入 foundation.dart，Todos 类使用一个 _items 数组存放 Todo 数据，以及其它对 Todo 进行操作的方法。</p><pre><code class="dart">import &#39;package:flutter/foundation.dart&#39;;class Todo {  bool finish;  String thing;  Todo({    @required this.thing,    this.finish = false,  });}class Todos extends ChangeNotifier {  List&lt;Todo&gt; _items = [    Todo(thing: &#39;Play lol&#39;, finish: true),    Todo(thing: &#39;Learn flutter&#39;, finish: false),    Todo(thing: &#39;Read book&#39;, finish: false),    Todo(thing: &#39;Watch anime&#39;, finish: false),  ];  get items {    return [..._items];  }  get finishTodos {    return _items.where((todo) =&gt; todo.finish);  }  void refresh() {    notifyListeners();  }  void addTodo(Todo todo) {    _items.insert(0, todo);    refresh();  }  void removeTodo(int index) {    _items.removeAt(index);    refresh();  }  void editTodo(int index, String newThing, bool isFinish) {    Todo todo = _items[index];    todo.thing = newThing;    todo.finish = isFinish;    refresh();  }  void toggleFinish(int index) {    final todo = _items[index];    todo.finish = !todo.finish;    refresh();  }  bool isTodoExist(String thing) {    bool isExist = false;    for (var i = 0; i &lt; _items.length; i++) {      final todo = _items[i];      if (todo.thing == thing) {        isExist = true;      }    }    return isExist;  }}</code></pre><p>然后使用 provider 提供的 ChangeNotifierProvider 方法将数据注册到整个应用，如果有多个数据就需要使用 MultiProvider 方法</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;todos_page.dart&#39;;import &#39;store/todos.dart&#39;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Todos&#39;,      debugShowCheckedModeBanner: false,      theme: ThemeData(        primarySwatch: Colors.green,      ),      home: ChangeNotifierProvider(        builder: (context) =&gt; Todos(),        child: TodosPage(),      ),    );  }}</code></pre><h3 id="列表页面"><a href="#列表页面" class="headerlink" title="列表页面"></a>列表页面</h3><p>接着就是实现显示 todo 列表的页面，这个页面就是要用到 Todos 类里面的数据的部件，要使用 provider 的数据首先要导入 provider 以及对应的数据类 Todos，然后用 Consumer 加类型 Todos 来使用这个数据</p><pre><code class="dart">Consumer&lt;Todos&gt;(  builder: (ctx, todos, child) {    return YourWidget()  },)</code></pre><p>这个页面使用了一个 ListView.builder() 来渲染 Todos，然后每一项使用一个 ListTile 展示。新增，编辑和删除对应了 3 个不同的部件，分别是 AddTodoButton()，EditTodoButton()， RemoveTodoButton()</p><pre><code class="dart">// todos_page.dartimport &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;store/todos.dart&#39;;import &#39;widget/add_todo_button.dart&#39;;import &#39;widget/edit_todo_button.dart&#39;;import &#39;widget/remove_todo_button.dart&#39;;class TodosPage extends StatelessWidget {  @override  Widget build(BuildContext context) {    return Scaffold(      appBar: AppBar(title: Text(&#39;Flutter Provider Todos&#39;)),      body: Consumer&lt;Todos&gt;(        builder: (ctx, todos, child) {          List&lt;Todo&gt; items = todos.items;          return ListView.builder(            itemCount: items.length,            itemBuilder: (_, index) =&gt; Column(              children: &lt;Widget&gt;[                ListTile(                  title: Text(                    items[index].thing,                    style: TextStyle(                      color: items[index].finish ? Colors.green : Colors.grey,                    ),                  ),                  trailing: Container(                    width: 150,                    child: Row(                      mainAxisAlignment: MainAxisAlignment.end,                      children: &lt;Widget&gt;[                        EditTodoButton(todoIndex: index),                        RemoveTodoButton(todoIndex: index),                      ],                    ),                  ),                ),                Divider(),              ],            ),          );        },      ),      floatingActionButton: AddTodoButton(),      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,    );  }}</code></pre><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>接下来就是要实现这 3 个按钮了，在 widget 目录创建对应的文件，每个按钮都会使用到 Todos 类里面定义的方法，所以都需要导入 provider 和 Todos 类，点击按钮会弹出一个对话框询问对应的操作，</p><img src="images/todos-widget.jpg" style="max-width:360px"><p>添加 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class AddTodoButton extends StatefulWidget {  @override  _AddTodoButtonState createState() =&gt; _AddTodoButtonState();}class _AddTodoButtonState extends State&lt;AddTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  final _controller = TextEditingController();  @override  void dispose() {    _formKey.currentState.dispose();    _controller.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (_, todos, child) {        return FloatingActionButton(          child: Icon(Icons.add),          onPressed: () {            print(&#39;add todo&#39;);            return showDialog(              context: context,              builder: (BuildContext _) {                return SimpleDialog(                  title: Text(&#39;添加 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: true,                            autovalidate: false,                            controller: _controller,                            keyboardType: TextInputType.text,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              bool isExist = todos.isTodoExist(val);                              if (isExist) {                                return &#39;这件事情已经存在了&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () {                                  Navigator.pop(context);                                },                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: () {                                  final isValid =                                      _formKey.currentState.validate();                                  if (!isValid) {                                    return;                                  }                                  final thing = _controller.value.text;                                  todos.addTodo(Todo(                                    thing: thing,                                    finish: false,                                  ));                                  _controller.clear();                                  Navigator.pop(context);                                },                              )                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><img src="https://github.com/xrr2016/flutter_provider_todos/raw/master/add-todo.png" width="360" style="max-width:360px"><p>编辑 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class EditTodoButton extends StatefulWidget {  final todoIndex;  const EditTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  _EditTodoButtonState createState() =&gt; _EditTodoButtonState();}class _EditTodoButtonState extends State&lt;EditTodoButton&gt; {  final _formKey = GlobalKey&lt;FormState&gt;();  @override  void dispose() {    _formKey?.currentState?.dispose();    super.dispose();  }  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(      builder: (context, todos, child) {        final todoIndex = widget.todoIndex;        final Todo todo = todos.items[todoIndex];        return IconButton(          color: Colors.blue,          icon: Icon(Icons.edit),          onPressed: () {            return showDialog(              context: context,              builder: (context) {                return SimpleDialog(                  title: Text(&#39;编辑 Todo&#39;),                  contentPadding: const EdgeInsets.all(24.0),                  children: &lt;Widget&gt;[                    Form(                      key: _formKey,                      child: Column(                        children: &lt;Widget&gt;[                          TextFormField(                            autofocus: false,                            autovalidate: false,                            initialValue: todo.thing,                            decoration: InputDecoration(                              border: OutlineInputBorder(),                              labelText: &#39;输入你想做的事&#39;,                            ),                            onChanged: (val) {                              todo.thing = val;                            },                            validator: (val) {                              if (val.isEmpty) {                                return &#39;想做的事不能为空&#39;;                              }                              return null;                            },                          ),                          SizedBox(height: 20),                          SwitchListTile(                            title: const Text(&#39;是否完成&#39;),                            value: todo.finish,                            onChanged: (bool value) {                              todo.finish = value;                            },                          ),                          SizedBox(height: 20),                          Row(                            mainAxisAlignment: MainAxisAlignment.end,                            children: &lt;Widget&gt;[                              FlatButton(                                child: Text(&#39;取消&#39;),                                onPressed: () =&gt; Navigator.pop(context),                              ),                              RaisedButton(                                child: Text(                                  &#39;确定&#39;,                                  style: TextStyle(color: Colors.white),                                ),                                color: Theme.of(context).primaryColor,                                onPressed: () {                                  final isValid =                                      _formKey.currentState.validate();                                  if (!isValid) {                                    return;                                  }                                  Navigator.pop(context);                                  todos.editTodo(                                    todoIndex,                                    todo.thing,                                    todo.finish,                                  );                                },                              )                            ],                          ),                        ],                      ),                    ),                  ],                );              },            );          },        );      },    );  }}</code></pre><img src="https://github.com/xrr2016/flutter_provider_todos/raw/master/edit-todo.png" width="360" style="max-width:360px"><p>删除 Todo 按钮</p><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:provider/provider.dart&#39;;import &#39;../store/todos.dart&#39;;class RemoveTodoButton extends StatelessWidget {  final int todoIndex;  const RemoveTodoButton({Key key, this.todoIndex}) : super(key: key);  @override  Widget build(BuildContext context) {    return Consumer&lt;Todos&gt;(builder: (_, todos, child) {      final Todo todo = todos.items[todoIndex];      return IconButton(        color: Colors.red,        icon: Icon(Icons.delete),        onPressed: () {          print(&#39;delete todo&#39;);          showDialog(            context: context,            builder: (BuildContext context) {              return AlertDialog(                title: Text(&#39;确认删除 ${todo.thing}?&#39;),                actions: &lt;Widget&gt;[                  FlatButton(                    child: Text(                      &#39;取消&#39;,                      style: TextStyle(color: Colors.grey),                    ),                    onPressed: () =&gt; Navigator.pop(context),                  ),                  FlatButton(                    child: Text(&#39;确认&#39;),                    onPressed: () {                      todos.removeTodo(todoIndex);                      Navigator.pop(context);                    },                  ),                ],              );            },          );        },      );    });  }}</code></pre><img src="https://github.com/xrr2016/flutter_provider_todos/raw/master/remove-todo.png" width="360" style="max-width:360px"><p>可以看到要使用对应的方法需要的只是向对应的部件注入这个数据，然后使用就可以了</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>使用了 provider 后，数据以及对一个 Todo 的操作都放在一个文件里面了，不用在多个层级间传递数据，并且在数据变化时自动更新了 UI，所以是十分有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之哈希表</title>
      <link href="/post/2019/09/08/dsa-hash/"/>
      <url>/post/2019/09/08/dsa-hash/</url>
      
        <content type="html"><![CDATA[<p>哈希表是一种常用的数据结构，可以快速的插入和取用，但是查询数据效率低下</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>哈希表是一种常用的数据结构，可以快速的插入和取用，但是查询数据效率低下。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于数组实现哈希表，数组的长度是预先设定的，有需要是增加。最常见的是将数组的长度设为一个质数</p><pre><code class="ts">class HashTable {  table = &lt;any&gt;[]  constructor() {    this.table = Array.from({      length: 137    })  }  // 将字符串的 ASCLL 码相加对数组长度求余  hash(data: string) {    let total = 0    for (let index = 0; index &lt; data.length; index++) {      total += data.charCodeAt(index)    }    return total % this.table.length  }  // 更优的 hash 方法  betterHash(data: string) {    const H = 37    let total = 0    for (let index = 0; index &lt; data.length; index++) {      total += H * total + data.charCodeAt(index)    }    total = total % this.table.length    if (total &lt; 0) {      total += this.table.length - 1    }    return parseInt(total.toString())  }  // 存储数据  put(key: string, data: any) {    const pos = this.betterHash(key)    this.table[pos] = data  }  // 获取数据  get(key: string) {    return this.table[this.betterHash(key)]  }  // 显示数据  show() {    for (let index = 0; index &lt; this.table.length; index++) {      const item = this.table[index]      if (item) {        console.log(`${index}: ${item}`)      }    }  }}</code></pre><p>测试下</p><pre><code class="ts">const hashTable = new HashTable()hashTable.put(&#39;David&#39;, &#39;David&#39;)hashTable.put(&#39;Jennifer&#39;, &#39;Jennifer&#39;)hashTable.put(&#39;Donnie&#39;, &#39;Donnie&#39;)hashTable.put(&#39;Raymond&#39;, &#39;Raymond&#39;)hashTable.put(&#39;Cynthia&#39;, &#39;Cynthia&#39;)hashTable.put(&#39;Mike&#39;, &#39;Mike&#39;)hashTable.put(&#39;Clayton&#39;, &#39;Clayton&#39;)hashTable.put(&#39;Danny&#39;, &#39;Danny&#39;)hashTable.put(&#39;Jonathan&#39;, &#39;Jonathan&#39;)hashTable.show()console.log(&#39;Jonathan: &#39;, hashTable.get(&#39;Jonathan&#39;))</code></pre><p>输出</p><pre><code class="ts">12: Jennifer22: Raymond55: Donnie58: Clayton80: Jonathan82: Mike103: Cynthia110: DannyJonathan:  Jonathan</code></pre><h2 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h2><p>当哈希方法对于多个输入产生了相同的输出是就会出现碰撞，两种可以解决键的碰撞问题开链法以及线性探测法</p><p>开链法</p><p>开链法指的是在实现 hash 表的底层数组中，每个数组又是一个新的数据结构，比如另一个数组，这样即使有两个键 hash 后的值相同，依然被保存在同样的位置，但是他们在第二个数组中的位置是不同的。</p><p>要实现开链法，在创建存储键值的数组时，通过一个函数创建一个新的数组，然后将该数组赋值给 hash 表里的每一个元素，创建一个二维数组。</p><p>线性探测法</p><p>线性探测法指的是当发生碰撞时检查 hash 表里的下一个位置是否为空，如果为空就将数据存入该位置，如果不为空，则继续查找下一个位置，直到找到空位子为止。通常来说如果数组的大小是待存储数据个数的 1.5 倍时，那么用开链法；如果数组的大小是待存储的数据两倍以上时，那么使用线性探测法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Egg.js 中使用 Redis 缓存提升性能</title>
      <link href="/post/2019/08/31/egg-redis-cache/"/>
      <url>/post/2019/08/31/egg-redis-cache/</url>
      
        <content type="html"><![CDATA[<p>Redis 是一款开源的，基于 BSD 许可的，高级键值缓存和存储系统。Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog。你可以在这些类型上面运行原子操作，例如，追加字符串，增加哈希中的值，加入一个元素到列表，计算集合的交集、并集和差集，或者是从有序集合中获取最高排名的元素。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 是一款开源的，基于 BSD 许可的，高级键值缓存和存储系统。Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog。你可以在这些类型上面运行原子操作，例如，追加字符串，增加哈希中的值，加入一个元素到列表，计算集合的交集、并集和差集，或者是从有序集合中获取最高排名的元素。</p><p>要在 Egg.js 中使用 redis，只需要执行 <code>npm i redis</code> 命令即可。</p><p>通过一个例子来验证一下，创建一个可以返回开源仓库在 Github 上的 star 数量的数据接口，来测试使用 Redis 后带来的提升，代码地址: <a href="https://github.com/xrr2016/egg-redis-test" target="_blank" rel="noopener">https://github.com/xrr2016/egg-redis-test</a></p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>首先使用 Egg.js 创建一个项目</p><pre><code class="bash">mkdir egg-redis-test &amp;&amp; cd egg-redis-testnpm init egg --type=simplenpm i</code></pre><p>安装 redis</p><pre><code class="sh">npm i redis</code></pre><p>启动项目</p><pre><code class="bash">npm run devopen http://localhost:7001</code></pre><p>先创建 controller 和 service 目录，用来放处理请求和返回数据的方法，完成后的项目目录为</p><p><img src="/images/egg-folder.jpg" alt="folder"></p><p>修改 router.js 文件，添加路由，然后在 controller/home.js 文件实现 stars 方法</p><pre><code class="js">&#39;use strict&#39;module.exports = app =&gt; {  const { router, controller } = app  router.get(&#39;/&#39;, controller.home.index)  router.get(&#39;/stars&#39;, controller.home.stars)}</code></pre><p>修改 controller/home.js 文件，接收请求传过来的 query 参数向下传给 stars service 返回结果</p><pre><code class="js">&#39;use strict&#39;const Controller = require(&#39;egg&#39;).Controllerclass HomeController extends Controller {  async stars() {    const { ctx, service } = this    const { owner, name } = ctx.query    ctx.body = await service.home.stars(owner, name)  }}module.exports = HomeController</code></pre><p>在 service/home.js 里实现 stars 方法，需要做的就是通过 controller 传过来的 owner, name 参数，请求 Github 的接口，返回数据。</p><p>需要注意的是，这里请求的是 Github 的 graphql 接口，所以首先需要在 Github 上新建一个 token，token 不能直接写在代码里面，需要将 token 放在环境变量里，否则代码提交到 Github 后会失效。</p><p><img src="/images/redis-token.jpg" alt="token"></p><p>创建 token 后使用 <a href="https://github.com/motdotla/dotenv#readme" target="_blank" rel="noopener">dotenv</a> 保存环境变量，先安装然后在项目目录创建一个 .env 文件</p><pre><code class="bash">npm i dotenv</code></pre><p><img src="/images/env.jpg" alt="token"></p><p>然后就可以使用 egg.js 自带的 crul 方法向 Github 接口发送 post 请求，代码如下</p><pre><code class="js">&#39;use strict&#39;require(&#39;dotenv&#39;).config()const Service = require(&#39;egg&#39;).Serviceclass HomeService extends Service {  async stars(owner, name) {    function setResponse(name, stars) {      return { msg: `${name} has ${stars} stars.` }    }    const query = `      query {        repository(owner: ${owner}, name: ${name}) {          stargazers {            totalCount          }        }      }    `    const result = await this.ctx.curl(&#39;https://api.github.com/graphql&#39;, {      method: &#39;POST&#39;,      dataType: &#39;json&#39;,      headers: {        Authorization: `token ${process.env.TOKEN}`      },      data: JSON.stringify({ query }),      timeout: 10000    })    const data = result.data.data    return setResponse(name, data.repository.stargazers.totalCount)  }}module.exports = HomeService</code></pre><p>使用 postman 测试一下接口</p><p><img src="/images/redis-before.jpg" alt="folder"></p><p>耗时平均 1 秒左右，接下来就是使用 Redis 添加缓存，首先需要在本地安装 Redis，参考 <a href="https://redis.io/download" target="_blank" rel="noopener">Redis download</a>，Mac 可以直接使用 homebrew 安装</p><p>安装</p><pre><code class="bash">brew install redis</code></pre><p>启动</p><pre><code class="bash">redis-server /usr/local/etc/redis.conf</code></pre><p>进入 redis 命令行</p><pre><code class="bash">redis-cli</code></pre><p>缓存的主要逻辑就是，第一次请求完得到 Github 的数据将数据放到缓存中，再次请求的时候直接使用缓存中的数据，也需要给缓存设置一个过期时间，<br>需要从环境变量中拿到 token，post 请求的数据要用 JSON.stringify 方法传给 Github 接口，否则出现解析错误，代码如下</p><pre><code class="js">&#39;use strict&#39;require(&#39;dotenv&#39;).config()const redis = require(&#39;redis&#39;)const { promisify } = require(&#39;util&#39;)const Service = require(&#39;egg&#39;).Serviceconst REDIS_PORT = process.env.PORT || 6379const client = redis.createClient(REDIS_PORT)const getAsync = promisify(client.get).bind(client)const setexAsync = promisify(client.setex).bind(client)class HomeService extends Service {  async stars(owner, name) {    const key = `${owner}/${name}`    const stars = await getAsync(key)    function setResponse(name, stars) {      return { msg: `${name} has ${stars} stars.` }    }    if (stars !== null) {      return setResponse(name, stars)    }    const query = `      query {        repository(owner: ${owner}, name: ${name}) {          stargazers {            totalCount          }        }      }    `    const result = await this.ctx.curl(&#39;https://api.github.com/graphql&#39;, {      method: &#39;POST&#39;,      dataType: &#39;json&#39;,      headers: {        Authorization: `token ${process.env.TOKEN}`      },      data: JSON.stringify({ query }),      timeout: 10000    })    const data = result.data.data    await setexAsync(key, 10, data.repository.stargazers.totalCount)    return setResponse(name, data.repository.stargazers.totalCount)  }}module.exports = HomeService</code></pre><p>再次测试，首先把 Redis 里面的缓存清空，使用 Redis 的命令行运行</p><pre><code class="bash">FLUSHALL</code></pre><p>发送请求，第一次的耗时还是一秒多，然后在失效时间内请求，可以看到使用缓存的数据后耗时大大减少了，性能提升效果显著，实际项目可以设置一个较长的缓存失效时间</p><p><img src="/images/redis-after.jpg" alt="folder"></p><p>当然缓存过期后又要重新向 Github 发送请求了，因为 Redis 已经把数据删除了</p><p><img src="/images/redis-vue.jpg" alt="folder"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://redis.io/documentation" target="_blank" rel="noopener">Redis documentation</a></p><p><a href="https://github.com/noderedis/node_redis" target="_blank" rel="noopener">Node Redis</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之字典</title>
      <link href="/post/2019/08/28/dsa-dictionary/"/>
      <url>/post/2019/08/28/dsa-dictionary/</url>
      
        <content type="html"><![CDATA[<p>字典是一种以键值对形式存储数据的数据结构，键用来查找，值用来保存数据</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字典是一种以键值对形式存储数据的数据结构，键用来查找，值用来保存数据</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="ts">class Dictionary {  data: any[] = []  // 添加元素  add(key: any, value: any) {    this.data[key] = value  }  // 查找元素  find(key: any) {    return this.data[key]  }  // 删除元素  remove(key: any) {    delete this.data[key]  }  // 显示元素  show() {    Object.entries(this.data).forEach(item =&gt; {      console.log(&#39;key:&#39;, item[0], &#39; value:&#39;, item[1])    })  }  // 元素个数  count() {    let n = 0    Object.keys(this.data).forEach(_ =&gt; {      n += 1    })    return n  }  // 清空元素  clear() {    Object.keys(this.data).forEach((key: any) =&gt; {      delete this.data[key]    })  }}</code></pre><p>测试</p><pre><code class="ts">const dictionary = new Dictionary()dictionary.add(&#39;a&#39;, &#39;a&#39;)dictionary.add(&#39;b&#39;, &#39;b&#39;)dictionary.add(&#39;c&#39;, &#39;c&#39;)dictionary.add(&#39;d&#39;, &#39;d&#39;)dictionary.add(&#39;e&#39;, &#39;e&#39;)dictionary.show()console.log(&#39;count: &#39;, dictionary.count())dictionary.clear()console.log(&#39;clear: &#39;, dictionary.count())</code></pre><p>输出</p><pre><code class="textmate">key: a  value: akey: b  value: bkey: c  value: ckey: d  value: dkey: e  value: ecount:  5clear:  0</code></pre><p>排序字典的输出，需要重新定义 show 方法</p><pre><code class="ts">// 显示元素show() {  Object.entries(this.data)    .sort()    .forEach(item =&gt; {      console.log(&#39;key:&#39;, item[0], &#39; value:&#39;, item[1])    })}</code></pre><p>测试一下</p><pre><code class="ts">const dictionary = new Dictionary()dictionary.add(&#39;c&#39;, &#39;c&#39;)dictionary.add(&#39;a&#39;, &#39;a&#39;)dictionary.add(&#39;d&#39;, &#39;d&#39;)dictionary.add(&#39;e&#39;, &#39;e&#39;)dictionary.add(&#39;b&#39;, &#39;b&#39;)dictionary.show()</code></pre><p>输出</p><pre><code class="textmate">key: a  value: akey: b  value: bkey: c  value: ckey: d  value: dkey: e  value: e</code></pre><p>使用 Object.keys 方法拿到字典的 keys 数组后，在用 sort 方法就可以显示有序的字典输出了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之链表</title>
      <link href="/post/2019/08/25/dsa-linklist/"/>
      <url>/post/2019/08/25/dsa-linklist/</url>
      
        <content type="html"><![CDATA[<p>链表是一组节点组成的集合，每个节点都使用一个对象的引用指向它的下一个节点，指向节点的引用叫做链</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>链表是一组节点组成的集合，每个节点都使用一个对象的引用指向它的下一个节点，指向节点的引用叫做链。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 LinkedListNode 类来表示节点，使用 LinkedList 来表示链表</p><pre><code class="ts">class LinkedListNode {  element: any  next: LinkedListNode  constructor(element: any) {    this.element = element    this.next = null  }}class LinkedList {  // 头节点  head: LinkedListNode  constructor() {    this.head = new LinkedListNode(&#39;head&#39;)  }  // 查找  find(element: any) {    let currentNode: LinkedListNode = this.head    while (currentNode.element !== element) {      currentNode = currentNode.next    }    return currentNode  }  // 插入  insert(element: any, item: any) {    let newNode = new LinkedListNode(element)    let currentNode = this.find(item)    newNode.next = currentNode.next    currentNode.next = newNode  }  // 移除  remove(element: any) {    let prevNode = this.findPrevNode(element)    if (!(prevNode.next === null)) {      prevNode.next = prevNode.next.next    }  }  //  findPrevNode(element: any) {    let currentNode = this.head    while (      !(currentNode.next === null) &amp;&amp;      currentNode.next.element !== element    ) {      currentNode = currentNode.next    }    return currentNode  }  // 显示  display() {    let currentNode = this.head    while (!(currentNode.next === null)) {      console.log(currentNode.next.element)      currentNode = currentNode.next    }  }}</code></pre><p>测试</p><pre><code class="ts">const foods = new LinkedList()foods.insert(&#39;eggs&#39;, &#39;head&#39;)foods.insert(&#39;apple&#39;, &#39;eggs&#39;)foods.insert(&#39;bread&#39;, &#39;apple&#39;)foods.insert(&#39;chese&#39;, &#39;bread&#39;)foods.insert(&#39;rice&#39;, &#39;chese&#39;)foods.display()console.log(&#39;------------&#39;)foods.remove(&#39;bread&#39;)foods.display()</code></pre><p>输出</p><pre><code class="json">eggsapplebreadcheserice------------eggsapplecheserice</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>要实现双向链表首先要为 LinkedListNode 类增加一个 prev 属性</p><pre><code class="ts">class LinkedListNode {  element: any  prev: LinkedListNode  next: LinkedListNode  constructor(element: any) {    this.element = element    this.prev = null    this.next = null  }}</code></pre><p>然后修改 LinkedList 类的 insert, remove 方法</p><pre><code class="ts">class LinkedList {  // 头节点  head: LinkedListNode = new LinkedListNode(&#39;head&#39;)  // 查找  find(element: any) {    let currentNode = this.head    while (currentNode.element !== element) {      currentNode = currentNode.next    }    return currentNode  }  // 找到最后的节点  findLast() {    let currentNode = this.head    while (currentNode.next !== null) {      currentNode = currentNode.next    }    return currentNode  }  // 插入  insert(element: any, item: any) {    let newNode = new LinkedListNode(element)    let currentNode = this.find(item)    newNode.prev = currentNode    newNode.next = currentNode.next    currentNode.next = newNode  }  // 移除  remove(element: any) {    let currentNode = this.find(element)    if (currentNode.next !== null) {      currentNode.prev.next = currentNode.next      currentNode.next.prev = currentNode.prev      currentNode.next = null      currentNode.prev = null    }  }  // 显示  display() {    let currentNode = this.head    while (!(currentNode.next === null)) {      console.log(currentNode.next.element)      currentNode = currentNode.next    }  }  // 倒叙显示  displayReverse() {    let currentNode = this.findLast()    while (currentNode.prev !== null) {      console.log(currentNode.element)      currentNode = currentNode.prev    }  }}</code></pre><p>测试一下</p><pre><code class="ts">foods.insert(&#39;eggs&#39;, &#39;head&#39;)foods.insert(&#39;apple&#39;, &#39;eggs&#39;)foods.insert(&#39;bread&#39;, &#39;apple&#39;)foods.insert(&#39;chese&#39;, &#39;bread&#39;)foods.insert(&#39;rice&#39;, &#39;chese&#39;)foods.display()console.log(&#39;------------&#39;)foods.remove(&#39;bread&#39;)foods.display()console.log(&#39;------------&#39;)foods.displayReverse()</code></pre><p>输出</p><pre><code class="json">eggsapplebreadcheserice------------eggsapplecheserice------------ricecheseappleeggs</code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>创建循环链表需要让它的头节点的 next 属性指向本身， 然后修改 display 方法</p><pre><code class="ts">this.head.next = this.head // 显示display() {  let currentNode = this.head  while (currentNode.next !== null &amp;&amp; currentNode.next.element !== &#39;head&#39;) {    console.log(currentNode.next.element)    currentNode = currentNode.next  }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表是一种高效的数据结构，如果发现数组在使用时很慢，就可以考虑用链表替代它，但是如果需要对数据随机访问，数组任然是更优的选择</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Egg.js 中使用 Sequelize 的事务 Transaction</title>
      <link href="/post/2019/08/22/egg-sequelize-transaction/"/>
      <url>/post/2019/08/22/egg-sequelize-transaction/</url>
      
        <content type="html"><![CDATA[<p>在查了几遍 <a href="https://sequelize.org/" target="_blank" rel="noopener">Sequelize</a> 关于 <a href="https://sequelize.org/master/manual/transactions.html" target="_blank" rel="noopener">Transactions</a> 的文档，看了大佬同事的代码后，我终于弄懂怎么在 egg.js 框架里面使用事务了 😓</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在查了几遍 <a href="https://sequelize.org/" target="_blank" rel="noopener">Sequelize</a> 关于 <a href="https://sequelize.org/master/manual/transactions.html" target="_blank" rel="noopener">Transactions</a> 的文档，看了大佬同事的代码后，我终于弄懂怎么在 egg.js 框架里面使用事务了 😓</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>Sequelize 关于事务的示例代码是这样滴，首先通过 <code>sequelize.transaction</code> 方法创建了一个事务后，把这个事务传给需要进行操作的函数，如新增用户，给用户加属性等，但是看上去代码比较难懂</p><pre><code class="js">return sequelize.transaction().then(t =&gt; {  return User.create(    {      firstName: &#39;Bart&#39;,      lastName: &#39;Simpson&#39;    },    { transaction: t }  )    .then(user =&gt; {      return user.addSibling(        {          firstName: &#39;Lisa&#39;,          lastName: &#39;Simpson&#39;        },        { transaction: t }      )    })    .then(() =&gt; {      return t.commit()    })    .catch(err =&gt; {      return t.rollback()    })})</code></pre><p>实际使用的话需要用 <code>async/await</code> 语法让代码看起来更加清晰一点，在 egg.js 中使用的示例如下，首先需要用当前上下文中的 model 对象（就是对数据表的映射对象）创建一个事务，然后在 <code>try/catch</code> 中执行所要进行的操作，如果操作抛出了异常，那么就会回滚</p><pre><code class="js">const transaction = await this.ctx.model.transaction()try {  await this.ctx.model.create(this.ctx.request.body, { transaction })  await this.ctx.service.user.find(userId, { transaction });  await this.ctx.service.product.destory(productId, { transaction });  ...  await transaction.commit()} catch (err) {  await transaction.rollback()  throw err}</code></pre><p>用了 <code>async/await</code> 语法，代码确实清晰了很多</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之队列</title>
      <link href="/post/2019/08/18/das-queue/"/>
      <url>/post/2019/08/18/das-queue/</url>
      
        <content type="html"><![CDATA[<p>队列是一种列表，只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的的数据，先进先出，可以将队列想象成在饭店排队取餐的人群，在队伍前面的先取餐，后来的人后取餐</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>队列是一种列表，只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的的数据，先进先出，可以将队列想象成在饭店排队取餐的人群，在队伍前面的先取餐，后来的人后取餐。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用 TypeScript 实现队列</p><pre><code class="ts">class Queue {  data: Array&lt;any&gt; = []  // 入队  enqueue(element: any) {    this.data.push(element)  }  // 出队  dequeue() {    return this.data.shift()  }  // 返回第一个元素  front() {    return this.data[0]  }  // 返回最后一个元素  back() {    return this.data[this.data.length - 1]  }  // 显示队列中所有元素  toString() {    return this.data.map(ele =&gt; `${ele}`).toString()  }  // 判断队列是否为空  empty() {    if (this.data.length) {      return false    }    return true  }}</code></pre><p>测试一下</p><pre><code class="ts">const queue = new Queue()queue.enqueue(&#39;a&#39;)queue.enqueue(&#39;b&#39;)queue.enqueue(&#39;c&#39;)queue.enqueue(&#39;d&#39;)queue.enqueue(&#39;e&#39;)console.log(&#39;queue: &#39;, queue)console.log(&#39;front: &#39;, queue.front())console.log(&#39;back: &#39;, queue.back())queue.dequeue()queue.dequeue()queue.dequeue()queue.dequeue()console.log(&#39;queue: &#39;, queue)console.log(&#39;queue: &#39;, queue.empty())</code></pre><p>输出</p><pre><code class="json">queue:  Queue { data: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ] }front: aback:  equeue:  Queue { data: [ &#39;e&#39; ] }queue:  false</code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列指的是在删除队列中元素的时候需要考虑元素的优先级，优先级高的元素先出队，优先级低的后出队，同等优先级的元素按原本的顺序出队。</p><p>首先需要一个具有优先级的元素</p><pre><code class="ts">interface Element {  data: any  code: number // code 表示优先级，数值越小优先级越高，0 为最高}</code></pre><p>然后需要修改下队列的出队方法，找到队列中优先级最高的元素，然后将其移除队列</p><pre><code class="ts">dequeue() {  const codes = this.data.map(ele =&gt; ele.code)  const minCode = Math.min.apply(null, codes)  const index = this.data.findIndex(ele =&gt; ele.code === minCode)  return this.data.splice(index, 1)}</code></pre><p>测试一下</p><pre><code class="ts">const queue = new Queue()queue.enqueue({ data: &#39;a&#39;, code: 5 })queue.enqueue({ data: &#39;b&#39;, code: 4 })queue.enqueue({ data: &#39;c&#39;, code: 3 })queue.enqueue({ data: &#39;d&#39;, code: 2 })queue.enqueue({ data: &#39;e&#39;, code: 1 })console.log(&#39;queue: &#39;, queue)queue.dequeue()queue.dequeue()queue.dequeue()queue.dequeue()console.log(&#39;queue: &#39;, queue)</code></pre><p>输出</p><pre><code class="json">queue:  Queue {  data:   [     { data: &#39;a&#39;, code: 5 },     { data: &#39;b&#39;, code: 4 },     { data: &#39;c&#39;, code: 3 },     { data: &#39;d&#39;, code: 2 },     { data: &#39;e&#39;, code: 1 }  ]}queue:  Queue {  data:    [      { data: &#39;a&#39;, code: 5 },      { data: &#39;b&#39;, code: 4 }    ]}</code></pre><p>可以看到队列中剩下了优先级较低的元素</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Flutter 的安卓打包</title>
      <link href="/post/2019/08/14/flutter-android-build/"/>
      <url>/post/2019/08/14/flutter-android-build/</url>
      
        <content type="html"><![CDATA[<p>Flutter 在打包安卓应用时有两种方式 <code>flutter build apk</code> 和 <code>flutter build appbundle</code>，本文说下这两种方式有什么区别</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 在打包安卓应用时有两种方式 <code>flutter build apk</code> 和 <code>flutter build appbundle</code>，本文说下这两种方式有什么区别。</p><h2 id="Appbundle"><a href="#Appbundle" class="headerlink" title="Appbundle"></a>Appbundle</h2><p>Android App Bundle 是上传到 Google Play 用以支持 Dynamic Delivery 的文件，扩展名为 .aab，一个 bundle 包含所有应用的已编译代码和资源，但是还没有生成 apk 和 Google Play 的签名。</p><p>Google Play 的新应用服务模式称为 Dynamic Delivery（动态传送），使用你的应用包为每个用户的设备配置生成并提供优化的 APK，因此用户只下载运行应用所需的代码和资源。开发者不再需要构建，签名和管理多个 APK 来支持不同的设备，用户可以获得更小，更优化的下载。</p><p><a href="https://developer.android.com/guide/app-bundle" target="_blank" rel="noopener">官方文档</a></p><h2 id="Apk"><a href="#Apk" class="headerlink" title="Apk"></a>Apk</h2><p>如果应用不发布到 Google Play，则需要发布多个 apk，但必须自己构建，签名和管理每个 apk。</p><p>通常构建一个 apk 用以支持所有目标设备，但由于需要支持多个屏幕密度或应用程序二进制接口（ABI）的文件，这可能会导致非常大的 apk，减少 apk 大小的一种方法是创建多个 apk，在执行 <code>flutter build apk</code> 的时候可以添加构建参数 <code>--target-platform android-arm,android-arm64 --split-per-abi</code>， 这样构建出来的 apk 包含特定屏幕密度或 ABI 的文件。</p><p><a href="https://developer.android.com/studio/build/configure-apk-splits" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之栈</title>
      <link href="/post/2019/08/10/dsa-stack/"/>
      <url>/post/2019/08/10/dsa-stack/</url>
      
        <content type="html"><![CDATA[<p>栈是一种高效的数据结构，因为它只能在栈顶添加或删除，这样的操作很快，它是被称之为后入先出（LIFO，last in first out）的数据结构。可以将栈想象成一叠装菜的盘子，用的时候先拿最上面的，洗好的盘子又会放到最上面</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一种高效的数据结构，因为它只能在栈顶添加或删除，这样的操作很快，它是被称之为后入先出（LIFO，last in first out）的数据结构。可以将栈想象成一叠装菜的盘子，用的时候先拿最上面的，洗好的盘子又会放到最上面。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用 TypeScript 实现栈</p><pre><code class="ts">class Stack {  top: number = 0  data: Array&lt;any&gt; = []  get length() {    return this.top  }  // 向栈中压入一个新元素  push(element: any) {    this.data.push(element)    this.top += 1  }  // 返回栈顶元素, 同时将 top 值减 1  pop() {    this.top -= 1    return this.data.pop()  }  // 返回栈顶元素  peek() {    if (!this.data.length) {      return false    }    return this.data[this.top - 1]  }  // 清空栈  clear() {    this.top = 0  }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="ts">const stack = new Stack()stack.push(&#39;aaa&#39;)stack.push(&#39;bbb&#39;)stack.push(&#39;ccc&#39;)stack.push(&#39;ddd&#39;)console.log(&#39;执行 push 方法后\n&#39;, stack)stack.pop()console.log(&#39;执行 pop 方法后\n&#39;, stack)console.log(&#39;执行 peek 方法后返回：&#39;, stack.peek())stack.clear()console.log(&#39;执行 clear 方法后\n&#39;, stack)执行 push 方法后 Stack { data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39; ], top: 4 }执行 pop 方法后 Stack { data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39; ], top: 3 }执行 peek 方法后返回： ccc执行 clear 方法后 Stack { data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39; ], top: 0 }</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="将-10-进制的数转化为另一种进制"><a href="#将-10-进制的数转化为另一种进制" class="headerlink" title="将 10 进制的数转化为另一种进制"></a>将 10 进制的数转化为另一种进制</h3><p>此算法只针对基数为 2 ～ 9 的情况</p><pre><code class="ts">function mulBase(num: number, base: number) {  const stack = new Stack()  while (num &gt; 0) {    stack.push(num % base)    num = Math.floor((num /= base))  }  let converted = &#39;&#39;  while (stack.length &gt; 0) {    converted += stack.pop()  }  return converted}console.log(&#39;num = 2 base = 2：&#39;, mulBase(2, 2)) // 10console.log(&#39;num = 32 base = 2：&#39;, mulBase(32, 2)) // 100000console.log(&#39;num = 125 base = 8：&#39;, mulBase(125, 8)) // 175</code></pre><h3 id="判断回文"><a href="#判断回文" class="headerlink" title="判断回文"></a>判断回文</h3><pre><code class="ts">function isPalindrome(word: string) {  let rword = &#39;&#39;  const stack = new Stack()  word.split(&#39;&#39;).forEach(w =&gt; stack.push(w))  while (stack.length &gt; 0) {     rword += stack.pop()  }  if(word === rword) {    return true  }  return false}console.log(&#39;hello&#39;, isPalindrome(&#39;hello&#39;));console.log(&#39;bob&#39;, isPalindrome(&#39;bob&#39;));console.log(&#39;racecar&#39;, isPalindrome(&#39;racecar&#39;));hello falsebob trueracecar true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之列表</title>
      <link href="/post/2019/08/08/datastructure-list/"/>
      <url>/post/2019/08/08/datastructure-list/</url>
      
        <content type="html"><![CDATA[<p>列表是一种常用的数据结构，如代办事项，十佳榜单等。当不需要在一个很长的序列中查找元素，或者对其排序时，列表显得尤其有用</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>列表是一种常用的数据结构，如代办事项，十佳榜单等。当不需要在一个很长的序列中查找元素，或者对其排序时，列表显得尤其有用</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 TypeScript 实现列表类，要实现的的列表类是</p><pre><code class="ts">class List {  pos: number // 列表当前位置  listSize: number // 列表的元素个数  data: [] // 列表的数据存储位置  constructor() {    this.pos = 0    this.listSize = 0    this.data = []  }  get length() {    return this.listSize  }  // 清空列表中的所有元素  clear() {}  // 返回列表的字符串形式  toString() {}  // 返回当前位置的元素  getElement() {}  // 在现有元素后插入新元素  insert() {}  // 在列表的末尾添加新元素  append() {}  // 从列表中删除元素  remove() {}  // 将列表的当前位置移动到第一个元素  front() {}  // 将列表的当前位置移动到最后一个元素  end() {}  // 将当前位置向前移一位  prev() {}  // 将当前位置向后移一位  next() {}  // 判断是否有后一个元素  hasNext() {}  // 判断是否有前一个元素  hasPrev() {}  // 返回列表的当前位置  currentPos() {}  // 将列表的当前位置移动到指定位置  moveTo() {}}</code></pre><p>将列表类实现后</p><pre><code class="ts">class List {  pos: number // 列表当前位置  data: Array&lt;any&gt; // 列表的数据存储  listSize: number // 列表的元素个数  constructor() {    this.pos = 0    this.listSize = 0    this.data = []  }  // 返回列表的长度  get length() {    return this.listSize  }  // 返回列表的当前位置  get currentPos() {    return this.pos  }  // 清空列表中的所有元素  clear() {    delete this.data    this.data.length = this.listSize = this.pos = 0  }  // 返回列表的字符串形式  toString() {    return this.data.toString()  }  // 返回当前位置的元素  getElement() {    return this.data[this.pos]  }  // 在现有元素后插入新元素  insert(element: any, after: any) {    const index = this.findIndex(after)    if (index &gt; -1) {      this.data.splice(index + 1, 0, element)      this.listSize += 1      return true    }    return false  }  // 在列表的末尾添加新元素  append(element: any) {    this.data.push(element)    this.listSize += 1  }  // 从列表中删除元素  remove(element: any) {    const index = this.findIndex(element)    if (index &gt; -1) {      this.data.splice(index, 1)      this.listSize -= 1      return true    }    return false  }  // 判断元素是否在列表中  contains(element: any) {    return this.data.includes(element)  }  // 将列表的当前位置移动到第一个元素  front() {    this.pos = 0  }  // 将列表的当前位置移动到最后一个元素  end() {    this.pos = this.listSize - 1  }  // 将当前位置向前移一位  prev() {    if (this.pos &gt; 0) {      this.pos -= 1    }  }  // 将当前位置向后移一位  next() {    if (this.pos &lt; this.listSize) {      this.pos += 1    }  }  // 判断是否有后一个元素  hasNext() {    return this.pos &lt; this.listSize  }  // 判断是否有前一个元素  hasPrev() {    return this.pos &gt; 0  }  // 将列表的当前位置移动到指定位置  moveTo(position: number) {    if (position &gt; 0 &amp;&amp; position &lt; this.listSize) {      this.pos = position    }  }  // 查找元素位置  private findIndex(element: any) {    return this.data.findIndex(ele =&gt; element === ele)  }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="ts">const list = new List()list.append(&#39;aaa&#39;)list.append(&#39;bbb&#39;)list.append(&#39;ccc&#39;)list.append(&#39;ddd&#39;)list.append(&#39;eee&#39;)console.log(&#39;list :&#39;, list)</code></pre><p>输出</p><pre><code class="ts">list : List {  pos: 0,  listSize: 5,  data: [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39;, &#39;eee&#39; ] }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在服务器上搭建 Npm 私服</title>
      <link href="/post/2019/08/08/create-privite-npm-server/"/>
      <url>/post/2019/08/08/create-privite-npm-server/</url>
      
        <content type="html"><![CDATA[<p>部门需要建一个 npm 私服，我查了一下发现有一个很好用的开源工具 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a>，有 3 中方式可以在自己的服务器上搭建，以 Centos 为例</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>部门需要建一个 npm 私服，我查了一下发现有一个很好用的开源工具 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a>，有 3 中方式可以在自己的服务器上搭建，以 Centos 为例</p><h2 id="使用-Node-js-环境"><a href="#使用-Node-js-环境" class="headerlink" title="使用 Node.js 环境"></a>使用 Node.js 环境</h2><p>首先需要在服务器上安装 node 环境</p><pre><code class="bash">curl -sL https://rpm.nodesource.com/setup_10.x | sudo bash -</code></pre><pre><code class="bash">sudo yum install nodejs</code></pre><p>安装后检查 node 是否正确安装</p><pre><code class="bash">node -v</code></pre><p>然后安装 Verdaccio</p><pre><code class="bash">npm install -g verdaccio</code></pre><p>安装完成就可以使用了， 如果使用的是 root 用户会提示你不要使用 root 账户</p><pre><code class="bash">verdaccio</code></pre><p>但是这样退出后服务就停止了，所以需要 pm2 进行启动</p><p>全局安装 pm2</p><pre><code class="bash">npm install -g pm2</code></pre><p>使用 pm2 启动 Verdaccio</p><pre><code class="bash">pm2 start verdaccio</code></pre><h2 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h2><p>首先需要在服务器上安装 Docker，有了 Docker 之后就很简单了</p><p>拉取镜像</p><pre><code class="bash">docker pull verdaccio/verdaccio</code></pre><p>运行容器</p><pre><code class="bash">docker run -d --rm --name verdaccio -p 4873:4873 verdaccio/verdaccio</code></pre><h2 id="使用-Cloudron"><a href="#使用-Cloudron" class="headerlink" title="使用 Cloudron"></a>使用 Cloudron</h2><p>这种方式没试过，因为上面两种已经很方便了</p><p>链接 <a href="https://cloudron.io/button/org.eggertsson.verdaccio.html" target="_blank" rel="noopener">https://cloudron.io/button/org.eggertsson.verdaccio.html</a></p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>私服安装完成后可以通过 ip 地址+端口号的形式访问了 xxx.xxx.xxx.xxx:4873</p><p>要用域名访问的话就需要将自己的域名解析到服务器上去</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://verdaccio.org/docs/en/installation" target="_blank" rel="noopener">https://verdaccio.org/docs/en/installation</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter World 上线啦</title>
      <link href="/post/2019/08/03/flutter-world-release/"/>
      <url>/post/2019/08/03/flutter-world-release/</url>
      
        <content type="html"><![CDATA[<p>一大波关于 Flutter 的学习资源集合</p><a id="more"></a><h2 id="Flutter-World-上线啦！"><a href="#Flutter-World-上线啦！" class="headerlink" title="Flutter World 上线啦！"></a>Flutter World 上线啦！</h2><p>一大波关于 Flutter 的学习资源集合，想要入坑的同学快去查看吧 👌</p><p><a href="https://flutterworld.site" target="_blank" rel="noopener">https://flutterworld.site</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Centos 中安装 Java8</title>
      <link href="/post/2019/08/01/centos-install-java8/"/>
      <url>/post/2019/08/01/centos-install-java8/</url>
      
        <content type="html"><![CDATA[<p>由于要在服务器上安装 <a href="https://jenkins.io/zh/" target="_blank" rel="noopener">Jenkins</a> 所以首先要安装 java</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于要在服务器上安装 <a href="https://jenkins.io/zh/" target="_blank" rel="noopener">Jenkins</a> 所以首先要安装 java。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>安装之前最好更新下</p><pre><code class="bash">yum -y update</code></pre><h2 id="安装-Java8"><a href="#安装-Java8" class="headerlink" title="安装 Java8"></a>安装 Java8</h2><pre><code class="bash">yum install java-1.8.0-openjdk</code></pre><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><pre><code class="bash">java -version</code></pre><h2 id="设置环境变量-JAVA-HOME"><a href="#设置环境变量-JAVA-HOME" class="headerlink" title="设置环境变量 JAVA_HOME"></a>设置环境变量 JAVA_HOME</h2><p>首先找到安装 java 的位置</p><pre><code class="bash">update-alternatives --config java</code></pre><p>编辑 .bash_profile 文件</p><pre><code class="bash">vim .bash_profile</code></pre><p>添加这一行</p><pre><code class="bash">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/jre/bin/java</code></pre><p>重新执行刚修改的 .bash_profile</p><pre><code class="bash">source .bash_profile</code></pre><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><pre><code class="bash">echo $JAVA_HOME</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Flutter 应用和部件的生命周期</title>
      <link href="/post/2019/07/28/understand-flutter-lifecycle/"/>
      <url>/post/2019/07/28/understand-flutter-lifecycle/</url>
      
        <content type="html"><![CDATA[<p>在 Flutter 里面部件以及应用本身都有自己的生命周期，本文分别说明它们的生命周期</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Flutter 里面部件以及应用本身都有自己的生命周期，本文分别说明它们的生命周期</p><h2 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h2><p>在 Flutter 里面有两种部件 StatefulWidget 和 StatelessWidget，它们的生命周期分别是</p><h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p>无状态部件的生命周期很简单，首先执行构造函数然后就执行 build 方法了</p><pre><code>Constructor Functionbuild()</code></pre><h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3><p>有状态部件的生命周期会复杂一些，因为是多了状态变化。首先是构造函数，然后会初始化 State 在执行 build 方法，如果执行了 setState 方法，就要检查部件是否更新，在执行 build，最后部件销毁的时候执行 dispose 方法</p><pre><code>Constructor FunctioninitState()build()setState()didUpdateWidget()build()dispose()</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Flutter 应用本身也有自己的生命周期，要观察到这些状态的变化需要让一个有状态部件混入 <code>WidgetsBindingObserver</code>，然后在 <code>initState</code> 方法中创建一个观察者，当然部件销毁的时候需要把创建的观察者实现清除</p><ul><li><p>inactive 应用处于非活动状态，并且未接收用户输入</p></li><li><p>paused 应用当前对用户不可见，不响应用户输入，并在后台运行</p></li><li><p>resumed 应用可见并响应用户输入</p></li><li><p>suspending 应用退出了</p></li></ul><p>代码</p><pre><code>class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return MaterialApp(      title: &#39;Flutter Lifecycle&#39;,      home: MyHomePage(),    );  }}class MyHomePage extends StatefulWidget {  @override  _MyHomePageState createState() =&gt; _MyHomePageState();}class _MyHomePageState extends State&lt;MyHomePage&gt; with WidgetsBindingObserver {  @override  void initState() {    WidgetsBinding.instance.addObserver(this);    super.initState();  }  @override  void didChangeAppLifecycleState(AppLifecycleState state) {    print(state);  }  @override  void dispose() {    WidgetsBinding.instance.removeObserver(this);    super.dispose();  }  @override  Widget build(BuildContext context) {    return Scaffold();  }}</code></pre><p>可以看到在 Flutter 应用里面这些生命周期还是挺简单易懂的</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于 Workbox Strategies几种策略的解释</title>
      <link href="/post/2019/07/26/about-workbox-strategies/"/>
      <url>/post/2019/07/26/about-workbox-strategies/</url>
      
        <content type="html"><![CDATA[<p>要将自己的网站支持 PWA，需要注册一个 serviceWorker 到浏览器中，通常使用 Google 的 <a href="https://developers.google.com/web/tools/workbox/" target="_blank" rel="noopener">Workbox</a> 工具，Workbox 可以在浏览器请求资源的时候提供了几种不同的策略对请求响应，本文对几种策略进行说明</p><a id="more"></a><p>要将自己的网站支持 PWA，需要注册一个 serviceWorker 到浏览器中，通常使用 Google 的 <a href="https://developers.google.com/web/tools/workbox/" target="_blank" rel="noopener">Workbox</a> 工具，Workbox 可以在浏览器请求资源的时候提供了几种不同的策略对请求响应，本文对几种策略进行说明。</p><h2 id="StaleWhileRevalidate"><a href="#StaleWhileRevalidate" class="headerlink" title="StaleWhileRevalidate"></a>StaleWhileRevalidate</h2><p>StaleWhileRevalidate 模式允许您使用缓存的响应尽快响应请求，如果未缓存，则返回到网络请求，然后，用网络请求更新缓存。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/stale-while-revalidate.png" alt="StaleWhileRevalidate"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.StaleWhileRevalidate({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="CacheFirst"><a href="#CacheFirst" class="headerlink" title="CacheFirst"></a>CacheFirst</h2><p>如果缓存中存在响应，则将使用缓存的响应来完成请求，并且根本不会使用网络。 如果没有缓存的响应，则将通过网络请求来满足请求，并且将缓存响应，以便直接从缓存提供下一个请求。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/cache-first.png" alt="CacheFirst"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.CacheFirst({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="NetworkFirst"><a href="#NetworkFirst" class="headerlink" title="NetworkFirst"></a>NetworkFirst</h2><p>对于频繁更新的请求，网络优先策略是理想的解决方案。 默认情况下，它将尝试从网络获取最新响应，如果请求成功，它会将响应放入缓存中。 如果网络无法返回响应，则将使用缓存的响应。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/network-first.png" alt="NetworkFirst"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.NetworkFirst({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="NetworkOnly"><a href="#NetworkOnly" class="headerlink" title="NetworkOnly"></a>NetworkOnly</h2><p>仅使用网络响应请求。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/network-only.png" alt="NetworkOnly"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.NetworkOnly({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="CacheOnly"><a href="#CacheOnly" class="headerlink" title="CacheOnly"></a>CacheOnly</h2><p>仅使用缓存响应请求。不常见，但如果您有自己的预先缓存步骤，则可能很有用。</p><p><img src="https://developers.google.com/web/tools/workbox/images/modules/workbox-strategies/cache-only.png" alt="CacheOnly"></p><pre><code class="js">workbox.routing.registerRoute(  /\.(?:js|css)$/,  new workbox.strategies.CacheOnly({    cacheName: &#39;static&#39;  }))</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Workbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Travis CI 部署 Hugo 博客到 Github Pages</title>
      <link href="/post/2019/07/26/hugo-travis-github-page/"/>
      <url>/post/2019/07/26/hugo-travis-github-page/</url>
      
        <content type="html"><![CDATA[<p>原本使用的是 Netlify 去部署博客的，域名解析也是通过 Netlify 的 DNS 服务器，但是发现博客在别人的电脑上打不开…发现是域名解析的问题，所以就把博客放到 Github Pages 上了，但是这样就失去了 Netlify 提供的自动构建和部署的能力，需要自己去配置 Travis CI 实现自动部署了</p><a id="more"></a><p>原本使用的是 Netlify 去部署博客的，域名解析也是通过 Netlify 的 DNS 服务器，但是发现博客在别人的电脑上打不开…发现是域名解析的问题，所以就把博客放到 Github Pages 上了，但是这样就失去了 Netlify 提供的自动构建和部署的能力，需要自己去配置 Travis CI 实现自动部署了。</p><h2 id="预先要求"><a href="#预先要求" class="headerlink" title="预先要求"></a>预先要求</h2><ul><li>本地安装了 <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></li><li>一个 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 账号</li><li>使用 Github 账号登录 <a href="https://travis-ci.org" target="_blank" rel="noopener">Travis</a></li></ul><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>使用 Hugo 命令行工具新建自己的博客，将代码推送到自己的 Github 仓库</p><pre><code class="sh">hugo new site my-blog...git push</code></pre><h2 id="新建一个-Github-Personal-access-token"><a href="#新建一个-Github-Personal-access-token" class="headerlink" title="新建一个 Github Personal access token"></a>新建一个 Github Personal access token</h2><p>在 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a> 新建一个 Personal access token 用来发布博客到 Github Pages 时进行验证，复制生成的 token，不要刷新或离开当前页面，否则 token 就看不见了，只能重新生成</p><p><img src="/images/github-token.jpg" alt="token"></p><p>登录到 <a href="https://travis-ci.org" target="_blank" rel="noopener">Travis CI</a> 对项目进行关联 <a href="https://travis-ci.org/account/repositories" target="_blank" rel="noopener">https://travis-ci.org/account/repositories</a></p><p>完成后进入设置界面 <code>https://travis-ci.org/your-gihub-user-name/your-gihub-repo/settings</code></p><p>在 Environment Variables 填写 GITHUB_TOKEN 变量，点击 Add 按钮，这样你的环境变量就添加完成了</p><h2 id="配置-travis-yml"><a href="#配置-travis-yml" class="headerlink" title="配置 .travis.yml"></a>配置 .travis.yml</h2><p>因为 Hugo 是用 GO 语言写的，所以要配置 GO 编译环境，在 before_script 里删除了 public 文件夹，如果有自定义域名，将自定义域名输出到构建出来的 CNAME 文件里面去，记得添加 DNS 解析记录到 Gihub 去 <a href="https://help.github.com/cn/articles/using-a-custom-domain-with-github-pages" target="_blank" rel="noopener">参考</a></p><pre><code class="json">language: godist: trustysudo: falseenv:  - HUGO_VERSION=0.56.0install: truebefore_script:  - wget https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_${HUGO_VERSION}_Linux-64bit.deb  - sudo dpkg -i hugo_${HUGO_VERSION}_Linux-64bit.deb  - rm -rf public || exit 0script:  - hugo -v --gc --minify  - echo &#39;your-custom-domain.com&#39; &gt; public/CNAMEdeploy:  provider: pages  local-dir: public  skip-cleanup: true  github-token: $GITHUB_TOKEN  keep-history: true  on:    branch: masterbranches:  only:  - master</code></pre><h2 id="提交触发构建"><a href="#提交触发构建" class="headerlink" title="提交触发构建"></a>提交触发构建</h2><p>最后新建一篇文章，push 到 Github 仓库，触发 Travis 构建就可以了，以后博客进行更新后就可以自动构建发布了。</p><pre><code class="sh">hugo new posts/my-first-post.md</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hugo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于 PWA 应用的 manifest.json 文件的解释</title>
      <link href="/post/2019/07/24/about-manifest/"/>
      <url>/post/2019/07/24/about-manifest/</url>
      
        <content type="html"><![CDATA[<p>网站要支持 PWA，需要一个 <code>manifest.json</code> 文件，W3C Web App Manifest 的草案上定义了以下的字段，解释一下每个字段是什么意思。</p><a id="more"></a><p>网站要支持 PWA，需要一个 <code>manifest.json</code> 文件，W3C Web App Manifest 的草案上定义了以下的字段，解释一下每个字段是什么意思。</p><pre><code class="js">dictionary WebAppManifest {   TextDirectionType dir = &quot;auto&quot;;   DOMString lang;   USVString name;   USVString short_name;   USVString description;   sequence&lt;ImageResource&gt; icons;   sequence&lt;ImageResource&gt; screenshots;   sequence&lt;USVString&gt; categories;   DOMString iarc_rating_id;   USVString start_url;   DisplayModeType display = &quot;browser&quot;;   OrientationLockType orientation;   USVString theme_color;   USVString background_color;   USVString scope;   ServiceWorkerRegistrationObject serviceworker;   sequence&lt;ExternalApplicationResource&gt; related_applications;   boolean prefer_related_applications = &quot;false&quot;;};dictionary ImageResource {  required USVString src;  DOMString sizes;  USVString type;  USVString purpose;  USVString platform;};dictionary ServiceWorkerRegistrationObject {  required USVString src;  USVString scope;  WorkerType type = &quot;classic&quot;;  ServiceWorkerUpdateViaCache update_via_cache = &quot;imports&quot;;};dictionary ExternalApplicationResource {  required USVString platform;  USVString url;  DOMString id;  USVString min_version;  sequence&lt;Fingerprint&gt; fingerprints;};</code></pre><p><strong>dir</strong> 指定了 manifest 中具有方向性的成员的基本方向，可以设置 <code>ltr</code> 左至右, <code>rtl</code> 右至左, <code>auto</code> 没有明确方向。</p><p><strong>lang</strong> 指定 manifest 中具有方向性成员的值的主要语言（因为知道语言也可以帮助方向性）。</p><p><strong>name</strong> 表示应用的名称。</p><p><strong>short_name</strong> 表示 Web 应用程序名称的简短版本，用于没有足够空间来显示 Web 应用程序的全名的地方。</p><p><strong>description</strong> 描述 Web 应用程序的目的。</p><p><strong>scope</strong> 表示 Web 应用程序导航范围。</p><p><strong>icons</strong> icons 是 ImageResources 的数组，可以在各种情况下充当 Web 应用程序的图标表示。例如，它们可用于在其他应用程序列表中表示 Web 应用程序，或者将 Web 应用程序与 OS 的任务切换器和/或系统首选项集成。</p><pre><code class="json">{  &quot;icons&quot;: [    {      &quot;src&quot;: &quot;icon/lowres.webp&quot;,      &quot;sizes&quot;: &quot;48x48&quot;,      &quot;type&quot;: &quot;image/webp&quot;    },    {      &quot;src&quot;: &quot;icon/lowres&quot;,      &quot;sizes&quot;: &quot;48x48&quot;    },    {      &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,      &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;    },    {      &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,      &quot;sizes&quot;: &quot;257x257&quot;    }  ]}</code></pre><p><strong>display</strong> 其值是 DisplayModeType 值之一，表示开发人员对 Web 应用程序的首选显示模式。可以设置</p><ul><li>“fullscreen” 占用整个可用的显示区域；</li><li>“standalone” 使其外观和感觉就像一个独立的本机应用程序；</li><li>“minimal-ui” 类似于 standalone 模式，但为最终用户提供了一些方法来访问用于控制导航的最小 UI 元素集（即，后退，前进，重新加载以及可能以某种方式查看文档的地址）；</li><li>“browser” 使用特定于平台的约定打开 Web 应用程序，以在用户代理中打开超链接（例如，在浏览器选项卡或新窗口中）；</li></ul><p><strong>orientation</strong> Web 应用程序的所有顶级浏览上下文的默认方向。</p><p><strong>start_url</strong> 表示起始 URL 的字符串，该 URL 是用户启动 Web 应用程序时开发人员更喜欢用户代理加载的 URL（例如，当用户从设备的应用程序菜单中单击 Web 应用程序的图标时或主屏幕）。</p><p><strong>serviceworker</strong> 表示应用中 serviceWorker 的信息。</p><pre><code class="json">&quot;serviceworker&quot;: {  &quot;src&quot;: &quot;sw.js&quot;,  &quot;scope&quot;: &quot;/foo&quot;,  &quot;update_via_cache&quot;: &quot;none&quot;}</code></pre><p><strong>theme_color</strong> 应用程序上下文的默认主题颜色。</p><p><strong>related_applications</strong> 是底层应用程序平台可访问的应用程序。</p><p><strong>prefer_related_applications</strong> 表示相关应用程序是否应优先于当前的 Web 应用程序。</p><p><strong>background_color</strong> Web 应用程序的预期背景颜色。</p><p><strong>categories</strong> Web 应用程序所属的预期应用程序类别。</p><p><strong>screenshots</strong> 一个 ImageResources 数组，表示常见使用场景中的 Web 应用程序的截图。</p><p><strong>iarc_rating_id</strong> 用于确定 Web 应用程序适合的年龄。</p><p>一个完整的示例</p><pre><code class="json">{  &quot;lang&quot;: &quot;en&quot;,  &quot;dir&quot;: &quot;ltr&quot;,  &quot;name&quot;: &quot;Super Racer 3000&quot;,  &quot;description&quot;: &quot;The ultimate futuristic racing game from the future!&quot;,  &quot;short_name&quot;: &quot;Racer3K&quot;,  &quot;icons&quot;: [    {      &quot;src&quot;: &quot;icon/lowres.webp&quot;,      &quot;sizes&quot;: &quot;64x64&quot;,      &quot;type&quot;: &quot;image/webp&quot;    },    {      &quot;src&quot;: &quot;icon/lowres.png&quot;,      &quot;sizes&quot;: &quot;64x64&quot;    },    {      &quot;src&quot;: &quot;icon/hd_hi&quot;,      &quot;sizes&quot;: &quot;128x128&quot;    }  ],  &quot;scope&quot;: &quot;/racer/&quot;,  &quot;start_url&quot;: &quot;/racer/start.html&quot;,  &quot;display&quot;: &quot;fullscreen&quot;,  &quot;orientation&quot;: &quot;landscape&quot;,  &quot;theme_color&quot;: &quot;aliceblue&quot;,  &quot;background_color&quot;: &quot;red&quot;,  &quot;serviceworker&quot;: {    &quot;src&quot;: &quot;sw.js&quot;,    &quot;scope&quot;: &quot;/racer/&quot;,    &quot;update_via_cache&quot;: &quot;none&quot;  },  &quot;screenshots&quot;: [    {      &quot;src&quot;: &quot;screenshots/in-game-1x.jpg&quot;,      &quot;sizes&quot;: &quot;640x480&quot;,      &quot;type&quot;: &quot;image/jpeg&quot;    },    {      &quot;src&quot;: &quot;screenshots/in-game-2x.jpg&quot;,      &quot;sizes&quot;: &quot;1280x920&quot;,      &quot;type&quot;: &quot;image/jpeg&quot;    }  ]}</code></pre><p>要在页面是使用的话直接用<link>标签引用即可。</p><pre><code class="html">&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot; /&gt;</code></pre><p>这样浏览器就可以安装你的 Web 应用了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让 Hugo 博客支持 PWA</title>
      <link href="/post/2019/07/23/add-pwa-support-to-hugo/"/>
      <url>/post/2019/07/23/add-pwa-support-to-hugo/</url>
      
        <content type="html"><![CDATA[<p>让用 Hugo 搭建的博客支持 PWA 很简单，只需 2 个步骤即可</p><a id="more"></a><p>让用 Hugo 搭建的博客支持 PWA 很简单，只需 2 个步骤即可：</p><h2 id="添加一个-manifest-json-文件"><a href="#添加一个-manifest-json-文件" class="headerlink" title="添加一个 manifest.json 文件"></a>添加一个 manifest.json 文件</h2><p>使用 <a href="https://app-manifest.firebaseapp.com" target="_blank" rel="noopener">https://app-manifest.firebaseapp.com</a> 来生成博客的 manifest.json 文件，然后将生成出来的文件和图片放到博客的 static 目录，然后在 layout/index.html 的</p><head>标签内引用这个文件<p></p><pre><code class="html">&lt;head&gt;  ...  &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot; /&gt;  ...&lt;/head&gt;</code></pre><p>这样你的博客就可以安装到桌面了</p><h2 id="使用-Workbox-工具注册-ServiceWorker"><a href="#使用-Workbox-工具注册-ServiceWorker" class="headerlink" title="使用 Workbox 工具注册 ServiceWorker"></a>使用 Workbox 工具注册 ServiceWorker</h2><p>在 static 新建一个 <code>sw.js</code> 文件，在文件添加以下内容用来为网络请求添加缓存；主要是缓存静态资源 js，css，图片以及字体等文件，<br>详细文档可以查看 <a href="https://developers.google.cn/web/tools/workbox" target="_blank" rel="noopener">Workbox 文档</a></p><pre><code class="js">importScripts(&#39;https://cdn.jsdelivr.net/npm/workbox-cdn/workbox/workbox-sw.js&#39;)if (workbox) {  console.log(`Yay! Workbox is loaded 🎉`)  workbox.routing.registerRoute(    /\.(?:js|css)$/,    new workbox.strategies.StaleWhileRevalidate({      cacheName: &#39;static-resources&#39;    })  )  workbox.routing.registerRoute(    /\.(?:png|jpg|jpeg|svg|gif)$/,    new workbox.strategies.CacheFirst({      cacheName: &#39;image-cache&#39;,      plugins: [        new workbox.expiration.Plugin({          maxEntries: 20,          maxAgeSeconds: 7 * 24 * 60 * 60        })      ]    })  )  workbox.routing.registerRoute(    /^https:\/\/fonts\.googleapis\.com/,    new workbox.strategies.StaleWhileRevalidate({      cacheName: &#39;google-fonts-stylesheets&#39;    })  )  workbox.routing.registerRoute(    /^https:\/\/fonts\.gstatic\.com/,    new workbox.strategies.CacheFirst({      cacheName: &#39;google-fonts-webfonts&#39;,      plugins: [        new workbox.cacheableResponse.Plugin({          statuses: [0, 200]        }),        new workbox.expiration.Plugin({          maxAgeSeconds: 60 * 60 * 24 * 365,          maxEntries: 30        })      ]    })  )} else {  console.log(`Boo! Workbox didn&#39;t load 😬`)}</code></pre><p>基本完成了，可以用 Chrome 的 Audits 的工具跑了一下分，看看还有什么地方要修改的。</p></head>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解 &lt;Link&gt; 标签上 Rel=prexxx 的作用</title>
      <link href="/post/2019/07/22/understand-link-prexxx/"/>
      <url>/post/2019/07/22/understand-link-prexxx/</url>
      
        <content type="html"><![CDATA[<p>在 HTML 中<link>标签指定了当前文档与外部资源之间的关系，本文说明<link>标签的 rel 属性分别设置 dns-prefetch，preconnect，prefetch，preload，prerender 的时候有说明作用</p><a id="more"></a><p>在 HTML 中<link>标签指定了当前文档与外部资源之间的关系<br>本文说明<link>标签的 rel 属性分别设置 dns-prefetch，preconnect，prefetch，preload，prerender 的时候有说明作用</p><p>dns-prefetch：向浏览器提示需要资源，允许浏览器在用户单击链接之前进行 DNS 查找和协议握手</p><p>preconnect：向浏览器提供提示，建议它提前打开与链接网站的连接，而不泄露任何私人信息或下载任何内容，以便在遵循链接时可以更快地获取链接的内容</p><p>prefetch：建议浏览器提前获取链接资源，因为它可能是用户请求的。 从 Firefox 44 开始，将考虑 crossorigin 属性的值，从而可以进行匿名预取</p><p>preload：告诉浏览器下载资源，因为稍后在当前导航期间将需要此资源</p><p>prerender：建议浏览器提前获取链接资源，并且它还在屏幕外渲染预取内容，以便在需要时可以快速呈现给用户</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://devdocs.io/html/link_types" target="_blank" rel="noopener">link_types</a></p><p><a href="https://stackoverflow.com/questions/47273743/preconnect-vs-dns-prefetch-resource-hints" target="_blank" rel="noopener">preconnect-vs-dns-prefetch-resource-hints</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器请求耗时阶段解释</title>
      <link href="/post/2019/07/18/request-timimg/"/>
      <url>/post/2019/07/18/request-timimg/</url>
      
        <content type="html"><![CDATA[<p>对于一个浏览器网络请求耗时阶段解释</p><a id="more"></a><h3 id="Queueing"><a href="#Queueing" class="headerlink" title="Queueing"></a>Queueing</h3><p>浏览器会在以下情况时将请求加入队列，有优先级更高的请求；当请求协议是 HTTP/1.0 和 HTTP/1.1 时，同一域名下已经有 6 个 TCP 链接；浏览器在分配磁盘缓存</p><h3 id="Stalled"><a href="#Stalled" class="headerlink" title="Stalled"></a>Stalled</h3><p>由于排队中描述的任何原因，请求可能会停止</p><h3 id="DNS-Lookup"><a href="#DNS-Lookup" class="headerlink" title="DNS Lookup"></a>DNS Lookup</h3><p>浏览器正在解析请求的 IP 地址</p><h3 id="Proxy-negotiation"><a href="#Proxy-negotiation" class="headerlink" title="Proxy negotiation"></a>Proxy negotiation</h3><p>浏览器与代理服务器协商请求</p><h3 id="Request-sent"><a href="#Request-sent" class="headerlink" title="Request sent"></a>Request sent</h3><p>请求已经发出</p><h3 id="ServiceWorker-Preparation"><a href="#ServiceWorker-Preparation" class="headerlink" title="ServiceWorker Preparation"></a>ServiceWorker Preparation</h3><p>浏览器启动 service worker</p><h3 id="Request-to-ServiceWorker"><a href="#Request-to-ServiceWorker" class="headerlink" title="Request to ServiceWorker"></a>Request to ServiceWorker</h3><p>请求已经向 service worker 发出</p><h3 id="Waiting-TTFB"><a href="#Waiting-TTFB" class="headerlink" title="Waiting (TTFB)"></a>Waiting (TTFB)</h3><p>浏览器等待第一个字节返回，此时间包括 1 次往返延迟和服务器准备响应所用的时间。</p><h3 id="Content-Download"><a href="#Content-Download" class="headerlink" title="Content Download"></a>Content Download</h3><p>浏览器接收响应，下载返回内容</p><h3 id="Receiving-Push"><a href="#Receiving-Push" class="headerlink" title="Receiving Push"></a>Receiving Push</h3><p>浏览器收到通过 HTTP/2 Server Push 的响应</p><h3 id="Reading-Push"><a href="#Reading-Push" class="headerlink" title="Reading Push"></a>Reading Push</h3><p>浏览器正在读取之前获取存储到本地的数据</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 语言中的 Final 与 Const 的区别</title>
      <link href="/post/2019/07/16/dart-final-vs-const/"/>
      <url>/post/2019/07/16/dart-final-vs-const/</url>
      
        <content type="html"><![CDATA[<p>在 Dart 中有 <code>final</code> 和 <code>const</code> 两个关键字，貌似都是表示常量的，但是它们还是有区别的</p><a id="more"></a><p>在 Dart 中有 <code>final</code> 和 <code>const</code> 两个关键字，貌似都是表示常量的，但是它们还是有区别的</p><p>final 变量的值只能被设置一次； const 变量在编译时就已经固定 (const 变量是隐式 final 的类型.) 最高级 final 变量或类变量在第一次使用时被初始化。</p><p><a href="https://dart.dev/guides/language/language-tour#final-and-const" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Apple 的 Code Signing</title>
      <link href="/post/2019/07/15/code-signing/"/>
      <url>/post/2019/07/15/code-signing/</url>
      
        <content type="html"><![CDATA[<p>想要把 Flutter 写的应用运行在 iPhone 上，必须要进行 Code Signing</p><p><a href="https://developer.apple.com/support/code-signing/" target="_blank" rel="noopener">官方文档</a></p><h2 id="Code-Signing"><a href="#Code-Signing" class="headerlink" title="Code Signing"></a>Code Signing</h2><p>Code signing your app assures users that it is from a known source and the app hasn’t been modified since it was last signed. Before your app can integrate app services, be installed on a device, or be submitted to the App Store, it must be signed with a<a href="https://developer.apple.com/support/certificates/" target="_blank" rel="noopener">certificate</a>issued by Apple. For more information on how to request certificates and code sign your apps, review<a href="https://help.apple.com/xcode/mac/current/" target="_blank" rel="noopener">Xcode Help</a>.</p><h2 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h2><p>代码签名您的应用程序会向用户保证它来自已知来源，并且该应用程序自上次签名后未被修改。 在您的应用程序可以集成应用程序服务，安装在设备上或提交到 App Store 之前，必须使用 Apple 颁发的证书进行签名。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
